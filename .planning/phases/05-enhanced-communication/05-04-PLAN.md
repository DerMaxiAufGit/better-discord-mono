---
phase: 05-enhanced-communication
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/services/groupService.ts
  - backend/src/routes/groups.ts
autonomous: true

must_haves:
  truths:
    - "Group CRUD operations work (create, read, update, delete)"
    - "Member management works (add, remove, change role, ban, unban)"
    - "Invite links can be created with optional expiry and max uses"
    - "Permission checks enforce role-based access"
  artifacts:
    - path: "backend/src/services/groupService.ts"
      provides: "Group business logic"
      exports: ["createGroup", "addMember", "removeMember", "changeRole", "banUser", "unbanUser", "createInvite", "joinViaInvite"]
    - path: "backend/src/routes/groups.ts"
      provides: "REST endpoints for groups"
      contains: "fastify.post"
  key_links:
    - from: "routes/groups.ts"
      to: "services/groupService.ts"
      via: "import"
      pattern: "import.*groupService"
    - from: "services/groupService.ts"
      to: "db"
      via: "SQL queries"
      pattern: "pool.query"
---

<objective>
Create backend group service with CRUD operations, member management, and invite links.

Purpose: Enable group conversation functionality with role-based permissions
Output: Complete group management API ready for frontend integration
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-01-SUMMARY.md
@backend/src/services/messageService.ts
@backend/src/routes/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create group service with CRUD and member management</name>
  <files>backend/src/services/groupService.ts</files>
  <action>
Create groupService.ts with these functions:

```typescript
import pool from '../db'
import { Group, GroupMember, GroupRole, GroupInvite, GroupBan } from '../db/schema'
import crypto from 'crypto'

// Permission definitions
const PERMISSIONS = {
  owner: ['all'],
  admin: ['sendMessages', 'deleteMessages', 'addMembers', 'removeMembers', 'banMembers', 'changeGroupSettings'],
  moderator: ['sendMessages', 'deleteMessages', 'addMembers', 'banMembers'],
  member: ['sendMessages']
} as const

export function hasPermission(role: GroupRole, permission: string): boolean {
  const perms = PERMISSIONS[role]
  return perms.includes('all') || perms.includes(permission as any)
}

export async function createGroup(ownerId: string, name: string, description?: string): Promise<Group> {
  const result = await pool.query(
    `INSERT INTO groups (name, description, owner_id) VALUES ($1, $2, $3) RETURNING *`,
    [name, description || null, ownerId]
  )
  const group = result.rows[0]

  // Add owner as member with owner role
  await pool.query(
    `INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, 'owner')`,
    [group.id, ownerId]
  )

  return group
}

export async function getGroup(groupId: string, userId: string): Promise<Group | null> {
  // Only return if user is a member
  const result = await pool.query(
    `SELECT g.* FROM groups g
     JOIN group_members gm ON g.id = gm.group_id
     WHERE g.id = $1 AND gm.user_id = $2`,
    [groupId, userId]
  )
  return result.rows[0] || null
}

export async function updateGroup(groupId: string, userId: string, updates: Partial<Pick<Group, 'name' | 'description' | 'avatar_url'>>): Promise<Group | null> {
  const member = await getMember(groupId, userId)
  if (!member || !hasPermission(member.role, 'changeGroupSettings')) {
    return null
  }

  const setClauses: string[] = []
  const values: any[] = []
  let paramIndex = 1

  if (updates.name !== undefined) {
    setClauses.push(`name = $${paramIndex++}`)
    values.push(updates.name)
  }
  if (updates.description !== undefined) {
    setClauses.push(`description = $${paramIndex++}`)
    values.push(updates.description)
  }
  if (updates.avatar_url !== undefined) {
    setClauses.push(`avatar_url = $${paramIndex++}`)
    values.push(updates.avatar_url)
  }

  if (setClauses.length === 0) return await getGroup(groupId, userId)

  setClauses.push(`updated_at = NOW()`)
  values.push(groupId)

  const result = await pool.query(
    `UPDATE groups SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
    values
  )
  return result.rows[0]
}

export async function deleteGroup(groupId: string, userId: string): Promise<boolean> {
  const group = await getGroup(groupId, userId)
  if (!group || group.owner_id !== userId) return false

  await pool.query(`DELETE FROM groups WHERE id = $1`, [groupId])
  return true
}

export async function getMembers(groupId: string): Promise<(GroupMember & { email: string })[]> {
  const result = await pool.query(
    `SELECT gm.*, u.email FROM group_members gm
     JOIN users u ON gm.user_id = u.id
     WHERE gm.group_id = $1
     ORDER BY gm.role, gm.joined_at`,
    [groupId]
  )
  return result.rows
}

export async function getMember(groupId: string, userId: string): Promise<GroupMember | null> {
  const result = await pool.query(
    `SELECT * FROM group_members WHERE group_id = $1 AND user_id = $2`,
    [groupId, userId]
  )
  return result.rows[0] || null
}

export async function addMember(groupId: string, actorId: string, targetUserId: string, role: GroupRole = 'member'): Promise<boolean> {
  const actor = await getMember(groupId, actorId)
  if (!actor || !hasPermission(actor.role, 'addMembers')) return false

  // Check if user is banned
  const isBanned = await pool.query(
    `SELECT 1 FROM group_bans WHERE group_id = $1 AND user_id = $2`,
    [groupId, targetUserId]
  )
  if (isBanned.rows.length > 0) {
    // Auto-unban when adding back
    await pool.query(`DELETE FROM group_bans WHERE group_id = $1 AND user_id = $2`, [groupId, targetUserId])
  }

  await pool.query(
    `INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, $3)
     ON CONFLICT (group_id, user_id) DO NOTHING`,
    [groupId, targetUserId, role]
  )
  return true
}

export async function removeMember(groupId: string, actorId: string, targetUserId: string): Promise<boolean> {
  const actor = await getMember(groupId, actorId)
  const target = await getMember(groupId, targetUserId)
  if (!actor || !target) return false

  // Owner cannot be removed
  if (target.role === 'owner') return false

  // Need removeMembers permission or be removing yourself
  if (actorId !== targetUserId && !hasPermission(actor.role, 'removeMembers')) return false

  await pool.query(`DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`, [groupId, targetUserId])
  return true
}

export async function changeRole(groupId: string, actorId: string, targetUserId: string, newRole: GroupRole): Promise<boolean> {
  const actor = await getMember(groupId, actorId)
  if (!actor || actor.role !== 'owner') return false // Only owner can change roles

  // Cannot change owner role
  if (newRole === 'owner') return false

  const target = await getMember(groupId, targetUserId)
  if (!target || target.role === 'owner') return false

  await pool.query(
    `UPDATE group_members SET role = $1 WHERE group_id = $2 AND user_id = $3`,
    [newRole, groupId, targetUserId]
  )
  return true
}

export async function banUser(groupId: string, actorId: string, targetUserId: string, reason?: string): Promise<boolean> {
  const actor = await getMember(groupId, actorId)
  if (!actor || !hasPermission(actor.role, 'banMembers')) return false

  const target = await getMember(groupId, targetUserId)
  if (target && (target.role === 'owner' || target.role === 'admin')) return false // Can't ban owner/admin

  // Remove from group if member
  if (target) {
    await pool.query(`DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`, [groupId, targetUserId])
  }

  await pool.query(
    `INSERT INTO group_bans (group_id, user_id, banned_by, reason) VALUES ($1, $2, $3, $4)
     ON CONFLICT (group_id, user_id) DO NOTHING`,
    [groupId, targetUserId, actorId, reason || null]
  )
  return true
}

export async function unbanUser(groupId: string, actorId: string, targetUserId: string): Promise<boolean> {
  const actor = await getMember(groupId, actorId)
  if (!actor || !hasPermission(actor.role, 'banMembers')) return false

  await pool.query(`DELETE FROM group_bans WHERE group_id = $1 AND user_id = $2`, [groupId, targetUserId])
  return true
}

export async function createInvite(groupId: string, userId: string, expiresIn?: number, maxUses?: number): Promise<GroupInvite | null> {
  const member = await getMember(groupId, userId)
  if (!member || !hasPermission(member.role, 'addMembers')) return null

  const code = crypto.randomBytes(8).toString('base64url')
  const expiresAt = expiresIn ? new Date(Date.now() + expiresIn * 1000) : null

  const result = await pool.query(
    `INSERT INTO group_invites (group_id, code, created_by, expires_at, max_uses)
     VALUES ($1, $2, $3, $4, $5) RETURNING *`,
    [groupId, code, userId, expiresAt, maxUses || null]
  )
  return result.rows[0]
}

export async function joinViaInvite(code: string, userId: string): Promise<{ success: boolean; groupId?: string; error?: string }> {
  const result = await pool.query(
    `SELECT * FROM group_invites WHERE code = $1`,
    [code]
  )
  const invite = result.rows[0] as GroupInvite | undefined

  if (!invite) return { success: false, error: 'Invalid invite code' }
  if (invite.expires_at && new Date(invite.expires_at) < new Date()) {
    return { success: false, error: 'Invite has expired' }
  }
  if (invite.max_uses && invite.uses >= invite.max_uses) {
    return { success: false, error: 'Invite has reached max uses' }
  }

  // Check if banned
  const isBanned = await pool.query(
    `SELECT 1 FROM group_bans WHERE group_id = $1 AND user_id = $2`,
    [invite.group_id, userId]
  )
  if (isBanned.rows.length > 0) {
    return { success: false, error: 'You are banned from this group' }
  }

  // Check if already member
  const existing = await getMember(invite.group_id, userId)
  if (existing) {
    return { success: true, groupId: invite.group_id } // Already member, just return
  }

  // Add as member
  await pool.query(
    `INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, 'member')`,
    [invite.group_id, userId]
  )

  // Increment uses
  await pool.query(`UPDATE group_invites SET uses = uses + 1 WHERE id = $1`, [invite.id])

  return { success: true, groupId: invite.group_id }
}

export async function getUserGroups(userId: string): Promise<(Group & { role: GroupRole; member_count: number })[]> {
  const result = await pool.query(
    `SELECT g.*, gm.role,
       (SELECT COUNT(*) FROM group_members WHERE group_id = g.id) as member_count
     FROM groups g
     JOIN group_members gm ON g.id = gm.group_id
     WHERE gm.user_id = $1
     ORDER BY g.updated_at DESC`,
    [userId]
  )
  return result.rows
}
```
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>groupService.ts exports all CRUD and member management functions</done>
</task>

<task type="auto">
  <name>Task 2: Create group REST routes</name>
  <files>backend/src/routes/groups.ts</files>
  <action>
Create groups.ts with REST endpoints:

```typescript
import { FastifyInstance } from 'fastify'
import * as groupService from '../services/groupService'

export default async function groupRoutes(fastify: FastifyInstance) {
  // All routes require authentication
  fastify.addHook('onRequest', fastify.authenticate)

  // Create group
  fastify.post<{ Body: { name: string; description?: string } }>('/groups', async (request, reply) => {
    const { name, description } = request.body
    if (!name || name.length < 1 || name.length > 100) {
      return reply.code(400).send({ error: 'Name must be 1-100 characters' })
    }

    const group = await groupService.createGroup(request.user.id, name, description)
    return reply.code(201).send(group)
  })

  // Get user's groups
  fastify.get('/groups', async (request) => {
    return groupService.getUserGroups(request.user.id)
  })

  // Get single group
  fastify.get<{ Params: { groupId: string } }>('/groups/:groupId', async (request, reply) => {
    const group = await groupService.getGroup(request.params.groupId, request.user.id)
    if (!group) return reply.code(404).send({ error: 'Group not found' })
    return group
  })

  // Update group
  fastify.patch<{ Params: { groupId: string }; Body: { name?: string; description?: string; avatar_url?: string } }>(
    '/groups/:groupId',
    async (request, reply) => {
      const updated = await groupService.updateGroup(request.params.groupId, request.user.id, request.body)
      if (!updated) return reply.code(403).send({ error: 'Permission denied or group not found' })
      return updated
    }
  )

  // Delete group
  fastify.delete<{ Params: { groupId: string } }>('/groups/:groupId', async (request, reply) => {
    const success = await groupService.deleteGroup(request.params.groupId, request.user.id)
    if (!success) return reply.code(403).send({ error: 'Only owner can delete group' })
    return reply.code(204).send()
  })

  // Get group members
  fastify.get<{ Params: { groupId: string } }>('/groups/:groupId/members', async (request, reply) => {
    const group = await groupService.getGroup(request.params.groupId, request.user.id)
    if (!group) return reply.code(404).send({ error: 'Group not found' })
    return groupService.getMembers(request.params.groupId)
  })

  // Add member
  fastify.post<{ Params: { groupId: string }; Body: { userId: string; role?: string } }>(
    '/groups/:groupId/members',
    async (request, reply) => {
      const role = (request.body.role || 'member') as 'admin' | 'moderator' | 'member'
      const success = await groupService.addMember(request.params.groupId, request.user.id, request.body.userId, role)
      if (!success) return reply.code(403).send({ error: 'Permission denied' })
      return reply.code(201).send({ success: true })
    }
  )

  // Remove member
  fastify.delete<{ Params: { groupId: string; userId: string } }>(
    '/groups/:groupId/members/:userId',
    async (request, reply) => {
      const success = await groupService.removeMember(request.params.groupId, request.user.id, request.params.userId)
      if (!success) return reply.code(403).send({ error: 'Permission denied' })
      return reply.code(204).send()
    }
  )

  // Change member role
  fastify.patch<{ Params: { groupId: string; userId: string }; Body: { role: string } }>(
    '/groups/:groupId/members/:userId',
    async (request, reply) => {
      const role = request.body.role as 'admin' | 'moderator' | 'member'
      const success = await groupService.changeRole(request.params.groupId, request.user.id, request.params.userId, role)
      if (!success) return reply.code(403).send({ error: 'Only owner can change roles' })
      return { success: true }
    }
  )

  // Ban user
  fastify.post<{ Params: { groupId: string }; Body: { userId: string; reason?: string } }>(
    '/groups/:groupId/bans',
    async (request, reply) => {
      const success = await groupService.banUser(
        request.params.groupId,
        request.user.id,
        request.body.userId,
        request.body.reason
      )
      if (!success) return reply.code(403).send({ error: 'Permission denied' })
      return reply.code(201).send({ success: true })
    }
  )

  // Unban user
  fastify.delete<{ Params: { groupId: string; userId: string } }>(
    '/groups/:groupId/bans/:userId',
    async (request, reply) => {
      const success = await groupService.unbanUser(request.params.groupId, request.user.id, request.params.userId)
      if (!success) return reply.code(403).send({ error: 'Permission denied' })
      return reply.code(204).send()
    }
  )

  // Create invite
  fastify.post<{ Params: { groupId: string }; Body: { expiresIn?: number; maxUses?: number } }>(
    '/groups/:groupId/invites',
    async (request, reply) => {
      const invite = await groupService.createInvite(
        request.params.groupId,
        request.user.id,
        request.body.expiresIn,
        request.body.maxUses
      )
      if (!invite) return reply.code(403).send({ error: 'Permission denied' })
      return reply.code(201).send(invite)
    }
  )

  // Join via invite
  fastify.post<{ Body: { code: string } }>('/groups/join', async (request, reply) => {
    const result = await groupService.joinViaInvite(request.body.code, request.user.id)
    if (!result.success) return reply.code(400).send({ error: result.error })
    return { groupId: result.groupId }
  })
}
```

Register routes in server.ts with `fastify.register(groupRoutes)`.
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>groups.ts exports default function with all REST endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register group routes in server</name>
  <files>backend/src/server.ts</files>
  <action>
Import and register group routes in server.ts:

```typescript
import groupRoutes from './routes/groups'

// Add after existing route registrations
fastify.register(groupRoutes)
```

Ensure the import path is correct and routes are registered before server starts.
  </action>
  <verify>Run: cd backend && npm run build</verify>
  <done>Server registers group routes, backend builds successfully</done>
</task>

</tasks>

<verification>
1. Backend TypeScript compiles without errors
2. groupService.ts exports all required functions
3. groups.ts has all REST endpoints with proper authentication
4. Server.ts imports and registers group routes
</verification>

<success_criteria>
- POST /groups creates group with owner as first member
- GET /groups returns user's groups with member counts
- Member management endpoints enforce role-based permissions
- Invite links work with expiry and max uses
- Ban prevents rejoin via invite
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-04-SUMMARY.md`
</output>
