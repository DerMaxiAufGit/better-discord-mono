---
phase: 05-enhanced-communication
plan: 08
type: execute
wave: 3
depends_on: ["05-05"]
files_modified:
  - frontend/src/lib/crypto/fileEncryption.ts
  - frontend/src/stores/fileStore.ts
  - frontend/src/lib/file/chunkedUpload.ts
autonomous: true

must_haves:
  truths:
    - "Files encrypted with SecretStream API in 64KB chunks"
    - "File store tracks upload/download progress"
    - "Encrypted files uploaded as multipart with encryption header"
  artifacts:
    - path: "frontend/src/lib/crypto/fileEncryption.ts"
      provides: "SecretStream file encryption"
      exports: ["encryptFile", "decryptFile"]
    - path: "frontend/src/stores/fileStore.ts"
      provides: "Upload/download state management"
      exports: ["useFileStore"]
    - path: "frontend/src/lib/file/chunkedUpload.ts"
      provides: "Multipart upload helper"
      exports: ["uploadFile", "downloadFile"]
  key_links:
    - from: "fileStore.ts"
      to: "chunkedUpload.ts"
      via: "uploadFile import"
      pattern: "import.*chunkedUpload"
    - from: "chunkedUpload.ts"
      to: "fileEncryption.ts"
      via: "encryptFile import"
      pattern: "import.*fileEncryption"
---

<objective>
Create frontend file encryption and upload/download infrastructure.

Purpose: Enable E2E encrypted file sharing in conversations
Output: File encryption utilities and upload/download with progress tracking
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-05-SUMMARY.md
@frontend/src/lib/crypto/libsodium.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file encryption utilities</name>
  <files>frontend/src/lib/crypto/fileEncryption.ts</files>
  <action>
Create fileEncryption.ts using libsodium SecretStream API:

```typescript
import { initSodium } from './libsodium'

const CHUNK_SIZE = 64 * 1024 // 64KB chunks

export interface EncryptedFileResult {
  header: Uint8Array
  key: Uint8Array
  encryptedData: Uint8Array
}

/**
 * Encrypt a file using SecretStream (XChaCha20-Poly1305 streaming).
 * Returns header, key, and encrypted data.
 */
export async function encryptFile(file: File): Promise<EncryptedFileResult> {
  const sodium = await initSodium()

  // Generate encryption key
  const key = sodium.randombytes_buf(sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES)

  // Initialize push state
  const { state, header } = sodium.crypto_secretstream_xchacha20poly1305_init_push(key)

  const fileBuffer = await file.arrayBuffer()
  const fileData = new Uint8Array(fileBuffer)

  const encryptedChunks: Uint8Array[] = []

  // Process in chunks
  for (let offset = 0; offset < fileData.length; offset += CHUNK_SIZE) {
    const chunk = fileData.slice(offset, Math.min(offset + CHUNK_SIZE, fileData.length))
    const isLastChunk = offset + CHUNK_SIZE >= fileData.length

    const tag = isLastChunk
      ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
      : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE

    const encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(
      state,
      chunk,
      null,
      tag
    )

    encryptedChunks.push(encryptedChunk)
  }

  // Combine encrypted chunks
  const totalLength = encryptedChunks.reduce((sum, chunk) => sum + chunk.length, 0)
  const encryptedData = new Uint8Array(totalLength)
  let position = 0
  for (const chunk of encryptedChunks) {
    encryptedData.set(chunk, position)
    position += chunk.length
  }

  return { header, key, encryptedData }
}

/**
 * Decrypt a file using SecretStream.
 */
export async function decryptFile(
  header: Uint8Array,
  key: Uint8Array,
  encryptedData: Uint8Array
): Promise<Uint8Array> {
  const sodium = await initSodium()

  // Initialize pull state
  const state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key)

  const decryptedChunks: Uint8Array[] = []

  // Encrypted chunk size = plaintext + ABYTES
  const encryptedChunkSize = CHUNK_SIZE + sodium.crypto_secretstream_xchacha20poly1305_ABYTES

  for (let offset = 0; offset < encryptedData.length; offset += encryptedChunkSize) {
    const chunk = encryptedData.slice(offset, Math.min(offset + encryptedChunkSize, encryptedData.length))

    const result = sodium.crypto_secretstream_xchacha20poly1305_pull(state, chunk)

    if (!result) {
      throw new Error('Decryption failed - authentication error')
    }

    decryptedChunks.push(result.message)

    if (result.tag === sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL) {
      break
    }
  }

  // Combine decrypted chunks
  const totalLength = decryptedChunks.reduce((sum, chunk) => sum + chunk.length, 0)
  const decryptedData = new Uint8Array(totalLength)
  let position = 0
  for (const chunk of decryptedChunks) {
    decryptedData.set(chunk, position)
    position += chunk.length
  }

  return decryptedData
}

/**
 * Encrypt the file key for a specific recipient using their session key.
 */
export async function encryptFileKey(fileKey: Uint8Array, sessionKey: Uint8Array): Promise<string> {
  const sodium = await initSodium()

  const nonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES)
  const encrypted = sodium.crypto_secretbox_easy(fileKey, nonce, sessionKey)

  // Combine nonce + encrypted
  const combined = new Uint8Array(nonce.length + encrypted.length)
  combined.set(nonce)
  combined.set(encrypted, nonce.length)

  return sodium.to_base64(combined)
}

/**
 * Decrypt the file key using session key.
 */
export async function decryptFileKey(encryptedKey: string, sessionKey: Uint8Array): Promise<Uint8Array> {
  const sodium = await initSodium()

  const combined = sodium.from_base64(encryptedKey)
  const nonce = combined.slice(0, sodium.crypto_secretbox_NONCEBYTES)
  const encrypted = combined.slice(sodium.crypto_secretbox_NONCEBYTES)

  const decrypted = sodium.crypto_secretbox_open_easy(encrypted, nonce, sessionKey)

  if (!decrypted) {
    throw new Error('Failed to decrypt file key')
  }

  return decrypted
}
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>fileEncryption.ts exports encryptFile, decryptFile, encryptFileKey, decryptFileKey</done>
</task>

<task type="auto">
  <name>Task 2: Create file store</name>
  <files>frontend/src/stores/fileStore.ts</files>
  <action>
Create fileStore.ts for upload/download progress tracking:

```typescript
import { create } from 'zustand'

export type FileStatus = 'pending' | 'encrypting' | 'uploading' | 'downloading' | 'decrypting' | 'complete' | 'error'

export interface FileUpload {
  id: string // temp ID until server responds
  file: File
  status: FileStatus
  progress: number // 0-100
  error?: string
  serverId?: string // ID from server after upload
}

export interface FileDownload {
  id: string // server file ID
  filename: string
  status: FileStatus
  progress: number
  error?: string
  blob?: Blob // decrypted file data
  url?: string // object URL for download
}

interface FileState {
  uploads: Map<string, FileUpload>
  downloads: Map<string, FileDownload>

  // Upload actions
  startUpload: (file: File) => string // returns temp ID
  updateUploadStatus: (id: string, status: FileStatus, progress?: number) => void
  completeUpload: (tempId: string, serverId: string) => void
  failUpload: (id: string, error: string) => void
  removeUpload: (id: string) => void

  // Download actions
  startDownload: (id: string, filename: string) => void
  updateDownloadStatus: (id: string, status: FileStatus, progress?: number) => void
  completeDownload: (id: string, blob: Blob) => void
  failDownload: (id: string, error: string) => void
  removeDownload: (id: string) => void

  // Cleanup
  clearAll: () => void
}

export const useFileStore = create<FileState>((set, get) => ({
  uploads: new Map(),
  downloads: new Map(),

  startUpload: (file) => {
    const id = `upload-${Date.now()}-${Math.random().toString(36).slice(2)}`
    set((state) => ({
      uploads: new Map(state.uploads).set(id, {
        id,
        file,
        status: 'pending',
        progress: 0
      })
    }))
    return id
  },

  updateUploadStatus: (id, status, progress) => {
    set((state) => {
      const upload = state.uploads.get(id)
      if (!upload) return state

      return {
        uploads: new Map(state.uploads).set(id, {
          ...upload,
          status,
          progress: progress ?? upload.progress
        })
      }
    })
  },

  completeUpload: (tempId, serverId) => {
    set((state) => {
      const upload = state.uploads.get(tempId)
      if (!upload) return state

      return {
        uploads: new Map(state.uploads).set(tempId, {
          ...upload,
          status: 'complete',
          progress: 100,
          serverId
        })
      }
    })
  },

  failUpload: (id, error) => {
    set((state) => {
      const upload = state.uploads.get(id)
      if (!upload) return state

      return {
        uploads: new Map(state.uploads).set(id, {
          ...upload,
          status: 'error',
          error
        })
      }
    })
  },

  removeUpload: (id) => {
    set((state) => {
      const uploads = new Map(state.uploads)
      uploads.delete(id)
      return { uploads }
    })
  },

  startDownload: (id, filename) => {
    set((state) => ({
      downloads: new Map(state.downloads).set(id, {
        id,
        filename,
        status: 'pending',
        progress: 0
      })
    }))
  },

  updateDownloadStatus: (id, status, progress) => {
    set((state) => {
      const download = state.downloads.get(id)
      if (!download) return state

      return {
        downloads: new Map(state.downloads).set(id, {
          ...download,
          status,
          progress: progress ?? download.progress
        })
      }
    })
  },

  completeDownload: (id, blob) => {
    set((state) => {
      const download = state.downloads.get(id)
      if (!download) return state

      const url = URL.createObjectURL(blob)

      return {
        downloads: new Map(state.downloads).set(id, {
          ...download,
          status: 'complete',
          progress: 100,
          blob,
          url
        })
      }
    })
  },

  failDownload: (id, error) => {
    set((state) => {
      const download = state.downloads.get(id)
      if (!download) return state

      return {
        downloads: new Map(state.downloads).set(id, {
          ...download,
          status: 'error',
          error
        })
      }
    })
  },

  removeDownload: (id) => {
    set((state) => {
      const download = state.downloads.get(id)
      if (download?.url) {
        URL.revokeObjectURL(download.url)
      }

      const downloads = new Map(state.downloads)
      downloads.delete(id)
      return { downloads }
    })
  },

  clearAll: () => {
    // Revoke all URLs
    const state = get()
    for (const download of state.downloads.values()) {
      if (download.url) {
        URL.revokeObjectURL(download.url)
      }
    }

    set({ uploads: new Map(), downloads: new Map() })
  }
}))
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>fileStore.ts exports useFileStore with upload/download tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create upload/download helpers</name>
  <files>frontend/src/lib/file/chunkedUpload.ts</files>
  <action>
Create frontend/src/lib/file/ directory and chunkedUpload.ts:

```typescript
import { encryptFile, decryptFile } from '@/lib/crypto/fileEncryption'
import { useFileStore } from '@/stores/fileStore'
import { useAuthStore } from '@/stores/auth'

const API_BASE = '/api'

interface UploadResult {
  id: string
  filename: string
  mimeType: string
  sizeBytes: number
}

/**
 * Encrypt and upload a file to the server.
 */
export async function uploadFile(
  file: File,
  conversationId?: string
): Promise<UploadResult> {
  const fileStore = useFileStore.getState()
  const token = useAuthStore.getState().accessToken

  const tempId = fileStore.startUpload(file)

  try {
    // Encrypt file
    fileStore.updateUploadStatus(tempId, 'encrypting', 10)
    const { header, encryptedData } = await encryptFile(file)
    fileStore.updateUploadStatus(tempId, 'encrypting', 50)

    // Prepare form data
    const formData = new FormData()
    formData.append('file', new Blob([encryptedData]), file.name)
    formData.append('encryptionHeader', btoa(String.fromCharCode(...header)))

    // Upload
    fileStore.updateUploadStatus(tempId, 'uploading', 60)

    const url = conversationId
      ? `${API_BASE}/files?conversationId=${conversationId}`
      : `${API_BASE}/files`

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`
      },
      body: formData
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(error)
    }

    const result: UploadResult = await response.json()

    fileStore.completeUpload(tempId, result.id)

    return result
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Upload failed'
    fileStore.failUpload(tempId, message)
    throw err
  }
}

/**
 * Download and decrypt a file from the server.
 */
export async function downloadFile(fileId: string, filename: string): Promise<Blob> {
  const fileStore = useFileStore.getState()
  const token = useAuthStore.getState().accessToken

  fileStore.startDownload(fileId, filename)

  try {
    // Fetch file
    fileStore.updateDownloadStatus(fileId, 'downloading', 20)

    const response = await fetch(`${API_BASE}/files/${fileId}`, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    if (!response.ok) {
      throw new Error('Download failed')
    }

    // Get encryption header from response
    const headerBase64 = response.headers.get('X-Encryption-Header')
    if (!headerBase64) {
      throw new Error('Missing encryption header')
    }

    const header = Uint8Array.from(atob(headerBase64), c => c.charCodeAt(0))
    const encryptedData = new Uint8Array(await response.arrayBuffer())

    fileStore.updateDownloadStatus(fileId, 'downloading', 60)

    // Decrypt file
    fileStore.updateDownloadStatus(fileId, 'decrypting', 70)

    // Note: For now, we need the key. In full implementation,
    // key would be encrypted per-recipient and retrieved separately.
    // This is a placeholder - actual key retrieval TBD in integration.
    // For testing, we'll need to store/retrieve the key properly.

    // Placeholder: assume key is stored elsewhere
    // const key = await getFileKey(fileId)
    // const decryptedData = await decryptFile(header, key, encryptedData)

    // For now, return raw encrypted data (decryption needs key management)
    const blob = new Blob([encryptedData])

    fileStore.completeDownload(fileId, blob)

    return blob
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Download failed'
    fileStore.failDownload(fileId, message)
    throw err
  }
}

/**
 * Trigger browser download for a blob.
 */
export function triggerDownload(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

/**
 * Get file metadata from server.
 */
export async function getFileMeta(fileId: string): Promise<{
  id: string
  filename: string
  mimeType: string
  sizeBytes: number
  encryptionHeader: string
}> {
  const token = useAuthStore.getState().accessToken

  const response = await fetch(`${API_BASE}/files/${fileId}/meta`, {
    headers: {
      Authorization: `Bearer ${token}`
    }
  })

  if (!response.ok) {
    throw new Error('Failed to get file metadata')
  }

  return response.json()
}
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>chunkedUpload.ts exports uploadFile, downloadFile, triggerDownload</done>
</task>

</tasks>

<verification>
1. Frontend TypeScript compiles
2. fileEncryption.ts uses SecretStream API correctly
3. fileStore.ts tracks upload/download state
4. chunkedUpload.ts handles encryption and upload flow
</verification>

<success_criteria>
- Files encrypted in 64KB chunks using SecretStream
- Upload progress tracked from 0-100%
- Encryption header sent as form field
- Download retrieves encrypted data with header
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-08-SUMMARY.md`
</output>
