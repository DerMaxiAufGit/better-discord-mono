---
phase: 05-enhanced-communication
plan: 07
type: execute
wave: 3
depends_on: ["05-04"]
files_modified:
  - frontend/src/stores/groupStore.ts
  - frontend/src/lib/crypto/groupEncryption.ts
autonomous: true

must_haves:
  truths:
    - "Group store manages group list, members, and selected group state"
    - "Pairwise encryption encrypts group messages for each member"
    - "Session keys reused from existing crypto infrastructure"
  artifacts:
    - path: "frontend/src/stores/groupStore.ts"
      provides: "Zustand store for group state"
      exports: ["useGroupStore"]
    - path: "frontend/src/lib/crypto/groupEncryption.ts"
      provides: "Group message encryption"
      exports: ["encryptGroupMessage", "decryptGroupMessage"]
  key_links:
    - from: "groupStore.ts"
      to: "/api/groups"
      via: "fetch"
      pattern: "fetch.*groups"
    - from: "groupEncryption.ts"
      to: "cryptoStore"
      via: "getOrDeriveSessionKeys"
      pattern: "cryptoStore"
---

<objective>
Create frontend group store and pairwise encryption for group messages.

Purpose: Enable group state management and E2E encrypted group messaging
Output: Zustand store and encryption utilities ready for UI integration
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-04-SUMMARY.md
@frontend/src/stores/cryptoStore.ts
@frontend/src/stores/contactStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create group store</name>
  <files>frontend/src/stores/groupStore.ts</files>
  <action>
Create groupStore.ts with Zustand:

```typescript
import { create } from 'zustand'
import { api } from '@/lib/api'

export type GroupRole = 'owner' | 'admin' | 'moderator' | 'member'

export interface Group {
  id: string
  name: string
  description: string | null
  avatar_url: string | null
  owner_id: string
  role: GroupRole
  member_count: number
  created_at: string
  updated_at: string
}

export interface GroupMember {
  id: number
  group_id: string
  user_id: string
  role: GroupRole
  joined_at: string
  email: string
  public_key?: string
}

export interface GroupInvite {
  id: string
  code: string
  expires_at: string | null
  max_uses: number | null
  uses: number
  created_at: string
}

interface GroupState {
  groups: Group[]
  selectedGroupId: string | null
  members: Map<string, GroupMember[]> // groupId -> members
  isLoading: boolean
  error: string | null

  // Actions
  loadGroups: () => Promise<void>
  selectGroup: (groupId: string | null) => void
  loadMembers: (groupId: string) => Promise<GroupMember[]>
  createGroup: (name: string, description?: string) => Promise<Group>
  updateGroup: (groupId: string, updates: Partial<Pick<Group, 'name' | 'description' | 'avatar_url'>>) => Promise<void>
  deleteGroup: (groupId: string) => Promise<void>
  addMember: (groupId: string, userId: string, role?: GroupRole) => Promise<void>
  removeMember: (groupId: string, userId: string) => Promise<void>
  changeRole: (groupId: string, userId: string, role: GroupRole) => Promise<void>
  createInvite: (groupId: string, expiresIn?: number, maxUses?: number) => Promise<GroupInvite>
  joinGroup: (code: string) => Promise<string> // returns groupId
  leaveGroup: (groupId: string) => Promise<void>
  clearGroups: () => void
}

export const useGroupStore = create<GroupState>((set, get) => ({
  groups: [],
  selectedGroupId: null,
  members: new Map(),
  isLoading: false,
  error: null,

  loadGroups: async () => {
    set({ isLoading: true, error: null })
    try {
      const groups = await api.get<Group[]>('/groups')
      set({ groups, isLoading: false })
    } catch (err) {
      set({ error: 'Failed to load groups', isLoading: false })
    }
  },

  selectGroup: (groupId) => {
    set({ selectedGroupId: groupId })
    if (groupId) {
      get().loadMembers(groupId)
    }
  },

  loadMembers: async (groupId) => {
    try {
      const members = await api.get<GroupMember[]>(`/groups/${groupId}/members`)
      set((state) => ({
        members: new Map(state.members).set(groupId, members)
      }))
      return members
    } catch {
      return []
    }
  },

  createGroup: async (name, description) => {
    const group = await api.post<Group>('/groups', { name, description })
    set((state) => ({ groups: [...state.groups, group] }))
    return group
  },

  updateGroup: async (groupId, updates) => {
    const updated = await api.patch<Group>(`/groups/${groupId}`, updates)
    set((state) => ({
      groups: state.groups.map(g => g.id === groupId ? { ...g, ...updated } : g)
    }))
  },

  deleteGroup: async (groupId) => {
    await api.delete(`/groups/${groupId}`)
    set((state) => ({
      groups: state.groups.filter(g => g.id !== groupId),
      selectedGroupId: state.selectedGroupId === groupId ? null : state.selectedGroupId
    }))
  },

  addMember: async (groupId, userId, role = 'member') => {
    await api.post(`/groups/${groupId}/members`, { userId, role })
    await get().loadMembers(groupId)
  },

  removeMember: async (groupId, userId) => {
    await api.delete(`/groups/${groupId}/members/${userId}`)
    await get().loadMembers(groupId)
  },

  changeRole: async (groupId, userId, role) => {
    await api.patch(`/groups/${groupId}/members/${userId}`, { role })
    await get().loadMembers(groupId)
  },

  createInvite: async (groupId, expiresIn, maxUses) => {
    return api.post<GroupInvite>(`/groups/${groupId}/invites`, { expiresIn, maxUses })
  },

  joinGroup: async (code) => {
    const { groupId } = await api.post<{ groupId: string }>('/groups/join', { code })
    await get().loadGroups()
    return groupId
  },

  leaveGroup: async (groupId) => {
    const userId = (await import('@/stores/auth')).useAuthStore.getState().user?.id
    if (userId) {
      await get().removeMember(groupId, userId)
    }
    set((state) => ({
      groups: state.groups.filter(g => g.id !== groupId),
      selectedGroupId: state.selectedGroupId === groupId ? null : state.selectedGroupId
    }))
  },

  clearGroups: () => {
    set({ groups: [], selectedGroupId: null, members: new Map() })
  }
}))
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>groupStore.ts exports useGroupStore with all CRUD and member operations</done>
</task>

<task type="auto">
  <name>Task 2: Create group encryption utilities</name>
  <files>frontend/src/lib/crypto/groupEncryption.ts</files>
  <action>
Create groupEncryption.ts with pairwise encryption for groups:

```typescript
import { useCryptoStore } from '@/stores/cryptoStore'
import { encryptMessage, decryptMessage } from './libsodium'
import type { GroupMember } from '@/stores/groupStore'

export interface EncryptedGroupMessage {
  recipientId: string
  encryptedContent: string // base64
}

/**
 * Encrypt a message for all group members using pairwise encryption.
 * Each member gets the message encrypted with their specific session key.
 */
export async function encryptGroupMessage(
  plaintext: string,
  members: GroupMember[],
  currentUserId: string
): Promise<EncryptedGroupMessage[]> {
  const cryptoStore = useCryptoStore.getState()
  const encrypted: EncryptedGroupMessage[] = []

  for (const member of members) {
    // Skip self
    if (member.user_id === currentUserId) continue

    // Skip members without public keys
    if (!member.public_key) {
      console.warn(`Skipping member ${member.user_id} - no public key`)
      continue
    }

    try {
      // Get or derive session keys for this member
      const sessionKeys = await cryptoStore.getOrDeriveSessionKeys(
        currentUserId,
        member.user_id,
        member.public_key
      )

      // Encrypt message with session key
      const encryptedContent = await encryptMessage(plaintext, sessionKeys.tx)

      encrypted.push({
        recipientId: member.user_id,
        encryptedContent
      })
    } catch (err) {
      console.error(`Failed to encrypt for member ${member.user_id}:`, err)
    }
  }

  return encrypted
}

/**
 * Decrypt a group message from a specific sender.
 * Uses existing pairwise session keys.
 */
export async function decryptGroupMessage(
  encryptedContent: string,
  senderId: string,
  senderPublicKey: string,
  currentUserId: string
): Promise<string | null> {
  const cryptoStore = useCryptoStore.getState()

  try {
    const sessionKeys = await cryptoStore.getOrDeriveSessionKeys(
      currentUserId,
      senderId,
      senderPublicKey
    )

    return await decryptMessage(encryptedContent, sessionKeys.rx)
  } catch (err) {
    console.error(`Failed to decrypt group message from ${senderId}:`, err)
    return null
  }
}

/**
 * Prepare public keys map from group members for key exchange.
 */
export function getMemberPublicKeys(members: GroupMember[]): Map<string, string> {
  const keys = new Map<string, string>()

  for (const member of members) {
    if (member.public_key) {
      keys.set(member.user_id, member.public_key)
    }
  }

  return keys
}
```

This implements the pairwise encryption pattern from RESEARCH.md:
- Each message is encrypted individually for each recipient
- Reuses existing X25519 session key derivation from Phase 2
- No shared group key (simpler, more secure for groups up to 200)
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>groupEncryption.ts exports encryptGroupMessage, decryptGroupMessage</done>
</task>

<task type="auto">
  <name>Task 3: Update API helper for group endpoints</name>
  <files>frontend/src/lib/api.ts</files>
  <action>
Ensure api.ts has proper typing for group endpoints. Add any missing HTTP methods if needed:

```typescript
// In api.ts, ensure these methods exist (may already be present):
export const api = {
  get: async <T>(path: string): Promise<T> => {
    const response = await fetch(`/api${path}`, {
      headers: { Authorization: `Bearer ${getToken()}` }
    })
    if (!response.ok) throw new Error(await response.text())
    return response.json()
  },

  post: async <T>(path: string, body?: unknown): Promise<T> => {
    const response = await fetch(`/api${path}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${getToken()}`
      },
      body: body ? JSON.stringify(body) : undefined
    })
    if (!response.ok) throw new Error(await response.text())
    return response.json()
  },

  patch: async <T>(path: string, body: unknown): Promise<T> => {
    const response = await fetch(`/api${path}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${getToken()}`
      },
      body: JSON.stringify(body)
    })
    if (!response.ok) throw new Error(await response.text())
    return response.json()
  },

  delete: async (path: string): Promise<void> => {
    const response = await fetch(`/api${path}`, {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${getToken()}` }
    })
    if (!response.ok) throw new Error(await response.text())
  }
}
```

Verify existing api.ts has PATCH method (may need to add it).
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>API helper supports GET, POST, PATCH, DELETE for group endpoints</done>
</task>

</tasks>

<verification>
1. Frontend TypeScript compiles
2. groupStore.ts exports useGroupStore
3. groupEncryption.ts exports encryption functions
4. API helper has all required methods
</verification>

<success_criteria>
- Group store manages groups, members, selection state
- Pairwise encryption works for all members with public keys
- Session keys reused from existing cryptoStore
- Members without public keys are gracefully skipped
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-07-SUMMARY.md`
</output>
