---
phase: 05-enhanced-communication
plan: 06
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/services/reactionService.ts
  - backend/src/routes/reactions.ts
autonomous: true

must_haves:
  truths:
    - "Reactions can be added to messages with toggle behavior"
    - "Reactions are stored per message per user per emoji"
    - "Reaction list shows all users who reacted with specific emoji"
    - "Maximum 50 unique emoji per message enforced"
  artifacts:
    - path: "backend/src/services/reactionService.ts"
      provides: "Reaction storage and retrieval"
      exports: ["addReaction", "removeReaction", "getReactions", "toggleReaction"]
    - path: "backend/src/routes/reactions.ts"
      provides: "Reaction REST endpoints"
      contains: "fastify.post"
  key_links:
    - from: "routes/reactions.ts"
      to: "services/reactionService.ts"
      via: "import"
      pattern: "import.*reactionService"
---

<objective>
Create backend reaction service for message emoji reactions.

Purpose: Enable emoji reactions on messages with toggle behavior
Output: Reaction API supporting add, remove, and list operations
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-01-SUMMARY.md
@backend/src/services/messageService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reaction service</name>
  <files>backend/src/services/reactionService.ts</files>
  <action>
Create reactionService.ts:

```typescript
import pool from '../db'
import { Reaction } from '../db/schema'

const MAX_UNIQUE_EMOJI_PER_MESSAGE = 50

export interface ReactionWithUser extends Reaction {
  email: string
}

export interface ReactionSummary {
  emoji: string
  count: number
  users: { userId: string; email: string }[]
  userReacted: boolean // whether current user has reacted
}

export async function addReaction(messageId: number, userId: string, emoji: string): Promise<boolean> {
  // Check unique emoji count
  const countResult = await pool.query(
    `SELECT COUNT(DISTINCT emoji) as count FROM reactions WHERE message_id = $1`,
    [messageId]
  )
  const currentCount = parseInt(countResult.rows[0].count)

  // Check if this emoji already exists
  const existingEmoji = await pool.query(
    `SELECT 1 FROM reactions WHERE message_id = $1 AND emoji = $2 LIMIT 1`,
    [messageId, emoji]
  )

  if (existingEmoji.rows.length === 0 && currentCount >= MAX_UNIQUE_EMOJI_PER_MESSAGE) {
    throw new Error(`Maximum ${MAX_UNIQUE_EMOJI_PER_MESSAGE} unique emoji per message`)
  }

  try {
    await pool.query(
      `INSERT INTO reactions (message_id, user_id, emoji) VALUES ($1, $2, $3)
       ON CONFLICT (message_id, user_id, emoji) DO NOTHING`,
      [messageId, userId, emoji]
    )
    return true
  } catch {
    return false
  }
}

export async function removeReaction(messageId: number, userId: string, emoji: string): Promise<boolean> {
  const result = await pool.query(
    `DELETE FROM reactions WHERE message_id = $1 AND user_id = $2 AND emoji = $3
     RETURNING id`,
    [messageId, userId, emoji]
  )
  return result.rows.length > 0
}

export async function toggleReaction(messageId: number, userId: string, emoji: string): Promise<{ added: boolean }> {
  // Check if reaction exists
  const existing = await pool.query(
    `SELECT id FROM reactions WHERE message_id = $1 AND user_id = $2 AND emoji = $3`,
    [messageId, userId, emoji]
  )

  if (existing.rows.length > 0) {
    await removeReaction(messageId, userId, emoji)
    return { added: false }
  } else {
    await addReaction(messageId, userId, emoji)
    return { added: true }
  }
}

export async function getReactions(messageId: number, currentUserId?: string): Promise<ReactionSummary[]> {
  const result = await pool.query(
    `SELECT r.emoji, r.user_id, u.email
     FROM reactions r
     JOIN users u ON r.user_id = u.id
     WHERE r.message_id = $1
     ORDER BY r.emoji, r.created_at`,
    [messageId]
  )

  // Group by emoji
  const emojiMap = new Map<string, { users: { userId: string; email: string }[] }>()

  for (const row of result.rows) {
    if (!emojiMap.has(row.emoji)) {
      emojiMap.set(row.emoji, { users: [] })
    }
    emojiMap.get(row.emoji)!.users.push({
      userId: row.user_id,
      email: row.email
    })
  }

  // Convert to summary array
  const summaries: ReactionSummary[] = []
  for (const [emoji, data] of emojiMap.entries()) {
    summaries.push({
      emoji,
      count: data.users.length,
      users: data.users,
      userReacted: currentUserId ? data.users.some(u => u.userId === currentUserId) : false
    })
  }

  return summaries
}

export async function getReactionsForMessages(messageIds: number[], currentUserId?: string): Promise<Map<number, ReactionSummary[]>> {
  if (messageIds.length === 0) return new Map()

  const result = await pool.query(
    `SELECT r.message_id, r.emoji, r.user_id, u.email
     FROM reactions r
     JOIN users u ON r.user_id = u.id
     WHERE r.message_id = ANY($1)
     ORDER BY r.message_id, r.emoji, r.created_at`,
    [messageIds]
  )

  // Group by message, then by emoji
  const messageMap = new Map<number, Map<string, { users: { userId: string; email: string }[] }>>()

  for (const row of result.rows) {
    if (!messageMap.has(row.message_id)) {
      messageMap.set(row.message_id, new Map())
    }
    const emojiMap = messageMap.get(row.message_id)!

    if (!emojiMap.has(row.emoji)) {
      emojiMap.set(row.emoji, { users: [] })
    }
    emojiMap.get(row.emoji)!.users.push({
      userId: row.user_id,
      email: row.email
    })
  }

  // Convert to ReactionSummary format
  const resultMap = new Map<number, ReactionSummary[]>()

  for (const [messageId, emojiMap] of messageMap.entries()) {
    const summaries: ReactionSummary[] = []
    for (const [emoji, data] of emojiMap.entries()) {
      summaries.push({
        emoji,
        count: data.users.length,
        users: data.users,
        userReacted: currentUserId ? data.users.some(u => u.userId === currentUserId) : false
      })
    }
    resultMap.set(messageId, summaries)
  }

  return resultMap
}

export async function hasAccessToMessage(messageId: number, userId: string): Promise<boolean> {
  const result = await pool.query(
    `SELECT 1 FROM messages m
     LEFT JOIN group_members gm ON m.group_id = gm.group_id AND gm.user_id = $2
     WHERE m.id = $1
       AND (m.sender_id = $2 OR m.recipient_id = $2 OR gm.user_id IS NOT NULL)`,
    [messageId, userId]
  )
  return result.rows.length > 0
}
```
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>reactionService.ts exports all reaction functions</done>
</task>

<task type="auto">
  <name>Task 2: Create reaction routes</name>
  <files>backend/src/routes/reactions.ts</files>
  <action>
Create reactions.ts:

```typescript
import { FastifyInstance } from 'fastify'
import * as reactionService from '../services/reactionService'

export default async function reactionRoutes(fastify: FastifyInstance) {
  // All routes require authentication
  fastify.addHook('onRequest', fastify.authenticate)

  // Toggle reaction (add if not exists, remove if exists)
  fastify.post<{ Params: { messageId: string }; Body: { emoji: string } }>(
    '/messages/:messageId/reactions',
    async (request, reply) => {
      const messageId = parseInt(request.params.messageId)
      const { emoji } = request.body

      if (!emoji || emoji.length > 32) {
        return reply.code(400).send({ error: 'Invalid emoji' })
      }

      // Check access
      const hasAccess = await reactionService.hasAccessToMessage(messageId, request.user.id)
      if (!hasAccess) {
        return reply.code(404).send({ error: 'Message not found' })
      }

      try {
        const result = await reactionService.toggleReaction(messageId, request.user.id, emoji)
        return result
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to add reaction'
        return reply.code(400).send({ error: message })
      }
    }
  )

  // Get reactions for a message
  fastify.get<{ Params: { messageId: string } }>(
    '/messages/:messageId/reactions',
    async (request, reply) => {
      const messageId = parseInt(request.params.messageId)

      // Check access
      const hasAccess = await reactionService.hasAccessToMessage(messageId, request.user.id)
      if (!hasAccess) {
        return reply.code(404).send({ error: 'Message not found' })
      }

      return reactionService.getReactions(messageId, request.user.id)
    }
  )

  // Remove specific reaction
  fastify.delete<{ Params: { messageId: string }; Querystring: { emoji: string } }>(
    '/messages/:messageId/reactions',
    async (request, reply) => {
      const messageId = parseInt(request.params.messageId)
      const { emoji } = request.query

      if (!emoji) {
        return reply.code(400).send({ error: 'Emoji required' })
      }

      // Check access
      const hasAccess = await reactionService.hasAccessToMessage(messageId, request.user.id)
      if (!hasAccess) {
        return reply.code(404).send({ error: 'Message not found' })
      }

      await reactionService.removeReaction(messageId, request.user.id, emoji)
      return reply.code(204).send()
    }
  )
}
```
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>reactions.ts exports default function with REST endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register reaction routes and update message service</name>
  <files>backend/src/server.ts, backend/src/services/messageService.ts</files>
  <action>
Register reaction routes in server.ts:
```typescript
import reactionRoutes from './routes/reactions'

// Add after existing route registrations
fastify.register(reactionRoutes)
```

Update messageService.ts to include reactions when fetching messages:
```typescript
import { getReactionsForMessages } from './reactionService'

// In getMessageHistory function, after fetching messages:
export async function getMessageHistory(userId: string, contactId: string, beforeId?: number, limit = 50) {
  // ... existing query ...

  // Add reactions to messages
  const messageIds = rows.map(r => r.id)
  const reactions = await getReactionsForMessages(messageIds, userId)

  return rows.map(row => ({
    ...row,
    reactions: reactions.get(row.id) || []
  }))
}
```
  </action>
  <verify>Run: cd backend && npm run build</verify>
  <done>Reaction routes registered, messages include reactions</done>
</task>

</tasks>

<verification>
1. Backend TypeScript compiles
2. reactionService.ts exports required functions
3. reactions.ts has toggle, get, delete endpoints
4. Message history includes reaction summaries
</verification>

<success_criteria>
- POST /messages/:id/reactions toggles reaction
- GET /messages/:id/reactions returns grouped reaction summaries
- 50 unique emoji limit enforced per message
- userReacted field indicates current user's reaction state
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-06-SUMMARY.md`
</output>
