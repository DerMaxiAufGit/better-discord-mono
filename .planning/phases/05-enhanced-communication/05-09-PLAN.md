---
phase: 05-enhanced-communication
plan: 09
type: execute
wave: 3
depends_on: ["05-06", "05-02"]
files_modified:
  - frontend/src/stores/reactionStore.ts
  - frontend/src/hooks/useTypingIndicator.ts
autonomous: true

must_haves:
  truths:
    - "Reaction store manages reactions per message with optimistic updates"
    - "Typing indicator hook debounces input and sends WebSocket events"
    - "Typing state tracked per conversation with automatic timeout"
  artifacts:
    - path: "frontend/src/stores/reactionStore.ts"
      provides: "Reaction state management"
      exports: ["useReactionStore"]
    - path: "frontend/src/hooks/useTypingIndicator.ts"
      provides: "Typing indicator WebSocket integration"
      exports: ["useTypingIndicator"]
  key_links:
    - from: "reactionStore.ts"
      to: "/api/messages/:id/reactions"
      via: "fetch"
      pattern: "fetch.*reactions"
    - from: "useTypingIndicator.ts"
      to: "WebSocket"
      via: "send"
      pattern: "ws.*send"
---

<objective>
Create frontend reaction store and typing indicator hook.

Purpose: Enable message reactions and typing indicators in conversations
Output: Zustand store for reactions and hook for typing events
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-06-SUMMARY.md
@.planning/phases/05-enhanced-communication/05-02-SUMMARY.md
@frontend/src/hooks/useMessaging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reaction store</name>
  <files>frontend/src/stores/reactionStore.ts</files>
  <action>
Create reactionStore.ts:

```typescript
import { create } from 'zustand'
import { api } from '@/lib/api'

export interface ReactionSummary {
  emoji: string
  count: number
  users: { userId: string; email: string }[]
  userReacted: boolean
}

interface ReactionState {
  // Map: messageId -> reactions
  reactions: Map<number, ReactionSummary[]>
  isLoading: Map<number, boolean>

  // Actions
  loadReactions: (messageId: number) => Promise<void>
  toggleReaction: (messageId: number, emoji: string) => Promise<void>
  setReactions: (messageId: number, reactions: ReactionSummary[]) => void
  addReactionOptimistic: (messageId: number, emoji: string, userId: string, email: string) => void
  removeReactionOptimistic: (messageId: number, emoji: string, userId: string) => void
  clearReactions: () => void
}

export const useReactionStore = create<ReactionState>((set, get) => ({
  reactions: new Map(),
  isLoading: new Map(),

  loadReactions: async (messageId) => {
    set((state) => ({
      isLoading: new Map(state.isLoading).set(messageId, true)
    }))

    try {
      const reactions = await api.get<ReactionSummary[]>(`/messages/${messageId}/reactions`)
      set((state) => ({
        reactions: new Map(state.reactions).set(messageId, reactions),
        isLoading: new Map(state.isLoading).set(messageId, false)
      }))
    } catch {
      set((state) => ({
        isLoading: new Map(state.isLoading).set(messageId, false)
      }))
    }
  },

  toggleReaction: async (messageId, emoji) => {
    try {
      const result = await api.post<{ added: boolean }>(`/messages/${messageId}/reactions`, { emoji })

      // Refresh reactions after toggle
      await get().loadReactions(messageId)

      return result.added
    } catch (err) {
      console.error('Failed to toggle reaction:', err)
      throw err
    }
  },

  setReactions: (messageId, reactions) => {
    set((state) => ({
      reactions: new Map(state.reactions).set(messageId, reactions)
    }))
  },

  addReactionOptimistic: (messageId, emoji, userId, email) => {
    set((state) => {
      const current = state.reactions.get(messageId) || []
      const existing = current.find(r => r.emoji === emoji)

      let updated: ReactionSummary[]

      if (existing) {
        // Add user to existing reaction
        if (existing.users.some(u => u.userId === userId)) return state // Already reacted

        updated = current.map(r =>
          r.emoji === emoji
            ? {
                ...r,
                count: r.count + 1,
                users: [...r.users, { userId, email }],
                userReacted: true
              }
            : r
        )
      } else {
        // Add new reaction
        updated = [
          ...current,
          {
            emoji,
            count: 1,
            users: [{ userId, email }],
            userReacted: true
          }
        ]
      }

      return {
        reactions: new Map(state.reactions).set(messageId, updated)
      }
    })
  },

  removeReactionOptimistic: (messageId, emoji, userId) => {
    set((state) => {
      const current = state.reactions.get(messageId) || []
      const existing = current.find(r => r.emoji === emoji)

      if (!existing) return state

      let updated: ReactionSummary[]

      if (existing.count === 1) {
        // Remove reaction entirely
        updated = current.filter(r => r.emoji !== emoji)
      } else {
        // Remove user from reaction
        updated = current.map(r =>
          r.emoji === emoji
            ? {
                ...r,
                count: r.count - 1,
                users: r.users.filter(u => u.userId !== userId),
                userReacted: r.users.some(u => u.userId === userId) ? false : r.userReacted
              }
            : r
        )
      }

      return {
        reactions: new Map(state.reactions).set(messageId, updated)
      }
    })
  },

  clearReactions: () => {
    set({ reactions: new Map(), isLoading: new Map() })
  }
}))
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>reactionStore.ts exports useReactionStore with toggle and optimistic updates</done>
</task>

<task type="auto">
  <name>Task 2: Create typing indicator hook</name>
  <files>frontend/src/hooks/useTypingIndicator.ts</files>
  <action>
Create useTypingIndicator.ts:

```typescript
import { useState, useEffect, useRef, useCallback } from 'react'

interface UseTypingIndicatorOptions {
  conversationId: string
  recipientId?: string // For 1:1 conversations
  sendTypingEvent: (isTyping: boolean) => void
  debounceMs?: number
  timeoutMs?: number
}

interface TypingUser {
  userId: string
  email?: string
}

interface UseTypingIndicatorReturn {
  typingUsers: TypingUser[]
  onInputChange: () => void
  onMessageSend: () => void
}

export function useTypingIndicator({
  conversationId,
  recipientId,
  sendTypingEvent,
  debounceMs = 300,
  timeoutMs = 5000
}: UseTypingIndicatorOptions): UseTypingIndicatorReturn {
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([])
  const isTypingRef = useRef(false)
  const timeoutRef = useRef<NodeJS.Timeout | null>(null)
  const debounceRef = useRef<NodeJS.Timeout | null>(null)

  // Handle incoming typing events
  useEffect(() => {
    const handleTypingEvent = (event: CustomEvent<{ conversationId: string; userId: string; email?: string; isTyping: boolean }>) => {
      const { conversationId: eventConvId, userId, email, isTyping } = event.detail

      if (eventConvId !== conversationId) return

      setTypingUsers((current) => {
        if (isTyping) {
          // Add user if not already typing
          if (current.some(u => u.userId === userId)) return current
          return [...current, { userId, email }]
        } else {
          // Remove user
          return current.filter(u => u.userId !== userId)
        }
      })
    }

    window.addEventListener('typing-indicator', handleTypingEvent as EventListener)

    return () => {
      window.removeEventListener('typing-indicator', handleTypingEvent as EventListener)
    }
  }, [conversationId])

  // Auto-clear typing users after timeout (server should also do this)
  useEffect(() => {
    if (typingUsers.length === 0) return

    const interval = setInterval(() => {
      // Client-side cleanup (server has 10s timeout, we use 15s for buffer)
      setTypingUsers([])
    }, 15000)

    return () => clearInterval(interval)
  }, [typingUsers])

  const sendStartTyping = useCallback(() => {
    if (isTypingRef.current) return

    isTypingRef.current = true
    sendTypingEvent(true)

    // Auto-stop after timeout
    timeoutRef.current = setTimeout(() => {
      if (isTypingRef.current) {
        isTypingRef.current = false
        sendTypingEvent(false)
      }
    }, timeoutMs)
  }, [sendTypingEvent, timeoutMs])

  const sendStopTyping = useCallback(() => {
    if (!isTypingRef.current) return

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
      timeoutRef.current = null
    }

    isTypingRef.current = false
    sendTypingEvent(false)
  }, [sendTypingEvent])

  const onInputChange = useCallback(() => {
    // Debounce the start typing event
    if (debounceRef.current) {
      clearTimeout(debounceRef.current)
    }

    debounceRef.current = setTimeout(() => {
      sendStartTyping()
    }, debounceMs)

    // Reset the timeout for stopping
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    if (isTypingRef.current) {
      timeoutRef.current = setTimeout(() => {
        sendStopTyping()
      }, timeoutMs)
    }
  }, [sendStartTyping, sendStopTyping, debounceMs, timeoutMs])

  const onMessageSend = useCallback(() => {
    // Immediately stop typing when message is sent
    if (debounceRef.current) {
      clearTimeout(debounceRef.current)
      debounceRef.current = null
    }

    sendStopTyping()
  }, [sendStopTyping])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current)
      if (debounceRef.current) clearTimeout(debounceRef.current)
      if (isTypingRef.current) {
        sendTypingEvent(false)
      }
    }
  }, [sendTypingEvent])

  return {
    typingUsers,
    onInputChange,
    onMessageSend
  }
}

/**
 * Format typing indicator text.
 */
export function formatTypingIndicator(users: TypingUser[]): string {
  if (users.length === 0) return ''

  const names = users.map(u => u.email?.split('@')[0] || 'Someone')

  if (names.length === 1) {
    return `${names[0]} is typing...`
  } else if (names.length === 2) {
    return `${names[0]} and ${names[1]} are typing...`
  } else {
    return `${names.length} people are typing...`
  }
}
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>useTypingIndicator.ts exports hook with onInputChange and onMessageSend</done>
</task>

<task type="auto">
  <name>Task 3: Add typing event dispatch to WebSocket handler</name>
  <files>frontend/src/hooks/useMessaging.ts</files>
  <action>
Update useMessaging.ts to dispatch typing events as CustomEvents:

In the WebSocket message handler, add a case for typing events:

```typescript
// Add to the switch/if statement handling incoming WebSocket messages:

if (data.type === 'typing') {
  // Dispatch custom event for typing indicator hook
  window.dispatchEvent(new CustomEvent('typing-indicator', {
    detail: {
      conversationId: data.conversationId,
      userId: data.userId,
      email: data.email,
      isTyping: data.isTyping
    }
  }))
  return
}
```

Also add a sendTyping function to the hook's return value:

```typescript
const sendTyping = useCallback((conversationId: string, recipientId: string, isTyping: boolean) => {
  if (ws.current?.readyState === WebSocket.OPEN) {
    ws.current.send(JSON.stringify({
      type: 'typing',
      conversationId,
      recipientId,
      isTyping
    }))
  }
}, [])

// Return sendTyping from the hook
return {
  // ... existing returns
  sendTyping
}
```
  </action>
  <verify>Run: cd frontend && npx tsc --noEmit</verify>
  <done>useMessaging dispatches typing events and exports sendTyping function</done>
</task>

</tasks>

<verification>
1. Frontend TypeScript compiles
2. reactionStore.ts handles optimistic updates
3. useTypingIndicator.ts debounces input and manages timeout
4. useMessaging.ts dispatches typing CustomEvents
</verification>

<success_criteria>
- Reactions toggle with optimistic UI updates
- Typing indicator shows after 300ms of typing
- Typing stops after 5s of inactivity
- Multiple typing users formatted correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-09-SUMMARY.md`
</output>
