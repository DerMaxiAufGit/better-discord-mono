---
phase: 05-enhanced-communication
plan: 05
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/services/fileService.ts
  - backend/src/routes/files.ts
autonomous: true

must_haves:
  truths:
    - "Files can be uploaded with encryption header stored in database"
    - "Files are stored on local disk with unique paths"
    - "Files can be downloaded by authorized users only"
    - "File metadata includes size, mime type, original filename"
  artifacts:
    - path: "backend/src/services/fileService.ts"
      provides: "File storage and retrieval"
      exports: ["uploadFile", "getFile", "getFileStream", "deleteFile"]
    - path: "backend/src/routes/files.ts"
      provides: "File upload/download endpoints"
      contains: "fastify.post"
  key_links:
    - from: "routes/files.ts"
      to: "services/fileService.ts"
      via: "import"
      pattern: "import.*fileService"
---

<objective>
Create backend file service for encrypted file storage and retrieval.

Purpose: Enable file sharing in conversations with E2E encryption support
Output: File upload/download API with local disk storage
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-enhanced-communication/05-RESEARCH.md
@.planning/phases/05-enhanced-communication/05-01-SUMMARY.md
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file service</name>
  <files>backend/src/services/fileService.ts</files>
  <action>
Create fileService.ts with upload and download functionality:

```typescript
import pool from '../db'
import { FileRecord } from '../db/schema'
import path from 'path'
import fs from 'fs/promises'
import { createReadStream, ReadStream } from 'fs'
import crypto from 'crypto'

// Storage directory - configurable via env
const UPLOAD_DIR = process.env.UPLOAD_DIR || '/app/uploads'
const MAX_FILE_SIZE = 100 * 1024 * 1024 // 100MB

export async function ensureUploadDir(): Promise<void> {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true })
  } catch (err) {
    console.error('Failed to create upload directory:', err)
  }
}

// Generate unique storage path
function generateStoragePath(originalFilename: string): string {
  const date = new Date()
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  const uuid = crypto.randomUUID()
  const ext = path.extname(originalFilename)

  return path.join(year.toString(), month, day, `${uuid}${ext}`)
}

export interface UploadFileParams {
  uploaderId: string
  conversationId?: string // group_id or null for DM context
  messageId?: number
  filename: string
  mimeType: string
  encryptionHeader: Buffer
  data: Buffer
}

export async function uploadFile(params: UploadFileParams): Promise<FileRecord> {
  const { uploaderId, conversationId, messageId, filename, mimeType, encryptionHeader, data } = params

  if (data.length > MAX_FILE_SIZE) {
    throw new Error(`File exceeds maximum size of ${MAX_FILE_SIZE} bytes`)
  }

  const storagePath = generateStoragePath(filename)
  const fullPath = path.join(UPLOAD_DIR, storagePath)

  // Ensure directory exists
  await fs.mkdir(path.dirname(fullPath), { recursive: true })

  // Write encrypted data to disk
  await fs.writeFile(fullPath, data)

  // Store metadata in database
  const result = await pool.query(
    `INSERT INTO files (conversation_id, message_id, uploader_id, filename, mime_type, size_bytes, storage_path, encryption_header)
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`,
    [conversationId || null, messageId || null, uploaderId, filename, mimeType, data.length, storagePath, encryptionHeader]
  )

  return result.rows[0]
}

export async function getFile(fileId: string, userId: string): Promise<FileRecord | null> {
  // Get file with authorization check
  // User can access if:
  // 1. They uploaded it
  // 2. They are recipient of the message
  // 3. They are member of the group
  const result = await pool.query(
    `SELECT f.* FROM files f
     LEFT JOIN messages m ON f.message_id = m.id
     LEFT JOIN group_members gm ON f.conversation_id = gm.group_id AND gm.user_id = $2
     WHERE f.id = $1
       AND (
         f.uploader_id = $2
         OR m.recipient_id = $2
         OR m.sender_id = $2
         OR gm.user_id IS NOT NULL
       )`,
    [fileId, userId]
  )

  return result.rows[0] || null
}

export async function getFileStream(fileId: string, userId: string): Promise<{ stream: ReadStream; file: FileRecord } | null> {
  const file = await getFile(fileId, userId)
  if (!file) return null

  const fullPath = path.join(UPLOAD_DIR, file.storage_path)

  try {
    await fs.access(fullPath)
    const stream = createReadStream(fullPath)
    return { stream, file }
  } catch {
    return null
  }
}

export async function deleteFile(fileId: string, userId: string): Promise<boolean> {
  const file = await getFile(fileId, userId)
  if (!file) return false

  // Only uploader can delete
  if (file.uploader_id !== userId) return false

  const fullPath = path.join(UPLOAD_DIR, file.storage_path)

  try {
    await fs.unlink(fullPath)
  } catch {
    // File might already be deleted from disk
  }

  await pool.query(`DELETE FROM files WHERE id = $1`, [fileId])
  return true
}

export async function getFilesByMessage(messageId: number): Promise<FileRecord[]> {
  const result = await pool.query(
    `SELECT * FROM files WHERE message_id = $1 ORDER BY created_at`,
    [messageId]
  )
  return result.rows
}

export async function associateFileWithMessage(fileId: string, messageId: number, userId: string): Promise<boolean> {
  // Verify user owns the file and it's not already associated
  const result = await pool.query(
    `UPDATE files SET message_id = $1
     WHERE id = $2 AND uploader_id = $3 AND message_id IS NULL
     RETURNING id`,
    [messageId, fileId, userId]
  )
  return result.rows.length > 0
}

// Initialize upload directory on module load
ensureUploadDir()
```
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>fileService.ts exports upload, download, delete functions</done>
</task>

<task type="auto">
  <name>Task 2: Create file routes</name>
  <files>backend/src/routes/files.ts</files>
  <action>
Create files.ts with upload/download endpoints:

```typescript
import { FastifyInstance } from 'fastify'
import multipart from '@fastify/multipart'
import * as fileService from '../services/fileService'

export default async function fileRoutes(fastify: FastifyInstance) {
  // Register multipart support
  await fastify.register(multipart, {
    limits: {
      fileSize: 100 * 1024 * 1024 // 100MB
    }
  })

  // All routes require authentication
  fastify.addHook('onRequest', fastify.authenticate)

  // Upload file
  fastify.post<{ Querystring: { conversationId?: string } }>('/files', async (request, reply) => {
    const data = await request.file()
    if (!data) {
      return reply.code(400).send({ error: 'No file provided' })
    }

    // Read file into buffer
    const chunks: Buffer[] = []
    for await (const chunk of data.file) {
      chunks.push(chunk)
    }
    const buffer = Buffer.concat(chunks)

    // Get encryption header from form field
    const encryptionHeaderBase64 = data.fields.encryptionHeader
    if (!encryptionHeaderBase64 || typeof encryptionHeaderBase64 !== 'object' || !('value' in encryptionHeaderBase64)) {
      return reply.code(400).send({ error: 'Missing encryption header' })
    }

    const encryptionHeader = Buffer.from((encryptionHeaderBase64 as any).value, 'base64')

    try {
      const file = await fileService.uploadFile({
        uploaderId: request.user.id,
        conversationId: request.query.conversationId,
        filename: data.filename,
        mimeType: data.mimetype,
        encryptionHeader,
        data: buffer
      })

      return reply.code(201).send({
        id: file.id,
        filename: file.filename,
        mimeType: file.mime_type,
        sizeBytes: file.size_bytes
      })
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed'
      return reply.code(400).send({ error: message })
    }
  })

  // Download file
  fastify.get<{ Params: { fileId: string } }>('/files/:fileId', async (request, reply) => {
    const result = await fileService.getFileStream(request.params.fileId, request.user.id)

    if (!result) {
      return reply.code(404).send({ error: 'File not found' })
    }

    const { stream, file } = result

    // Return encryption header in response header
    reply.header('X-Encryption-Header', file.encryption_header.toString('base64'))
    reply.header('Content-Type', 'application/octet-stream')
    reply.header('Content-Length', file.size_bytes)
    reply.header('Content-Disposition', `attachment; filename="${encodeURIComponent(file.filename)}"`)

    return reply.send(stream)
  })

  // Get file metadata
  fastify.get<{ Params: { fileId: string } }>('/files/:fileId/meta', async (request, reply) => {
    const file = await fileService.getFile(request.params.fileId, request.user.id)

    if (!file) {
      return reply.code(404).send({ error: 'File not found' })
    }

    return {
      id: file.id,
      filename: file.filename,
      mimeType: file.mime_type,
      sizeBytes: file.size_bytes,
      encryptionHeader: file.encryption_header.toString('base64'),
      createdAt: file.created_at
    }
  })

  // Delete file
  fastify.delete<{ Params: { fileId: string } }>('/files/:fileId', async (request, reply) => {
    const success = await fileService.deleteFile(request.params.fileId, request.user.id)

    if (!success) {
      return reply.code(403).send({ error: 'Permission denied or file not found' })
    }

    return reply.code(204).send()
  })

  // Associate file with message (after message is created)
  fastify.patch<{ Params: { fileId: string }; Body: { messageId: number } }>(
    '/files/:fileId',
    async (request, reply) => {
      const success = await fileService.associateFileWithMessage(
        request.params.fileId,
        request.body.messageId,
        request.user.id
      )

      if (!success) {
        return reply.code(400).send({ error: 'Cannot associate file' })
      }

      return { success: true }
    }
  )
}
```
  </action>
  <verify>Run: cd backend && npx tsc --noEmit</verify>
  <done>files.ts exports default function with upload/download endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register file routes and install multipart</name>
  <files>backend/package.json, backend/src/server.ts</files>
  <action>
Install @fastify/multipart:
```bash
cd backend && npm install @fastify/multipart
```

Register file routes in server.ts:
```typescript
import fileRoutes from './routes/files'

// Add after existing route registrations
fastify.register(fileRoutes)
```

Add upload directory to docker-compose.yml volumes (if not already):
```yaml
backend:
  volumes:
    - ./uploads:/app/uploads
```
  </action>
  <verify>Run: cd backend && npm run build</verify>
  <done>Backend builds with multipart support and file routes registered</done>
</task>

</tasks>

<verification>
1. @fastify/multipart is installed
2. Backend TypeScript compiles
3. File routes registered in server
4. Upload directory structure is created
</verification>

<success_criteria>
- POST /files accepts multipart upload with encryptionHeader field
- GET /files/:id returns encrypted file stream with X-Encryption-Header
- DELETE /files/:id only works for uploader
- Files stored in organized year/month/day directory structure
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-communication/05-05-SUMMARY.md`
</output>
