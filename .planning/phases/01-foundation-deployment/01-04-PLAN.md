---
phase: 01-foundation-deployment
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - frontend/src/stores/auth.ts
  - frontend/src/lib/api.ts
  - frontend/src/pages/LoginPage.tsx
  - frontend/src/pages/SignupPage.tsx
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/components/auth/LoginForm.tsx
  - frontend/src/components/auth/SignupForm.tsx
  - frontend/src/components/auth/PasswordInput.tsx
  - frontend/src/routes/index.tsx
  - frontend/src/routes/ProtectedRoute.tsx
  - frontend/src/App.tsx
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "User can navigate to /signup and create an account"
    - "User can navigate to /login and sign in"
    - "After login, user is redirected to dashboard"
    - "User cannot access dashboard without being logged in"
    - "User can click logout in sidebar and be redirected to login"
    - "User stays logged in after page refresh (refresh token works)"
    - "Password field shows strength meter during signup"
    - "Login errors show generic 'Invalid credentials' message"
  artifacts:
    - path: "frontend/src/stores/auth.ts"
      provides: "Auth state management"
      exports: ["useAuthStore"]
    - path: "frontend/src/lib/api.ts"
      provides: "API client with auth"
      exports: ["api", "authApi"]
    - path: "frontend/src/pages/LoginPage.tsx"
      provides: "Login page"
      min_lines: 20
    - path: "frontend/src/pages/SignupPage.tsx"
      provides: "Signup page"
      min_lines: 20
    - path: "frontend/src/routes/ProtectedRoute.tsx"
      provides: "Auth guard"
      min_lines: 10
  key_links:
    - from: "frontend/src/stores/auth.ts"
      to: "/api/auth/*"
      via: "fetch with credentials"
      pattern: "credentials.*include"
    - from: "frontend/src/routes/ProtectedRoute.tsx"
      to: "frontend/src/stores/auth.ts"
      via: "useAuthStore check"
      pattern: "useAuthStore"
    - from: "frontend/src/components/layout/Sidebar.tsx"
      to: "frontend/src/stores/auth.ts"
      via: "logout action"
      pattern: "logout|useAuthStore"
---

<objective>
Implement frontend authentication with login/signup forms, protected routes, Zustand auth store, and API integration.

Purpose: Connects the frontend to the auth backend, enabling the complete signup/login/logout flow that users need.
Output: Working auth flow where users can sign up, log in, stay logged in across refreshes, and log out.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-deployment/01-RESEARCH.md
@.planning/phases/01-foundation-deployment/01-CONTEXT.md
@.planning/phases/01-foundation-deployment/01-02-SUMMARY.md
@.planning/phases/01-foundation-deployment/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand auth store and API client</name>
  <files>
    frontend/src/stores/auth.ts
    frontend/src/lib/api.ts
    frontend/package.json
  </files>
  <action>
**Add dependencies to package.json:**
- zxcvbn (password strength)
- react-hook-form, @hookform/resolvers, zod (form handling)

**Create frontend/src/lib/api.ts:**
API client with automatic token refresh:

```typescript
const API_BASE = import.meta.env.VITE_API_URL || '/api';

// Single in-flight refresh promise to prevent thundering herd
let refreshPromise: Promise<string> | null = null;

export async function fetchWithAuth(
  url: string,
  options: RequestInit = {}
): Promise<Response> {
  const authStore = (await import('../stores/auth')).useAuthStore.getState();

  const headers = new Headers(options.headers);
  if (authStore.accessToken) {
    headers.set('Authorization', `Bearer ${authStore.accessToken}`);
  }
  headers.set('Content-Type', 'application/json');

  const response = await fetch(`${API_BASE}${url}`, {
    ...options,
    headers,
    credentials: 'include', // CRITICAL: send cookies
  });

  // Handle 401 - attempt refresh
  if (response.status === 401 && !url.includes('/auth/refresh')) {
    const newToken = await refreshAccessToken();
    if (newToken) {
      headers.set('Authorization', `Bearer ${newToken}`);
      return fetch(`${API_BASE}${url}`, {
        ...options,
        headers,
        credentials: 'include',
      });
    }
  }

  return response;
}

async function refreshAccessToken(): Promise<string | null> {
  const authStore = (await import('../stores/auth')).useAuthStore.getState();

  // Reuse existing refresh promise (thundering herd prevention)
  if (refreshPromise) {
    return refreshPromise;
  }

  refreshPromise = (async () => {
    try {
      const response = await fetch(`${API_BASE}/auth/refresh`, {
        method: 'POST',
        credentials: 'include',
      });

      if (response.ok) {
        const data = await response.json();
        authStore.setAccessToken(data.accessToken);
        return data.accessToken;
      } else {
        authStore.logout();
        return null;
      }
    } finally {
      refreshPromise = null;
    }
  })();

  return refreshPromise;
}

// Convenience methods
export const api = {
  get: (url: string) => fetchWithAuth(url),
  post: (url: string, body: unknown) =>
    fetchWithAuth(url, { method: 'POST', body: JSON.stringify(body) }),
  put: (url: string, body: unknown) =>
    fetchWithAuth(url, { method: 'PUT', body: JSON.stringify(body) }),
  delete: (url: string) =>
    fetchWithAuth(url, { method: 'DELETE' }),
};
```

**Create frontend/src/stores/auth.ts:**
Zustand store for auth state:

```typescript
import { create } from 'zustand';

interface User {
  id: string;
  email: string;
}

interface AuthState {
  accessToken: string | null;
  user: User | null;
  isLoading: boolean;
  isInitialized: boolean;

  setAccessToken: (token: string) => void;
  setUser: (user: User | null) => void;
  login: (email: string, password: string) => Promise<void>;
  signup: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

const API_BASE = import.meta.env.VITE_API_URL || '/api';

export const useAuthStore = create<AuthState>((set, get) => ({
  accessToken: null,
  user: null,
  isLoading: false,
  isInitialized: false,

  setAccessToken: (token) => set({ accessToken: token }),
  setUser: (user) => set({ user }),

  login: async (email, password) => {
    set({ isLoading: true });
    try {
      const res = await fetch(`${API_BASE}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Login failed');
      }

      const data = await res.json();
      set({ accessToken: data.accessToken, user: data.user });
    } finally {
      set({ isLoading: false });
    }
  },

  signup: async (email, password) => {
    set({ isLoading: true });
    try {
      const res = await fetch(`${API_BASE}/auth/signup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Signup failed');
      }

      const data = await res.json();
      set({ accessToken: data.accessToken, user: data.user });
    } finally {
      set({ isLoading: false });
    }
  },

  logout: async () => {
    await fetch(`${API_BASE}/auth/logout`, {
      method: 'POST',
      credentials: 'include',
    });
    set({ accessToken: null, user: null });
  },

  checkAuth: async () => {
    try {
      const res = await fetch(`${API_BASE}/auth/refresh`, {
        method: 'POST',
        credentials: 'include',
      });

      if (res.ok) {
        const data = await res.json();
        set({ accessToken: data.accessToken });

        // Fetch user data
        const userRes = await fetch(`${API_BASE}/auth/me`, {
          headers: { 'Authorization': `Bearer ${data.accessToken}` },
        });
        if (userRes.ok) {
          const userData = await userRes.json();
          set({ user: userData });
        }
      }
    } catch {
      // Not logged in, that's fine
    } finally {
      set({ isInitialized: true });
    }
  },
}));
```
  </action>
  <verify>
    - TypeScript compiles without errors
    - useAuthStore exports all required methods
    - api.ts has credentials: 'include' for all requests
    - Refresh token logic prevents thundering herd (single promise)
  </verify>
  <done>Auth store and API client created with token refresh and thundering herd prevention</done>
</task>

<task type="auto">
  <name>Task 2: Create login and signup forms with validation</name>
  <files>
    frontend/src/components/auth/LoginForm.tsx
    frontend/src/components/auth/SignupForm.tsx
    frontend/src/components/auth/PasswordInput.tsx
    frontend/src/pages/LoginPage.tsx
    frontend/src/pages/SignupPage.tsx
    frontend/src/components/ui/input.tsx
    frontend/src/components/ui/label.tsx
    frontend/src/components/ui/card.tsx
  </files>
  <action>
**Create shadcn/ui components (minimal versions):**
- frontend/src/components/ui/input.tsx - styled input with cn()
- frontend/src/components/ui/label.tsx - styled label
- frontend/src/components/ui/card.tsx - Card, CardHeader, CardContent, CardFooter

**Create frontend/src/components/auth/PasswordInput.tsx:**
Password input with:
- Show/hide toggle (Eye/EyeOff icons from lucide-react)
- Optional strength meter (when showStrength prop is true)
- Use zxcvbn for strength calculation (0-4 score)
- Visual strength bar (5 segments, colored based on score)
- Labels: Weak, Fair, Good, Strong, Very Strong
- Register compatible (accepts ...register('password'))

**Create frontend/src/components/auth/LoginForm.tsx:**
- Use react-hook-form with zod validation
- Schema: email (valid email), password (min 1 char - don't reveal requirements)
- Fields: email input, password input (no strength meter)
- Submit button with loading state
- Error display for form-level errors (from API)
- Error message: "Invalid credentials" (generic per CONTEXT.md)
- Link to signup page

**Create frontend/src/components/auth/SignupForm.tsx:**
- Use react-hook-form with zod validation
- Schema: email (valid email), password (min 8 chars)
- Fields: email input, password input WITH strength meter
- Submit button with loading state
- Error display for form-level errors
- Link to login page

**Create frontend/src/pages/LoginPage.tsx:**
- Centered card layout (per CONTEXT.md)
- Contains LoginForm
- Title: "Welcome back"
- Subtitle: "Sign in to your account"

**Create frontend/src/pages/SignupPage.tsx:**
- Centered card layout
- Contains SignupForm
- Title: "Create account"
- Subtitle: "Get started with ChatApp"

Both pages should redirect to /dashboard after successful auth.
  </action>
  <verify>
    - Login page renders with form
    - Signup page renders with form and password strength meter
    - Password visibility toggle works
    - Form validation shows errors
    - Submitting calls the auth store methods
  </verify>
  <done>Login and signup forms work with validation, strength meter, and API integration</done>
</task>

<task type="auto">
  <name>Task 3: Implement routing with protected routes</name>
  <files>
    frontend/src/routes/index.tsx
    frontend/src/routes/ProtectedRoute.tsx
    frontend/src/pages/DashboardPage.tsx
    frontend/src/App.tsx
    frontend/src/components/layout/Sidebar.tsx
  </files>
  <action>
**Create frontend/src/routes/ProtectedRoute.tsx:**
```typescript
import { Navigate, Outlet } from 'react-router';
import { useAuthStore } from '../stores/auth';
import { AppShell } from '../components/layout/AppShell';

export function ProtectedRoute() {
  const { accessToken, user, isInitialized } = useAuthStore();

  // Wait for auth check to complete
  if (!isInitialized) {
    return <div className="flex h-screen items-center justify-center">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
    </div>;
  }

  if (!accessToken || !user) {
    return <Navigate to="/login" replace />;
  }

  return (
    <AppShell>
      <Outlet />
    </AppShell>
  );
}
```

**Create frontend/src/pages/DashboardPage.tsx:**
- Welcome message with user email
- Placeholder content: "Select a conversation to get started"
- Centered in main area

**Create frontend/src/routes/index.tsx:**
Router configuration using React Router 7:
```typescript
import { createBrowserRouter } from 'react-router';
import { LoginPage } from '../pages/LoginPage';
import { SignupPage } from '../pages/SignupPage';
import { DashboardPage } from '../pages/DashboardPage';
import { ProtectedRoute } from './ProtectedRoute';

export const router = createBrowserRouter([
  { path: '/login', element: <LoginPage /> },
  { path: '/signup', element: <SignupPage /> },
  {
    element: <ProtectedRoute />,
    children: [
      { path: '/', element: <DashboardPage /> },
      { path: '/dashboard', element: <DashboardPage /> },
    ],
  },
]);
```

**Update frontend/src/App.tsx:**
- Call useAuthStore().checkAuth() on mount (useEffect)
- Render RouterProvider with router
- Keep ThemeProvider wrapping

**Update frontend/src/components/layout/Sidebar.tsx:**
- Display user email/avatar (get from useAuthStore)
- Make logout button functional (call useAuthStore().logout())
- After logout, redirect to /login (use useNavigate)
  </action>
  <verify>
    - Navigating to / or /dashboard redirects to /login when not logged in
    - After login, user lands on dashboard
    - Dashboard shows user email
    - Logout button in sidebar works and redirects to login
    - Refreshing page while logged in maintains session (refresh token works)
  </verify>
  <done>Routing works with protected routes, session persistence, and working logout</done>
</task>

</tasks>

<verification>
Full auth flow test:

```bash
# Start full stack
docker compose up --build -d

# Wait for services
sleep 30

# Open browser to http://localhost
# Should redirect to /login

# 1. Test signup
# - Navigate to /signup
# - Enter email: test@example.com
# - Enter password: MySecurePass123
# - Observe strength meter
# - Submit
# - Should redirect to dashboard
# - Should see user email in sidebar

# 2. Test session persistence
# - Refresh page
# - Should still be on dashboard (not redirected to login)
# - User email still visible

# 3. Test logout
# - Click logout in sidebar
# - Should redirect to /login
# - Navigate to /dashboard directly
# - Should redirect back to /login

# 4. Test login
# - Enter credentials from signup
# - Submit
# - Should redirect to dashboard

# 5. Test invalid login
# - Logout first
# - Enter wrong password
# - Should see "Invalid credentials" error
```
</verification>

<success_criteria>
1. /login and /signup pages render with forms
2. Password input has show/hide toggle
3. Signup form shows password strength meter
4. Form validation works (email format, password length)
5. Successful signup auto-logs in and redirects to dashboard
6. Successful login redirects to dashboard
7. Invalid login shows "Invalid credentials" (generic message)
8. Protected routes redirect to /login when not authenticated
9. Session persists across page refresh (refresh token)
10. Logout clears session and redirects to login
11. User email displayed in sidebar when logged in
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-deployment/01-04-SUMMARY.md`
</output>
