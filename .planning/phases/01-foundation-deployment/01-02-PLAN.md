---
phase: 01-foundation-deployment
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/server.ts
  - backend/src/routes/auth.ts
  - backend/src/services/auth.service.ts
  - backend/src/db/index.ts
  - backend/src/types/index.ts
  - backend/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "User can POST /api/auth/signup with email/password and receive access token"
    - "User can POST /api/auth/login with valid credentials and receive access token"
    - "User receives httpOnly cookie with refresh token on login/signup"
    - "User can POST /api/auth/refresh and get new access token"
    - "User can POST /api/auth/logout and have refresh token cleared"
    - "Invalid credentials return 401 with generic error message"
  artifacts:
    - path: "backend/src/routes/auth.ts"
      provides: "Auth route handlers"
      exports: ["authRoutes"]
    - path: "backend/src/services/auth.service.ts"
      provides: "Auth business logic"
      exports: ["AuthService"]
    - path: "backend/src/db/index.ts"
      provides: "Database connection pool"
      exports: ["pool", "query"]
  key_links:
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/services/auth.service.ts"
      via: "service method calls"
      pattern: "authService\\."
    - from: "backend/src/services/auth.service.ts"
      to: "backend/src/db/index.ts"
      via: "database queries"
      pattern: "pool\\.query|query\\("
    - from: "backend/src/routes/auth.ts"
      to: "httpOnly cookie"
      via: "reply.setCookie"
      pattern: "setCookie.*httpOnly.*true"
---

<objective>
Implement complete JWT authentication API with signup, login, refresh, and logout endpoints following security best practices.

Purpose: Core authentication is required before any protected features. This plan implements the auth backend that the frontend will consume.
Output: Working auth API with proper JWT handling, bcrypt password hashing, and sliding window refresh tokens.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-deployment/01-RESEARCH.md
@.planning/phases/01-foundation-deployment/01-CONTEXT.md
@.planning/phases/01-foundation-deployment/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database connection and TypeScript configuration</name>
  <files>
    backend/tsconfig.json
    backend/src/db/index.ts
    backend/src/types/index.ts
  </files>
  <action>
**backend/tsconfig.json:**
Configure TypeScript for Node.js ESM:
- target: ES2022
- module: NodeNext
- moduleResolution: NodeNext
- outDir: ./dist
- rootDir: ./src
- strict: true
- esModuleInterop: true
- skipLibCheck: true
- declaration: true

**backend/src/types/index.ts:**
Define core types:
```typescript
export interface User {
  id: string;
  email: string;
  password_hash: string;
  email_verified: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface JwtPayload {
  userId: string;
  email: string;
}

export interface AuthResponse {
  accessToken: string;
  user: {
    id: string;
    email: string;
  };
}
```

**backend/src/db/index.ts:**
Create PostgreSQL connection pool:
- Import pg Pool
- Create pool with DATABASE_URL from environment
- Export query helper function that wraps pool.query
- Export pool for direct access if needed
- Add connection test on startup (log success/failure)
  </action>
  <verify>
    - tsc compiles without errors
    - backend/src/db/index.ts exports pool and query
    - Types are properly defined and exported
  </verify>
  <done>TypeScript compiles, database connection pool created and exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement auth service with bcrypt and JWT</name>
  <files>
    backend/src/services/auth.service.ts
  </files>
  <action>
Create AuthService class with methods:

**signup(email: string, password: string): Promise<User>**
- Hash password with bcrypt (12 salt rounds)
- Insert user into database
- Return created user (without password_hash in response)
- Throw error if email already exists (catch unique constraint, return generic "Email already registered")

**login(email: string, password: string): Promise<User | null>**
- Query user by email
- Compare password with bcrypt
- Return user if valid, null if invalid
- IMPORTANT: Use constant-time comparison, return same error for "user not found" and "wrong password" (prevents user enumeration)

**findById(userId: string): Promise<User | null>**
- Query user by id
- Return user or null

**generateTokens(user: User, jwtSign: Function): { accessToken: string, refreshToken: string }**
- Access token: { userId: user.id, email: user.email }, expires in JWT_ACCESS_EXPIRY (default 15m)
- Refresh token: { userId: user.id }, expires in JWT_REFRESH_EXPIRY (default 7d)
- Return both tokens

Note: Use environment variables for expiry times (process.env.JWT_ACCESS_EXPIRY || '15m')
  </action>
  <verify>
    - AuthService exports all four methods
    - bcrypt.hash is called with 12 salt rounds
    - Login returns null for both "not found" and "wrong password" (no user enumeration)
    - Token generation uses environment variables for expiry
  </verify>
  <done>AuthService implements signup, login, findById, and generateTokens with proper security</done>
</task>

<task type="auto">
  <name>Task 3: Implement auth routes with cookie handling</name>
  <files>
    backend/src/routes/auth.ts
    backend/src/server.ts
  </files>
  <action>
**backend/src/routes/auth.ts:**
Create Fastify plugin with auth routes:

**POST /auth/signup**
- Body: { email: string, password: string }
- Validate email format (basic regex, not complex - see research)
- Validate password length >= 8
- Call authService.signup()
- Generate tokens
- Set refresh token in httpOnly cookie:
  - httpOnly: true
  - secure: process.env.NODE_ENV === 'production'
  - sameSite: 'strict'
  - path: '/api/auth'
  - maxAge: 7 * 24 * 60 * 60 * 1000 (7 days in ms)
- Return { accessToken, user: { id, email } }
- On duplicate email: return 400 { error: "Email already registered" }

**POST /auth/login**
- Body: { email: string, password: string }
- Call authService.login()
- If null: return 401 { error: "Invalid credentials" } (generic message per CONTEXT.md)
- Generate tokens, set cookie, return same as signup

**POST /auth/refresh**
- Read refreshToken from cookies
- If missing: return 401 { error: "No refresh token" }
- Verify JWT, extract userId
- Find user by id
- Generate NEW tokens (sliding window - both access AND refresh)
- Set new refresh token cookie (resets 7-day expiry)
- Return { accessToken }
- On invalid/expired token: return 401 { error: "Invalid refresh token" }

**POST /auth/logout**
- Clear refresh token cookie (set maxAge: 0)
- Return { success: true }

**POST /auth/me** (bonus - useful for frontend)
- Require Authorization: Bearer <accessToken> header
- Verify token, return user data
- Return 401 if invalid

**backend/src/server.ts:**
Update to:
- Register @fastify/cookie plugin (add to package.json if missing)
- Register @fastify/jwt with secret from JWT_SECRET env var
- Register @fastify/cors with credentials: true, origin from CORS_ORIGIN env var or default to '*' in dev
- Register authRoutes with prefix '/auth'
- Keep /health endpoint
  </action>
  <verify>
    - All 5 endpoints respond correctly (test with curl)
    - Signup returns accessToken and sets httpOnly cookie
    - Login with wrong password returns 401 "Invalid credentials"
    - Refresh returns new accessToken and sets new cookie
    - Logout clears the cookie
    - /auth/me with valid token returns user data
  </verify>
  <done>All auth endpoints work, cookies are httpOnly with proper settings, sliding window refresh implemented</done>
</task>

</tasks>

<verification>
Test auth flow with curl commands:

```bash
# Ensure backend is running
docker compose up -d

# Signup
curl -X POST http://localhost:3000/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}' \
  -c cookies.txt -v
# Should return {"accessToken":"...","user":{"id":"...","email":"..."}}
# Should set refreshToken cookie

# Login
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}' \
  -c cookies.txt -v
# Should return same format as signup

# Login with wrong password
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"wrongpassword"}'
# Should return 401 {"error":"Invalid credentials"}

# Refresh (using saved cookies)
curl -X POST http://localhost:3000/auth/refresh \
  -b cookies.txt -c cookies.txt
# Should return {"accessToken":"..."}

# Me endpoint
ACCESS_TOKEN="<paste from signup/login response>"
curl http://localhost:3000/auth/me \
  -H "Authorization: Bearer $ACCESS_TOKEN"
# Should return user data

# Logout
curl -X POST http://localhost:3000/auth/logout \
  -b cookies.txt -c cookies.txt
# Should return {"success":true}

# Cleanup
rm cookies.txt
```
</verification>

<success_criteria>
1. POST /auth/signup creates user and returns access token
2. POST /auth/login validates credentials and returns access token
3. Invalid login returns 401 with generic "Invalid credentials" (no user enumeration)
4. POST /auth/refresh returns new access token and rotates refresh token (sliding window)
5. POST /auth/logout clears the refresh token cookie
6. Refresh token is httpOnly, secure in production, sameSite strict
7. Access token expires in 15 minutes, refresh token in 7 days
8. Passwords are hashed with bcrypt (12 rounds)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-deployment/01-02-SUMMARY.md`
</output>
