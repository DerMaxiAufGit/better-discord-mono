---
phase: 01-foundation-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - .env.example
  - postgres/init.sql
  - backend/Dockerfile
  - frontend/Dockerfile
  - frontend/nginx.conf
autonomous: true

must_haves:
  truths:
    - "User can run docker compose up and all containers start"
    - "All containers report healthy status"
    - "PostgreSQL accepts connections and has users table"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Service orchestration"
      contains: "services:"
    - path: ".env.example"
      provides: "Configuration template"
      contains: "DB_PASSWORD"
    - path: "postgres/init.sql"
      provides: "Initial database schema"
      contains: "CREATE TABLE users"
    - path: "backend/Dockerfile"
      provides: "Backend container build"
      contains: "FROM node"
    - path: "frontend/Dockerfile"
      provides: "Frontend container build"
      contains: "FROM node"
  key_links:
    - from: "docker-compose.yml"
      to: "postgres"
      via: "depends_on with health check"
      pattern: "condition: service_healthy"
    - from: "docker-compose.yml"
      to: ".env"
      via: "environment variable interpolation"
      pattern: "\\$\\{DB_"
---

<objective>
Create Docker Compose infrastructure with PostgreSQL database, backend and frontend containers, health checks, and environment variable configuration.

Purpose: Establishes the deployable foundation. Without this, there's no way to run or deploy the app.
Output: Working `docker compose up` that starts all services with proper health checks and startup ordering.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-deployment/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose orchestration with health checks</name>
  <files>
    docker-compose.yml
    .env.example
    .env
  </files>
  <action>
Create docker-compose.yml with three services:

1. **postgres** service:
   - Image: postgres:18-alpine
   - Environment: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB from env vars
   - Volume: postgres_data:/var/lib/postgresql/data (NOT /var/lib/postgresql - must include /data)
   - Volume: ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
   - Health check: pg_isready -U ${DB_USER} -d ${DB_NAME}
   - Health check timing: interval 10s, timeout 5s, retries 5, start_period 30s

2. **backend** service:
   - Build: ./backend
   - Environment: DATABASE_URL, JWT_SECRET, JWT_ACCESS_EXPIRY (15m), JWT_REFRESH_EXPIRY (7d), NODE_ENV
   - depends_on postgres with condition: service_healthy
   - Port: 3000:3000
   - Health check: wget --spider -q http://localhost:3000/health (install wget in Dockerfile)
   - Health check timing: interval 10s, timeout 3s, retries 3

3. **frontend** service:
   - Build: ./frontend with args VITE_API_URL
   - depends_on backend with condition: service_healthy
   - Port: 80:80
   - Health check: wget --spider -q http://localhost:80
   - Health check timing: interval 30s, timeout 3s

Create .env.example with all required variables and placeholder values:
- DB_USER, DB_PASSWORD, DB_NAME
- JWT_SECRET (with note to change in production)
- JWT_ACCESS_EXPIRY=15m, JWT_REFRESH_EXPIRY=7d
- VITE_API_URL=/api (for production proxy)

Copy .env.example to .env for local development.

Define named volume postgres_data at bottom.
  </action>
  <verify>
    - docker compose config shows valid YAML with no errors
    - All three services defined with health checks
    - Environment variable interpolation works (no literal ${VAR} in output)
  </verify>
  <done>docker-compose.yml parses successfully and references all expected environment variables</done>
</task>

<task type="auto">
  <name>Task 2: Create database schema and container configurations</name>
  <files>
    postgres/init.sql
    backend/Dockerfile
    backend/package.json
    backend/src/server.ts
    frontend/Dockerfile
    frontend/nginx.conf
  </files>
  <action>
**postgres/init.sql:**
Create users table with:
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- email: VARCHAR(255) UNIQUE NOT NULL
- password_hash: VARCHAR(255) NOT NULL
- email_verified: BOOLEAN DEFAULT FALSE (for future use per research)
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()

Create index on email for login lookup.

**backend/Dockerfile:**
Multi-stage build:
- Stage 1 (builder): node:20-alpine, WORKDIR /app, copy package*.json, npm ci, copy src, npm run build
- Stage 2 (runtime): node:20-alpine, RUN apk add --no-cache wget (for health check), WORKDIR /app, copy from builder /app/dist and node_modules, EXPOSE 3000, CMD ["node", "dist/server.js"]

**backend/package.json:**
Minimal package.json with:
- name: "backend"
- type: "module"
- scripts: { "build": "tsc", "start": "node dist/server.js", "dev": "tsx watch src/server.ts" }
- dependencies: fastify, @fastify/cors, @fastify/jwt, @fastify/cookie, pg, bcrypt, dotenv
- devDependencies: @types/node, @types/bcrypt, @types/pg, typescript, tsx

**backend/src/server.ts:**
Minimal Fastify server with health endpoint only (auth routes in Plan 02):
- Import fastify, register cors and jwt plugins
- GET /health returns { status: 'ok' }
- Listen on 0.0.0.0:3000

**frontend/Dockerfile:**
Multi-stage build:
- Stage 1 (builder): node:20-alpine, WORKDIR /app, copy package*.json, npm ci, copy source, ARG VITE_API_URL, ENV VITE_API_URL=$VITE_API_URL, npm run build
- Stage 2 (runtime): nginx:alpine, RUN apk add --no-cache wget (for health check), copy from builder /app/dist to /usr/share/nginx/html, copy nginx.conf to /etc/nginx/conf.d/default.conf, EXPOSE 80

**frontend/nginx.conf:**
Configure nginx to:
- Serve static files from /usr/share/nginx/html
- Proxy /api/* requests to http://backend:3000 (strip /api prefix)
- Return index.html for all non-file routes (SPA routing)
  </action>
  <verify>
    - postgres/init.sql contains CREATE TABLE users with all columns
    - backend/Dockerfile builds without errors: docker build -t test-backend ./backend
    - frontend/Dockerfile builds without errors: docker build -t test-frontend ./frontend
    - backend/src/server.ts compiles with tsc
  </verify>
  <done>All Dockerfiles build successfully, init.sql creates users table with proper schema</done>
</task>

<task type="auto">
  <name>Task 3: Verify full stack startup</name>
  <files>None (verification only)</files>
  <action>
Run full stack verification:

1. Create minimal frontend placeholder:
   - frontend/package.json with vite, react, react-dom, typescript
   - frontend/index.html with root div
   - frontend/src/main.tsx rendering "App loading..."
   - frontend/vite.config.ts with react plugin
   - frontend/tsconfig.json for TypeScript

2. Start the stack:
   - docker compose up --build -d
   - Wait for all services healthy: docker compose ps (all should show "healthy")

3. Verify each service:
   - PostgreSQL: docker compose exec postgres psql -U $DB_USER -d $DB_NAME -c "SELECT * FROM users LIMIT 1" (should return empty, not error)
   - Backend: curl http://localhost:3000/health (should return {"status":"ok"})
   - Frontend: curl http://localhost:80 (should return HTML)

4. Clean up:
   - docker compose down

If any service fails health check, diagnose and fix before marking complete.
  </action>
  <verify>
    - docker compose ps shows all 3 services as "healthy"
    - curl http://localhost:3000/health returns 200
    - curl http://localhost:80 returns HTML content
    - PostgreSQL users table exists and is queryable
  </verify>
  <done>All three containers start, pass health checks, and communicate correctly</done>
</task>

</tasks>

<verification>
Run these commands to verify the plan succeeded:

```bash
# Full verification sequence
docker compose down -v  # Clean slate
docker compose up --build -d
sleep 30  # Wait for health checks
docker compose ps  # All healthy
curl -f http://localhost:3000/health  # Backend responds
curl -f http://localhost:80  # Frontend serves
docker compose exec postgres psql -U chatapp -d chatapp -c "\dt"  # users table exists
docker compose down
```
</verification>

<success_criteria>
1. `docker compose up` starts all services without manual intervention
2. All three containers report "healthy" in `docker compose ps`
3. PostgreSQL has users table with correct schema
4. Backend /health endpoint returns 200
5. Frontend serves static content and proxies /api to backend
6. .env.example documents all required configuration
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-deployment/01-01-SUMMARY.md`
</output>
