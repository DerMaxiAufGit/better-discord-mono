---
phase: 03-voice-video-calls
plan: 07
type: execute
wave: 5
depends_on: ["03-03", "03-05", "03-06"]
files_modified:
  - frontend/src/App.tsx
  - frontend/src/components/messaging/ConversationView.tsx
  - frontend/src/pages/ContactsPage.tsx
  - frontend/src/lib/websocket/useMessaging.ts
  - frontend/src/components/layout/AppShell.tsx
autonomous: false

must_haves:
  truths:
    - "User can start call from chat header"
    - "User can start call from contact profile"
    - "Incoming call notification shows anywhere in app"
    - "Missed calls appear as system message in chat"
    - "Call connection works across NAT"
  artifacts:
    - path: "frontend/src/components/messaging/ConversationView.tsx"
      provides: "Call button in chat header"
      contains: "startCall"
    - path: "frontend/src/components/layout/AppShell.tsx"
      provides: "IncomingCallBanner and ActiveCallWindow mounting"
      contains: "IncomingCallBanner"
  key_links:
    - from: "frontend/src/components/messaging/ConversationView.tsx"
      to: "frontend/src/lib/webrtc/useCall.ts"
      via: "startCall action"
      pattern: "useCall|startCall"
    - from: "frontend/src/lib/websocket/useMessaging.ts"
      to: "call signaling handlers"
      via: "WebSocket message routing"
      pattern: "call-offer|call-answer"
---

<objective>
Integrate call functionality throughout the app: add call buttons, wire up signaling to useMessaging, mount global call UI components, and add missed call system messages.

Purpose: Connect all the call infrastructure created in previous plans into a cohesive calling experience. Users should be able to initiate calls from natural places (chat, contacts) and receive incoming calls no matter where they are in the app.

Output: Fully integrated calling with call buttons in chat and contacts, global incoming call notifications, and system messages for missed calls.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-video-calls/03-CONTEXT.md
@.planning/phases/03-voice-video-calls/03-03-SUMMARY.md
@.planning/phases/03-voice-video-calls/03-05-SUMMARY.md
@.planning/phases/03-voice-video-calls/03-06-SUMMARY.md

# Files to modify
@frontend/src/App.tsx
@frontend/src/components/messaging/ConversationView.tsx
@frontend/src/pages/ContactsPage.tsx
@frontend/src/lib/websocket/useMessaging.ts
@frontend/src/components/layout/AppShell.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire call signaling into useMessaging</name>
  <files>frontend/src/lib/websocket/useMessaging.ts</files>
  <action>
Extend useMessaging to handle call signaling messages:

Add call message handlers in the ws.onmessage switch:

```typescript
// Add to storeRefs
import { useCallStore } from '@/stores/callStore'
// In storeRefs.current, add call store actions

// In ws.onmessage handler:
case 'call-offer':
  // Incoming call
  const { callId, senderId, senderUsername, sdp } = data;
  // Determine polite role
  const isPolite = currentUser.id.toString() > senderId;
  callStore.receiveIncomingCall(callId, senderId, senderUsername, isPolite);
  // Store pending SDP for when user accepts
  pendingSdpRef.current = sdp;
  break;

case 'call-accept':
  // Callee accepted, proceed with connection
  if (callStore.status === 'outgoing') {
    callStore.setConnecting();
    // Signal to useCall to proceed with negotiation
    callAcceptedCallback?.();
  }
  break;

case 'call-answer':
  // Received answer SDP
  callAnswerCallback?.(data.sdp);
  break;

case 'call-ice-candidate':
  // Received ICE candidate
  iceCandidateCallback?.(data.candidate);
  break;

case 'call-reject':
  // Callee rejected
  callStore.endCall();
  // Could show toast: "Call declined"
  break;

case 'call-hangup':
  // Remote party hung up
  callStore.endCall();
  break;
```

Export callbacks so useCall can register handlers:
```typescript
interface UseMessagingReturn {
  // Existing...
  isConnected: boolean;
  sendMessage: ...;
  markAsRead: ...;

  // Call signaling
  sendCallSignal: (type: string, recipientId: string, data: object) => void;
  registerCallHandlers: (handlers: CallHandlers) => void;
}
```

sendCallSignal wraps WebSocket send for call messages.
  </action>
  <verify>Connect WebSocket, receive a call-offer message, verify callStore updates to 'incoming' state.</verify>
  <done>useMessaging routes call signaling messages to appropriate handlers</done>
</task>

<task type="auto">
  <name>Task 2: Add call buttons and mount global call UI</name>
  <files>frontend/src/components/messaging/ConversationView.tsx, frontend/src/pages/ContactsPage.tsx, frontend/src/components/layout/AppShell.tsx</files>
  <action>
**ConversationView.tsx - Add call button to header:**

```tsx
import { Phone } from 'lucide-react';
import { useCall } from '@/lib/webrtc/useCall';

// In header section, after the contact name:
const { startCall, status } = useCall();

<Button
  variant="ghost"
  size="icon"
  onClick={() => startCall(contactId, contactUsername)}
  disabled={status !== 'idle' || !isConnected}
  title="Start voice call"
>
  <Phone className="h-5 w-5" />
</Button>
```

**ContactsPage.tsx - Add call button to contact cards/profile:**

Add call button next to message button on contact items:
```tsx
<Button
  variant="ghost"
  size="icon"
  onClick={() => startCall(contact.id, contact.username)}
  disabled={callStatus !== 'idle'}
>
  <Phone className="h-4 w-4" />
</Button>
```

**AppShell.tsx - Mount global call components:**

```tsx
import { useCallStore } from '@/stores/callStore';
import { IncomingCallBanner } from '@/components/call/IncomingCallBanner';
import { ActiveCallWindow } from '@/components/call/ActiveCallWindow';
import { useCall } from '@/lib/webrtc/useCall';

// Inside AppShell:
const { status } = useCallStore();
const callActions = useCall();

// At top level of return (before main layout):
{status === 'incoming' && (
  <IncomingCallBanner
    callerUsername={callStore.remoteUsername!}
    onAccept={callActions.acceptCall}
    onReject={callActions.rejectCall}
    ringTimeout={settingsStore.ringTimeout}
  />
)}

{['connecting', 'connected', 'reconnecting'].includes(status) && (
  <ActiveCallWindow {...callActions} />
)}
```

IncomingCallBanner renders at top of viewport (position fixed).
ActiveCallWindow renders full page or floating based on isMinimized.
  </action>
  <verify>Navigate to a conversation, verify phone icon in header. Click it, verify call-offer is sent. Have another client receive it and verify IncomingCallBanner appears.</verify>
  <done>Call buttons available in chat and contacts, global call UI mounts correctly</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete voice call functionality:
- Coturn TURN server running in Docker
- Call signaling through existing WebSocket
- Perfect Negotiation WebRTC connection
- Incoming call notifications
- Active call UI with mute and quality display
- Audio settings in SettingsPage
  </what-built>
  <how-to-verify>
1. Start the application: `docker compose up -d`
2. Open two browser windows (or use incognito for second user)
3. Log in as two different users (create if needed)
4. Ensure both users are friends
5. Go to Settings > Audio on both browsers, grant microphone permission
6. User A: Open chat with User B, click phone icon in header
7. User B: Should see incoming call banner at top of screen
8. User B: Click Accept
9. Verify: Both see "Connecting..." then "Connected"
10. Verify: Speak into microphone, audio should be heard by other party
11. Verify: Mute button works (muted user's audio not heard)
12. Verify: Quality indicator shows (bars + latency)
13. Verify: Timer counts up
14. Verify: Either party can click End Call

If testing across networks (not localhost):
- Verify call connects even behind NAT (TURN relay working)
- Check Docker logs: `docker compose logs coturn`
  </how-to-verify>
  <resume-signal>Type "approved" if calls work, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. Call button visible in ConversationView header
2. Call button visible in ContactsPage
3. Clicking call button sends call-offer via WebSocket
4. Receiving call-offer shows IncomingCallBanner
5. Accept/reject buttons work correctly
6. Connected call has working audio
7. Mute, hangup, minimize all function
8. Quality metrics update during call
9. Call works across different networks (TURN relay)
</verification>

<success_criteria>
- Voice calls work end-to-end between two users
- Call UI integrates seamlessly with existing app
- NAT traversal works via self-hosted coturn
- All Phase 3 success criteria from ROADMAP.md verified:
  1. User can initiate voice call with online contact
  2. User receives incoming call notification and can accept/decline
  3. User can mute/unmute microphone during active call
  4. Calls establish successfully even behind NAT/firewall (TURN relay)
  5. User sees connection quality indicators during call
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-video-calls/03-07-SUMMARY.md`
</output>
