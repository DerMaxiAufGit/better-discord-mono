---
phase: 03-voice-video-calls
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - backend/src/routes/websocket.ts
  - frontend/src/lib/api.ts
  - frontend/src/lib/webrtc/PeerConnection.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket can relay call signaling messages between peers"
    - "Frontend can create RTCPeerConnection with TURN credentials"
    - "Perfect Negotiation pattern handles offer/answer exchange"
  artifacts:
    - path: "backend/src/routes/websocket.ts"
      provides: "Call signaling message types"
      contains: "call-offer"
    - path: "frontend/src/lib/webrtc/PeerConnection.ts"
      provides: "RTCPeerConnection wrapper with Perfect Negotiation"
      exports: ["createPeerConnection", "PeerConnectionManager"]
      min_lines: 150
    - path: "frontend/src/lib/api.ts"
      provides: "TURN credentials fetching"
      contains: "turn/credentials"
  key_links:
    - from: "frontend/src/lib/webrtc/PeerConnection.ts"
      to: "frontend/src/lib/api.ts"
      via: "fetch TURN credentials"
      pattern: "turnApi|getTurnCredentials"
    - from: "backend/src/routes/websocket.ts"
      to: "activeConnections"
      via: "forward call signaling"
      pattern: "call-offer|call-answer|call-ice"
---

<objective>
Extend WebSocket protocol with call signaling messages and implement RTCPeerConnection wrapper with Perfect Negotiation pattern.

Purpose: Enable SDP offer/answer exchange and ICE candidate trickle through existing WebSocket infrastructure. Perfect Negotiation ensures robust connection establishment without glare (simultaneous offer collision).

Output: Extended WebSocket message types for call signaling, PeerConnection.ts with Perfect Negotiation, TURN credentials API integration.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-video-calls/03-CONTEXT.md
@.planning/phases/03-voice-video-calls/03-RESEARCH.md
@.planning/phases/03-voice-video-calls/03-01-SUMMARY.md
@.planning/phases/03-voice-video-calls/03-02-SUMMARY.md

# Existing WebSocket implementation
@backend/src/routes/websocket.ts
@frontend/src/lib/websocket/useMessaging.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend WebSocket protocol with call signaling</name>
  <files>backend/src/routes/websocket.ts</files>
  <action>
Extend IncomingMessage type to include call signaling:

```typescript
interface IncomingMessage {
  type: 'message' | 'typing' | 'read' |
        'call-offer' | 'call-answer' | 'call-ice-candidate' |
        'call-accept' | 'call-reject' | 'call-hangup';

  // Existing fields...
  recipientId?: string;
  encryptedContent?: string;

  // Call signaling fields
  callId?: string;
  sdp?: string;                    // SDP offer/answer as string
  candidate?: RTCIceCandidateInit; // ICE candidate
}
```

Add handlers in the message switch:

1. **call-offer**: Forward to recipient with senderId, callId, sdp
2. **call-answer**: Forward to recipient with senderId, callId, sdp
3. **call-ice-candidate**: Forward to recipient with senderId, callId, candidate
4. **call-accept**: Forward to caller indicating callee accepted
5. **call-reject**: Forward to caller indicating callee rejected/declined
6. **call-hangup**: Forward to recipient indicating call ended

For all call messages:
- Verify recipientId exists
- Check if recipient is online (in activeConnections)
- Forward the message with senderId added
- If recipient offline, respond with error (call signaling only works with online users)

No database storage for call signaling - it's transient. Missed calls are detected client-side when call-offer times out without response.
  </action>
  <verify>Start backend, connect two WebSocket clients, send call-offer from one and verify the other receives it with correct fields.</verify>
  <done>WebSocket relays all call signaling messages between connected peers</done>
</task>

<task type="auto">
  <name>Task 2: Add TURN credentials to API client</name>
  <files>frontend/src/lib/api.ts</files>
  <action>
Add turnApi to the existing API client:

```typescript
export const turnApi = {
  async getCredentials(): Promise<{
    username: string;
    password: string;
    ttl: number;
    uris: string[];
  }> {
    const response = await fetchWithAuth('/api/turn/credentials');
    if (!response.ok) {
      throw new Error('Failed to get TURN credentials');
    }
    return response.json();
  },
};
```

Uses existing fetchWithAuth helper that handles JWT token and refresh.
  </action>
  <verify>Import turnApi, call getCredentials, verify it returns valid credentials object with username, password, ttl, uris.</verify>
  <done>turnApi.getCredentials() fetches TURN credentials from backend</done>
</task>

<task type="auto">
  <name>Task 3: Create PeerConnection manager with Perfect Negotiation</name>
  <files>frontend/src/lib/webrtc/PeerConnection.ts</files>
  <action>
Create frontend/src/lib/webrtc/PeerConnection.ts with Perfect Negotiation pattern:

```typescript
interface SignalingChannel {
  send: (msg: { type: string; [key: string]: unknown }) => void;
}

interface PeerConnectionConfig {
  isPolite: boolean;
  onTrack: (stream: MediaStream) => void;
  onIceConnectionStateChange: (state: RTCIceConnectionState) => void;
  signaling: SignalingChannel;
  callId: string;
  remoteUserId: string;
}

class PeerConnectionManager {
  private pc: RTCPeerConnection | null = null;
  private config: PeerConnectionConfig;
  private makingOffer = false;
  private ignoreOffer = false;
  private isSettingRemoteAnswerPending = false;

  constructor(config: PeerConnectionConfig) { ... }

  async initialize(iceServers: RTCIceServer[]): Promise<void> {
    // Create RTCPeerConnection with ice servers
    // Set up event handlers:
    // - onicecandidate: send via signaling
    // - onnegotiationneeded: Perfect Negotiation offer logic
    // - ontrack: call config.onTrack
    // - oniceconnectionstatechange: call config callback
  }

  async addLocalStream(stream: MediaStream): Promise<void> {
    // Add all tracks from stream to peer connection
  }

  async handleRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {
    // Perfect Negotiation logic for handling remote offer/answer
    // Handle offer collision using polite/impolite roles
  }

  async handleIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {
    // Add ICE candidate (ignore if ignoreOffer is true)
  }

  restartIce(): void {
    // Trigger ICE restart
  }

  close(): void {
    // Clean up peer connection
  }

  getStats(): Promise<RTCStatsReport> {
    // Return stats for quality monitoring
  }
}
```

Follow MDN Perfect Negotiation pattern exactly:
- Polite peer backs down on collision
- Impolite peer ignores incoming offer during collision
- Use pc.setLocalDescription() without arguments (implicit offer/answer)

Export both the class and a factory function:
```typescript
export async function createPeerConnection(config: PeerConnectionConfig): Promise<PeerConnectionManager>
```

The factory function fetches TURN credentials before initializing.
  </action>
  <verify>Create a PeerConnectionManager instance, call initialize with mock ice servers, verify onNegotiationNeeded triggers and sends offer via signaling channel.</verify>
  <done>PeerConnectionManager implements Perfect Negotiation with full WebRTC lifecycle management</done>
</task>

</tasks>

<verification>
1. Backend WebSocket handles all call-* message types
2. Call signaling messages are forwarded only to online recipients
3. turnApi.getCredentials() works with authentication
4. PeerConnectionManager can be created and initialized
5. Perfect Negotiation: offer/answer exchange works correctly
6. ICE candidates are trickled via signaling channel
</verification>

<success_criteria>
- All call signaling flows through existing WebSocket
- PeerConnection created with self-hosted TURN credentials
- Perfect Negotiation handles both polite and impolite roles
- ICE candidates properly trickled and added
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-video-calls/03-03-SUMMARY.md`
</output>
