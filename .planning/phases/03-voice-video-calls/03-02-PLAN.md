---
phase: 03-voice-video-calls
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/stores/callStore.ts
  - frontend/src/stores/settingsStore.ts
autonomous: true

must_haves:
  truths:
    - "Call state can be tracked (idle, ringing, connecting, connected, ended)"
    - "User audio preferences are persisted across sessions"
    - "Active call info accessible from any component"
  artifacts:
    - path: "frontend/src/stores/callStore.ts"
      provides: "Call state management"
      exports: ["useCallStore"]
      min_lines: 80
    - path: "frontend/src/stores/settingsStore.ts"
      provides: "Audio settings persistence"
      exports: ["useSettingsStore"]
  key_links:
    - from: "frontend/src/stores/callStore.ts"
      to: "zustand"
      via: "import create"
      pattern: "create<CallState>"
---

<objective>
Create Zustand stores for managing call state (active calls, connection status, quality metrics) and user audio settings (device preferences, processing toggles).

Purpose: Centralized state management for call lifecycle and audio preferences. Call state needs to be accessible from multiple components (call UI, header, notifications). Settings need to persist across sessions.

Output: callStore with call lifecycle state, settingsStore with audio preferences persisted to localStorage.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-video-calls/03-CONTEXT.md
@.planning/phases/03-voice-video-calls/03-RESEARCH.md

# Existing stores for pattern reference
@frontend/src/stores/auth.ts
@frontend/src/stores/messageStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create call state store</name>
  <files>frontend/src/stores/callStore.ts</files>
  <action>
Create callStore.ts with Zustand for managing call lifecycle:

```typescript
type CallStatus = 'idle' | 'outgoing' | 'incoming' | 'connecting' | 'connected' | 'reconnecting' | 'ended';

interface CallState {
  // Current call
  status: CallStatus;
  callId: string | null;
  remoteUserId: string | null;
  remoteUsername: string | null;
  isPolite: boolean;           // Perfect Negotiation role
  isMuted: boolean;

  // Quality metrics
  quality: 1 | 2 | 3 | 4;      // Signal bars
  latency: number | null;       // RTT in ms

  // Timing
  startTime: Date | null;

  // UI state
  isMinimized: boolean;         // Floating window vs full page

  // Actions
  startOutgoingCall: (callId: string, remoteUserId: string, remoteUsername: string, isPolite: boolean) => void;
  receiveIncomingCall: (callId: string, remoteUserId: string, remoteUsername: string, isPolite: boolean) => void;
  acceptCall: () => void;
  rejectCall: () => void;
  setConnecting: () => void;
  setConnected: () => void;
  setReconnecting: () => void;
  endCall: () => void;
  toggleMute: () => boolean;    // Returns new mute state
  toggleMinimized: () => void;
  updateQuality: (quality: 1 | 2 | 3 | 4, latency: number | null) => void;
  reset: () => void;
}
```

Initial state: status='idle', all null values, quality=4, isMuted=false, isMinimized=false.

The isPolite boolean determines Perfect Negotiation role - derived from lexicographic comparison of user IDs (same pattern as key exchange in Phase 2).
  </action>
  <verify>Import useCallStore, call startOutgoingCall, verify state updates correctly. Check that endCall resets to initial state.</verify>
  <done>callStore provides complete call lifecycle state management with all actions</done>
</task>

<task type="auto">
  <name>Task 2: Create settings store with audio preferences</name>
  <files>frontend/src/stores/settingsStore.ts</files>
  <action>
Create settingsStore.ts with Zustand and localStorage persistence for audio settings:

```typescript
interface SettingsState {
  // Audio devices
  selectedMicId: string | null;        // null = system default
  selectedSpeakerId: string | null;    // null = system default

  // Audio processing
  echoCancellation: boolean;
  noiseSuppression: boolean;
  autoGainControl: boolean;

  // Call preferences
  ringtoneEnabled: boolean;
  ringTimeout: number;                  // seconds, default 30

  // Actions
  setMicId: (deviceId: string | null) => void;
  setSpeakerId: (deviceId: string | null) => void;
  setEchoCancellation: (enabled: boolean) => void;
  setNoiseSuppression: (enabled: boolean) => void;
  setAutoGainControl: (enabled: boolean) => void;
  setRingtoneEnabled: (enabled: boolean) => void;
  setRingTimeout: (seconds: number) => void;
}
```

Use Zustand persist middleware with localStorage. Key: 'audio-settings'.

Default values:
- All processing: true (echoCancellation, noiseSuppression, autoGainControl)
- ringtoneEnabled: true
- ringTimeout: 30
- Device IDs: null (use system defaults)
  </action>
  <verify>Set a device ID, refresh page, verify the value persists. Toggle echoCancellation, refresh, verify it persists.</verify>
  <done>settingsStore persists audio preferences to localStorage with sensible defaults</done>
</task>

</tasks>

<verification>
1. callStore state transitions work: idle -> outgoing -> connecting -> connected -> ended
2. callStore state transitions work: idle -> incoming -> (accept) -> connecting -> connected
3. toggleMute returns new state and updates store
4. settingsStore values persist across page refresh
5. Both stores can be imported without circular dependency issues
</verification>

<success_criteria>
- Call lifecycle fully managed through store actions
- Settings persist across browser sessions
- Quality metrics updateable for UI display
- Both stores export typed hooks (useCallStore, useSettingsStore)
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-video-calls/03-02-SUMMARY.md`
</output>
