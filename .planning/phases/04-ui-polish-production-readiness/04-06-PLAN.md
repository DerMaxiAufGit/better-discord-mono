---
phase: 04-ui-polish-production-readiness
plan: 06
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - frontend/src/components/auth/SessionExpiredModal.tsx
  - frontend/src/stores/auth.ts
  - frontend/src/lib/api.ts
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Session expiry shows login modal instead of redirect"
    - "App state is preserved when re-authenticating"
    - "Silent token refresh happens automatically"
    - "Modal only appears when refresh token fails"
  artifacts:
    - path: "frontend/src/components/auth/SessionExpiredModal.tsx"
      provides: "In-place login modal for session recovery"
      exports: ["SessionExpiredModal"]
    - path: "frontend/src/stores/auth.ts"
      provides: "Auth store with session expired state"
      contains: "sessionExpired"
  key_links:
    - from: "frontend/src/lib/api.ts"
      to: "frontend/src/stores/auth.ts"
      via: "set sessionExpired on refresh failure"
      pattern: "setSessionExpired|sessionExpired"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/auth/SessionExpiredModal.tsx"
      via: "conditional modal rendering"
      pattern: "SessionExpiredModal"
---

<objective>
Implement graceful auth recovery with in-place login modal instead of redirect.

Purpose: Preserve user's app state (open conversation, etc.) when session expires.
Output: SessionExpiredModal for re-authentication and improved token refresh flow.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-ui-polish-production-readiness/04-CONTEXT.md
@frontend/src/stores/auth.ts
@frontend/src/lib/api.ts
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sessionExpired state to auth store</name>
  <files>frontend/src/stores/auth.ts</files>
  <action>
    Update auth store to track session expiry state.

    Add to store state:
    - sessionExpired: boolean (default false)
    - setSessionExpired: (expired: boolean) => void

    The flow:
    1. Token refresh fails in api.ts
    2. api.ts calls useAuthStore.getState().setSessionExpired(true)
    3. App.tsx renders SessionExpiredModal
    4. User logs in via modal
    5. Modal calls setSessionExpired(false) and updates tokens

    Add to auth store:
    ```typescript
    interface AuthState {
      // ... existing
      sessionExpired: boolean
      setSessionExpired: (expired: boolean) => void
    }

    export const useAuthStore = create<AuthState>((set) => ({
      // ... existing
      sessionExpired: false,
      setSessionExpired: (expired) => set({ sessionExpired: expired }),
    }))
    ```

    Also add a relogin action that mirrors the existing login logic:
    1. Calls the same login API endpoint
    2. Updates localStorage with new accessToken
    3. Updates user state
    4. Sets sessionExpired to false to close modal

    ```typescript
    relogin: async (email: string, password: string) => {
      // Use same API endpoint as regular login
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: 'include', // For refresh token cookie
      })

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: 'Login failed' }))
        throw new Error(error.error || error.message || 'Login failed')
      }

      const data = await response.json()
      localStorage.setItem('accessToken', data.accessToken)
      set({
        user: data.user,
        isAuthenticated: true,
        sessionExpired: false, // This closes the modal
      })
    }
    ```

    The key difference from regular login is that relogin sets sessionExpired to false,
    which causes the modal to unmount and the user to continue where they left off.
  </action>
  <verify>TypeScript compiles: cd frontend && npx tsc --noEmit</verify>
  <done>Auth store has sessionExpired state and relogin action</done>
</task>

<task type="auto">
  <name>Task 2: Create SessionExpiredModal component</name>
  <files>frontend/src/components/auth/SessionExpiredModal.tsx</files>
  <action>
    Create modal for in-place re-authentication.

    Design from CONTEXT.md:
    - Modal with login form
    - Preserve app state (don't redirect)
    - Show when refresh token fails

    Implementation:
    ```tsx
    import { useState } from 'react'
    import { Button } from '@/components/ui/button'
    import { Input } from '@/components/ui/input'
    import { Label } from '@/components/ui/label'
    import { useAuthStore } from '@/stores/auth'
    import { Lock } from 'lucide-react'

    export function SessionExpiredModal() {
      const [email, setEmail] = useState('')
      const [password, setPassword] = useState('')
      const [error, setError] = useState('')
      const [isLoading, setIsLoading] = useState(false)
      const relogin = useAuthStore((s) => s.relogin)
      const user = useAuthStore((s) => s.user)

      // Pre-fill email if we have user info
      useState(() => {
        if (user?.email) setEmail(user.email)
      })

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()
        setError('')
        setIsLoading(true)

        try {
          await relogin(email, password)
        } catch (err) {
          setError((err as Error).message || 'Login failed')
        } finally {
          setIsLoading(false)
        }
      }

      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
          <div className="w-full max-w-md bg-card rounded-lg p-6 shadow-lg mx-4">
            <div className="flex items-center gap-2 mb-4">
              <Lock className="h-5 w-5 text-muted-foreground" />
              <h2 className="text-lg font-semibold">Session Expired</h2>
            </div>

            <p className="text-sm text-muted-foreground mb-4">
              Your session has expired. Please log in again to continue.
            </p>

            <form onSubmit={handleSubmit} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                />
              </div>

              {error && (
                <p className="text-sm text-red-500">{error}</p>
              )}

              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? 'Logging in...' : 'Log In'}
              </Button>
            </form>
          </div>
        </div>
      )
    }
    ```
  </action>
  <verify>TypeScript compiles: cd frontend && npx tsc --noEmit</verify>
  <done>SessionExpiredModal provides in-place re-authentication</done>
</task>

<task type="auto">
  <name>Task 3: Integrate session expiry into api.ts and App.tsx</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/App.tsx
  </files>
  <action>
    1. Update api.ts to trigger sessionExpired on refresh failure:

    ```typescript
    import { useAuthStore } from '@/stores/auth'

    // In the 401 handling section, after refresh fails:
    if (error.response?.status === 401) {
      const newToken = await refreshAccessToken()

      if (!newToken) {
        // Refresh failed - show session expired modal
        useAuthStore.getState().setSessionExpired(true)
        throw new Error('Session expired')
      }
      // ... retry with new token
    }
    ```

    2. Update App.tsx to render SessionExpiredModal:

    ```tsx
    import { SessionExpiredModal } from '@/components/auth/SessionExpiredModal'
    import { useAuthStore } from '@/stores/auth'

    function App() {
      const sessionExpired = useAuthStore((s) => s.sessionExpired)

      return (
        <ThemeProvider ...>
          <Toaster ... />

          {/* Session expired modal - renders above everything */}
          {sessionExpired && <SessionExpiredModal />}

          <BrowserRouter>
            ...
          </BrowserRouter>
        </ThemeProvider>
      )
    }
    ```

    The modal renders above the entire app, preserving all state underneath.
    After successful re-login, sessionExpired becomes false and modal disappears.
  </action>
  <verify>cd frontend && npm run build (compiles successfully)</verify>
  <done>Session expiry triggers modal instead of redirect, preserving app state</done>
</task>

</tasks>

<verification>
1. cd frontend && npx tsc --noEmit
2. grep "sessionExpired" frontend/src/stores/auth.ts
3. grep "SessionExpiredModal" frontend/src/App.tsx
4. grep "setSessionExpired" frontend/src/lib/api.ts
</verification>

<success_criteria>
- Auth store tracks sessionExpired state
- SessionExpiredModal renders when sessionExpired is true
- Successful re-login clears sessionExpired and restores session
- App state (open conversations, etc.) preserved during re-auth
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-polish-production-readiness/04-06-SUMMARY.md`
</output>
