---
phase: 04-ui-polish-production-readiness
plan: 05
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - frontend/src/components/error/ConnectionBanner.tsx
  - frontend/src/components/layout/AppShell.tsx
  - frontend/src/lib/websocket/useMessaging.ts
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket disconnect shows subtle connection banner"
    - "API errors show toast notifications"
    - "Failed message sends show retry option"
    - "Connection banner auto-hides when reconnected"
  artifacts:
    - path: "frontend/src/components/error/ConnectionBanner.tsx"
      provides: "Persistent connection state banner"
      exports: ["ConnectionBanner"]
    - path: "frontend/src/lib/api.ts"
      provides: "API client with toast error handling"
      contains: "showApiError"
  key_links:
    - from: "frontend/src/lib/websocket/useMessaging.ts"
      to: "frontend/src/lib/toast.ts"
      via: "toast on connection state change"
      pattern: "toast|showError"
    - from: "frontend/src/components/layout/AppShell.tsx"
      to: "frontend/src/components/error/ConnectionBanner.tsx"
      via: "conditional banner rendering"
      pattern: "ConnectionBanner"
---

<objective>
Add connection state feedback and integrate toast notifications for errors.

Purpose: Provide clear feedback when connection issues occur and graceful error handling.
Output: Connection banner for WebSocket state, toast integration for API errors, retry handling.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-ui-polish-production-readiness/04-CONTEXT.md
@frontend/src/lib/websocket/useMessaging.ts
@frontend/src/lib/api.ts
@frontend/src/components/layout/AppShell.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConnectionBanner component</name>
  <files>frontend/src/components/error/ConnectionBanner.tsx</files>
  <action>
    Create a subtle connection state banner at frontend/src/components/error/ConnectionBanner.tsx.

    Design from CONTEXT.md:
    - Subtle indicator showing connection state
    - Banner style (not modal, not toast)
    - Let user continue viewing cached content

    Implementation:
    ```tsx
    import { WifiOff, Loader2 } from 'lucide-react'
    import { cn } from '@/lib/utils'

    interface ConnectionBannerProps {
      status: 'connected' | 'connecting' | 'disconnected'
      className?: string
    }

    export function ConnectionBanner({ status, className }: ConnectionBannerProps) {
      if (status === 'connected') return null

      return (
        <div
          className={cn(
            'flex items-center justify-center gap-2 py-2 px-4 text-sm',
            status === 'connecting' && 'bg-yellow-500/10 text-yellow-600 dark:text-yellow-400',
            status === 'disconnected' && 'bg-red-500/10 text-red-600 dark:text-red-400',
            className
          )}
        >
          {status === 'connecting' ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Reconnecting...</span>
            </>
          ) : (
            <>
              <WifiOff className="h-4 w-4" />
              <span>Connection lost. Trying to reconnect...</span>
            </>
          )}
        </div>
      )
    }
    ```

    Keep it simple and non-intrusive.
  </action>
  <verify>TypeScript compiles: cd frontend && npx tsc --noEmit</verify>
  <done>ConnectionBanner component shows appropriate state feedback</done>
</task>

<task type="auto">
  <name>Task 2: Integrate ConnectionBanner into AppShell</name>
  <files>frontend/src/components/layout/AppShell.tsx</files>
  <action>
    Add ConnectionBanner to AppShell, driven by WebSocket connection state.

    Changes:
    1. Import ConnectionBanner from '@/components/error/ConnectionBanner'
    2. Get connection status from a suitable source (useMessaging or a shared store)
    3. Render ConnectionBanner at top of main content area

    Since useMessaging returns isConnected, we need to expose connection state.
    Option: Create a simple connectionStore or pass through context.

    For simplicity, use the existing pattern - check if WebSocket is connected.
    Add to messageStore or create connectionStore:

    ```tsx
    // In AppShell, get connection status
    // If useMessaging is only used in MessagesPage, we need shared state
    // Solution: Create a minimal connection status in a shared store

    // For now, use a simpler approach:
    // Add connection status to messageStore (it already has WebSocket logic awareness)
    ```

    Actually, the cleanest approach:
    1. Add `connectionStatus` to messageStore (set by useMessaging)
    2. Read from messageStore in AppShell

    In AppShell:
    ```tsx
    import { ConnectionBanner } from '@/components/error/ConnectionBanner'
    import { useMessageStore } from '@/stores/messageStore'

    export function AppShell({ children }: AppShellProps) {
      const connectionStatus = useMessageStore((s) => s.connectionStatus)
      // ...

      return (
        <>
          {/* Connection banner at very top */}
          <ConnectionBanner status={connectionStatus} />

          {/* Existing call banners */}
          {showIncomingCall && <IncomingCallBanner ... />}
          ...
        </>
      )
    }
    ```

    Also update messageStore to track connectionStatus: 'connected' | 'connecting' | 'disconnected'
    (default to 'connecting' until first connection)
  </action>
  <verify>TypeScript compiles: cd frontend && npx tsc --noEmit</verify>
  <done>ConnectionBanner shows at top of AppShell when disconnected</done>
</task>

<task type="auto">
  <name>Task 3: Add toast notifications for API and WebSocket errors</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/lib/websocket/useMessaging.ts
  </files>
  <action>
    Integrate toast notifications into error handling.

    1. In api.ts, add toast for non-401 errors:
    ```typescript
    import { showApiError } from '@/lib/toast'

    // In apiRequest function, after exhausting retry:
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Request failed' }))
      const message = error.error || error.message || `HTTP ${response.status}`

      // Don't toast 401s (handled by auth flow)
      if (response.status !== 401) {
        showApiError(message)
      }

      throw new Error(message)
    }
    ```

    2. In useMessaging.ts, add toast for connection events:
    ```typescript
    import { toast } from '@/lib/toast'

    // On reconnection success (after being disconnected):
    if (wasDisconnected && nowConnected) {
      toast.success('Connected')
    }

    // On disconnect after 3 failed attempts:
    toast.error('Connection lost. Will keep trying...')
    ```

    Keep toasts minimal - don't toast every state change.
    Only toast on:
    - Successful reconnection after disconnect
    - Giving up on reconnection (if applicable)
    - API errors (except 401)
  </action>
  <verify>cd frontend && npm run build (compiles successfully)</verify>
  <done>Toast notifications appear for API errors and connection recovery</done>
</task>

</tasks>

<verification>
1. cd frontend && npx tsc --noEmit
2. grep "ConnectionBanner" frontend/src/components/layout/AppShell.tsx
3. grep "showApiError\|toast" frontend/src/lib/api.ts
4. grep "toast" frontend/src/lib/websocket/useMessaging.ts
</verification>

<success_criteria>
- ConnectionBanner shows when WebSocket disconnected
- ConnectionBanner auto-hides when reconnected
- API errors show toast notifications
- Toast not shown for 401 errors (handled separately)
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-polish-production-readiness/04-05-SUMMARY.md`
</output>
