---
phase: 06-social-features
plan: 08
type: execute
wave: 3
depends_on: ["06-01"]
files_modified:
  - frontend/src/lib/search/messageIndex.ts
  - frontend/src/lib/search/searchEngine.ts
  - frontend/src/stores/searchStore.ts
  - frontend/src/components/search/MessageSearchBar.tsx
  - frontend/src/components/search/SearchResults.tsx
autonomous: true

must_haves:
  truths:
    - "User can search through decrypted message history"
    - "Search results grouped by conversation"
    - "Messages cached in IndexedDB for fast search"
    - "Search works offline for cached messages"
  artifacts:
    - path: "frontend/src/lib/search/messageIndex.ts"
      provides: "IndexedDB wrapper for message caching"
      exports: ["messageIndex"]
    - path: "frontend/src/stores/searchStore.ts"
      provides: "Search state and results"
      exports: ["useSearchStore"]
    - path: "frontend/src/components/search/SearchResults.tsx"
      provides: "Search results display"
      exports: ["SearchResults"]
  key_links:
    - from: "frontend/src/stores/searchStore.ts"
      to: "frontend/src/lib/search/searchEngine.ts"
      via: "searchEngine.search() calls"
    - from: "frontend/src/lib/search/messageIndex.ts"
      to: "IndexedDB"
      via: "Native browser API"
---

<objective>
Create client-side message search using IndexedDB caching for encrypted messages.

Purpose: Enable users to search through E2E encrypted message history (server cannot search encrypted content)
Output: IndexedDB message cache, search engine, search UI components
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@frontend/src/stores/messageStore.ts
@frontend/src/lib/crypto/messageEncryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexedDB message index</name>
  <files>frontend/src/lib/search/messageIndex.ts</files>
  <action>
Create directory and file `frontend/src/lib/search/messageIndex.ts`:

```typescript
interface IndexedMessage {
  id: number;
  conversationId: string;  // recipientId for DMs, groupId for groups
  conversationType: 'dm' | 'group';
  senderId: string;
  senderName: string;
  plaintext: string;
  timestamp: number;  // Unix timestamp for indexing
  searchTokens: string[];  // Pre-tokenized lowercase words
}

const DB_NAME = 'MessageSearchCache';
const DB_VERSION = 1;
const STORE_NAME = 'messages';
const MAX_CACHED_MESSAGES = 10000;  // LRU limit

class MessageIndex {
  private db: IDBDatabase | null = null;
  private initPromise: Promise<void> | null = null;

  /**
   * Initialize IndexedDB connection
   */
  async initialize(): Promise<void> {
    if (this.db) return;
    if (this.initPromise) return this.initPromise;

    this.initPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // Create object store with indexes
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          store.createIndex('conversationId', 'conversationId', { unique: false });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('senderId', 'senderId', { unique: false });
        }
      };

      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onerror = () => {
        reject(request.error);
      };
    });

    return this.initPromise;
  }

  /**
   * Index a decrypted message for search
   */
  async indexMessage(message: {
    id: number;
    conversationId: string;
    conversationType: 'dm' | 'group';
    senderId: string;
    senderName: string;
    plaintext: string;
    timestamp: Date;
  }): Promise<void> {
    await this.initialize();
    if (!this.db) throw new Error('Database not initialized');

    // Tokenize message for search
    const searchTokens = this.tokenize(message.plaintext);

    const indexedMessage: IndexedMessage = {
      id: message.id,
      conversationId: message.conversationId,
      conversationType: message.conversationType,
      senderId: message.senderId,
      senderName: message.senderName,
      plaintext: message.plaintext,
      timestamp: message.timestamp.getTime(),
      searchTokens,
    };

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);

      const request = store.put(indexedMessage);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Index multiple messages (batch)
   */
  async indexMessages(messages: Array<{
    id: number;
    conversationId: string;
    conversationType: 'dm' | 'group';
    senderId: string;
    senderName: string;
    plaintext: string;
    timestamp: Date;
  }>): Promise<void> {
    await this.initialize();
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);

      for (const message of messages) {
        const searchTokens = this.tokenize(message.plaintext);
        store.put({
          id: message.id,
          conversationId: message.conversationId,
          conversationType: message.conversationType,
          senderId: message.senderId,
          senderName: message.senderName,
          plaintext: message.plaintext,
          timestamp: message.timestamp.getTime(),
          searchTokens,
        });
      }

      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  /**
   * Search messages by query
   */
  async search(
    query: string,
    options?: {
      conversationId?: string;
      limit?: number;
    }
  ): Promise<IndexedMessage[]> {
    await this.initialize();
    if (!this.db) return [];

    const queryTokens = this.tokenize(query);
    if (queryTokens.length === 0) return [];

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);

      // Get all messages (or filtered by conversation)
      const request = options?.conversationId
        ? store.index('conversationId').getAll(options.conversationId)
        : store.getAll();

      request.onsuccess = () => {
        const allMessages: IndexedMessage[] = request.result;

        // Filter by query tokens
        const matches = allMessages.filter((msg) =>
          queryTokens.every((qt) =>
            msg.searchTokens.some((st) => st.includes(qt))
          )
        );

        // Sort by timestamp (newest first)
        matches.sort((a, b) => b.timestamp - a.timestamp);

        // Apply limit
        const limited = options?.limit ? matches.slice(0, options.limit) : matches;
        resolve(limited);
      };

      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Delete a message from index
   */
  async deleteMessage(messageId: number): Promise<void> {
    await this.initialize();
    if (!this.db) return;

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);

      const request = store.delete(messageId);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Clear all cached messages
   */
  async clear(): Promise<void> {
    await this.initialize();
    if (!this.db) return;

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);

      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Clean up old messages (LRU eviction)
   */
  async cleanup(): Promise<number> {
    await this.initialize();
    if (!this.db) return 0;

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const index = store.index('timestamp');

      const countRequest = store.count();
      countRequest.onsuccess = () => {
        const count = countRequest.result;
        if (count <= MAX_CACHED_MESSAGES) {
          resolve(0);
          return;
        }

        // Get oldest messages to delete
        const toDelete = count - MAX_CACHED_MESSAGES;
        let deleted = 0;

        const cursorRequest = index.openCursor();
        cursorRequest.onsuccess = (event) => {
          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
          if (cursor && deleted < toDelete) {
            cursor.delete();
            deleted++;
            cursor.continue();
          } else {
            resolve(deleted);
          }
        };
        cursorRequest.onerror = () => reject(cursorRequest.error);
      };
    });
  }

  /**
   * Tokenize text for search indexing
   */
  private tokenize(text: string): string[] {
    return text
      .toLowerCase()
      .split(/\s+/)
      .filter((token) => token.length >= 2)
      .slice(0, 100);  // Limit tokens per message
  }
}

export const messageIndex = new MessageIndex();
export type { IndexedMessage };
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>IndexedDB message index created with search, cleanup, and batch indexing</done>
</task>

<task type="auto">
  <name>Task 2: Create search store</name>
  <files>frontend/src/stores/searchStore.ts</files>
  <action>
Create `frontend/src/stores/searchStore.ts`:

```typescript
import { create } from 'zustand';
import { messageIndex, type IndexedMessage } from '@/lib/search/messageIndex';

interface SearchResult {
  message: IndexedMessage;
  highlight: string;  // Text with search term highlighted
}

interface GroupedResults {
  conversationId: string;
  conversationType: 'dm' | 'group';
  conversationName: string;
  results: SearchResult[];
}

interface SearchState {
  // Search state
  query: string;
  isSearching: boolean;
  results: SearchResult[];
  groupedResults: GroupedResults[];

  // Filter
  filterConversationId: string | null;

  // Actions
  setQuery: (query: string) => void;
  search: () => Promise<void>;
  clearSearch: () => void;
  setFilterConversation: (conversationId: string | null) => void;

  // Indexing
  indexMessage: (message: {
    id: number;
    conversationId: string;
    conversationType: 'dm' | 'group';
    senderId: string;
    senderName: string;
    plaintext: string;
    timestamp: Date;
  }) => Promise<void>;
  indexMessages: (messages: Array<{
    id: number;
    conversationId: string;
    conversationType: 'dm' | 'group';
    senderId: string;
    senderName: string;
    plaintext: string;
    timestamp: Date;
  }>) => Promise<void>;
  deleteFromIndex: (messageId: number) => Promise<void>;
  clearIndex: () => Promise<void>;
}

export const useSearchStore = create<SearchState>((set, get) => ({
  query: '',
  isSearching: false,
  results: [],
  groupedResults: [],
  filterConversationId: null,

  setQuery: (query: string) => {
    set({ query });
  },

  search: async () => {
    const { query, filterConversationId } = get();

    if (query.trim().length < 2) {
      set({ results: [], groupedResults: [] });
      return;
    }

    set({ isSearching: true });

    try {
      const indexedMessages = await messageIndex.search(query, {
        conversationId: filterConversationId || undefined,
        limit: 100,
      });

      // Create search results with highlighting
      const results: SearchResult[] = indexedMessages.map((msg) => ({
        message: msg,
        highlight: highlightQuery(msg.plaintext, query),
      }));

      // Group by conversation
      const grouped = groupByConversation(results);

      set({ results, groupedResults: grouped, isSearching: false });
    } catch (error) {
      console.error('Search error:', error);
      set({ results: [], groupedResults: [], isSearching: false });
    }
  },

  clearSearch: () => {
    set({ query: '', results: [], groupedResults: [] });
  },

  setFilterConversation: (conversationId: string | null) => {
    set({ filterConversationId: conversationId });
  },

  indexMessage: async (message) => {
    await messageIndex.indexMessage(message);
  },

  indexMessages: async (messages) => {
    await messageIndex.indexMessages(messages);
  },

  deleteFromIndex: async (messageId: number) => {
    await messageIndex.deleteMessage(messageId);
  },

  clearIndex: async () => {
    await messageIndex.clear();
  },
}));

/**
 * Highlight search query in text
 */
function highlightQuery(text: string, query: string): string {
  const tokens = query.toLowerCase().split(/\s+/).filter((t) => t.length >= 2);
  if (tokens.length === 0) return text;

  let highlighted = text;
  for (const token of tokens) {
    const regex = new RegExp(`(${escapeRegex(token)})`, 'gi');
    highlighted = highlighted.replace(regex, '**$1**');
  }

  return highlighted;
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Group search results by conversation
 */
function groupByConversation(results: SearchResult[]): GroupedResults[] {
  const groups = new Map<string, GroupedResults>();

  for (const result of results) {
    const { conversationId, conversationType } = result.message;
    const key = conversationId;

    if (!groups.has(key)) {
      groups.set(key, {
        conversationId,
        conversationType,
        conversationName: conversationId,  // Will be resolved by UI
        results: [],
      });
    }

    groups.get(key)!.results.push(result);
  }

  return Array.from(groups.values());
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Search store created with query, results, and indexing actions</done>
</task>

<task type="auto">
  <name>Task 3: Create search UI components</name>
  <files>frontend/src/components/search/MessageSearchBar.tsx, frontend/src/components/search/SearchResults.tsx, frontend/src/components/search/index.ts</files>
  <action>
1. Create directory `frontend/src/components/search/`

2. Create `frontend/src/components/search/MessageSearchBar.tsx`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { useSearchStore } from '@/stores/searchStore';
import { Search, X, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';

interface MessageSearchBarProps {
  className?: string;
  placeholder?: string;
  autoFocus?: boolean;
}

export function MessageSearchBar({
  className,
  placeholder = 'Search messages...',
  autoFocus = false,
}: MessageSearchBarProps) {
  const [inputValue, setInputValue] = useState('');
  const { query, isSearching, setQuery, search, clearSearch } = useSearchStore();

  // Debounce search
  useEffect(() => {
    const timer = setTimeout(() => {
      if (inputValue !== query) {
        setQuery(inputValue);
        if (inputValue.trim().length >= 2) {
          search();
        }
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [inputValue, query, setQuery, search]);

  const handleClear = useCallback(() => {
    setInputValue('');
    clearSearch();
  }, [clearSearch]);

  return (
    <div className={cn('relative', className)}>
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        placeholder={placeholder}
        className="pl-9 pr-9"
        autoFocus={autoFocus}
      />
      {isSearching ? (
        <Loader2 className="absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 animate-spin text-muted-foreground" />
      ) : inputValue && (
        <Button
          variant="ghost"
          size="icon"
          className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7"
          onClick={handleClear}
        >
          <X className="h-3 w-3" />
        </Button>
      )}
    </div>
  );
}
```

3. Create `frontend/src/components/search/SearchResults.tsx`:

```typescript
import { useSearchStore } from '@/stores/searchStore';
import { ScrollArea } from '@/components/ui/scroll-area';
import { MessageSquare, Users } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SearchResultsProps {
  className?: string;
  onResultClick?: (conversationId: string, messageId: number) => void;
}

export function SearchResults({ className, onResultClick }: SearchResultsProps) {
  const { query, groupedResults, isSearching } = useSearchStore();

  if (!query || query.length < 2) {
    return null;
  }

  if (isSearching) {
    return (
      <div className={cn('p-4 text-center text-muted-foreground', className)}>
        Searching...
      </div>
    );
  }

  if (groupedResults.length === 0) {
    return (
      <div className={cn('p-4 text-center text-muted-foreground', className)}>
        No messages found for "{query}"
      </div>
    );
  }

  return (
    <ScrollArea className={cn('max-h-[400px]', className)}>
      <div className="space-y-4 p-2">
        {groupedResults.map((group) => (
          <div key={group.conversationId}>
            {/* Conversation header */}
            <div className="flex items-center gap-2 px-2 py-1 text-sm font-medium text-muted-foreground">
              {group.conversationType === 'group' ? (
                <Users className="h-4 w-4" />
              ) : (
                <MessageSquare className="h-4 w-4" />
              )}
              <span>{group.conversationName}</span>
              <span className="text-xs">({group.results.length})</span>
            </div>

            {/* Results */}
            <div className="space-y-1">
              {group.results.slice(0, 5).map((result) => (
                <button
                  key={result.message.id}
                  className="w-full text-left px-3 py-2 rounded-md hover:bg-muted transition-colors"
                  onClick={() => onResultClick?.(group.conversationId, result.message.id)}
                >
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">
                      {result.message.senderName}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {formatDate(result.message.timestamp)}
                    </span>
                  </div>
                  <p
                    className="text-sm text-muted-foreground truncate mt-0.5"
                    dangerouslySetInnerHTML={{
                      __html: result.highlight
                        .replace(/\*\*(.*?)\*\*/g, '<mark class="bg-yellow-200 dark:bg-yellow-900 px-0.5 rounded">$1</mark>')
                        .slice(0, 150),
                    }}
                  />
                </button>
              ))}
              {group.results.length > 5 && (
                <div className="text-xs text-muted-foreground px-3 py-1">
                  +{group.results.length - 5} more results
                </div>
              )}
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

function formatDate(timestamp: number): string {
  const date = new Date(timestamp);
  const now = new Date();
  const diff = now.getTime() - date.getTime();

  if (diff < 86400000) {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  if (diff < 604800000) {
    return date.toLocaleDateString([], { weekday: 'short' });
  }
  return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
}
```

4. Create `frontend/src/components/search/index.ts`:

```typescript
export { MessageSearchBar } from './MessageSearchBar';
export { SearchResults } from './SearchResults';
```
  </action>
  <verify>Run `npm run build` to verify all components compile</verify>
  <done>Search bar and results components created with highlighting and grouping</done>
</task>

</tasks>

<verification>
1. Messages can be indexed in IndexedDB
2. Search returns results matching query tokens
3. Results grouped by conversation
4. Search terms highlighted in results
5. Debounced search (300ms delay)
6. LRU cleanup keeps cache under 10K messages
</verification>

<success_criteria>
- IndexedDB stores decrypted messages
- Search finds partial word matches
- Results display with conversation grouping
- Highlighting marks search terms
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-08-SUMMARY.md`
</output>
