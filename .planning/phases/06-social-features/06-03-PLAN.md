---
phase: 06-social-features
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/src/services/presenceService.ts
  - backend/src/routes/presence.ts
  - backend/src/routes/websocket.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "User can set their status (online/away/dnd/invisible)"
    - "User presence is tracked via WebSocket connection"
    - "Status broadcasts to friends respect visibility rules"
    - "Last-seen timestamps update on disconnect"
  artifacts:
    - path: "backend/src/services/presenceService.ts"
      provides: "Presence tracking, status updates, visibility logic"
      exports: ["presenceService"]
    - path: "backend/src/routes/presence.ts"
      provides: "REST routes for presence status"
      exports: ["default"]
  key_links:
    - from: "backend/src/routes/websocket.ts"
      to: "backend/src/services/presenceService.ts"
      via: "Track connect/disconnect events"
    - from: "backend/src/services/presenceService.ts"
      to: "backend/src/routes/websocket.ts"
      via: "broadcastToUsers for status updates"
---

<objective>
Create backend presence service with Redis caching and selective visibility for invisible mode.

Purpose: Enable real-time online/offline status tracking with privacy controls
Output: Presence service with WebSocket integration, status broadcasting, visibility list support
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-01-SUMMARY.md
@backend/src/routes/websocket.ts
@backend/src/services/friendService.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create presence service with Redis tracking</name>
  <files>backend/src/services/presenceService.ts</files>
  <action>
Create `backend/src/services/presenceService.ts`:

```typescript
import { query } from '../db/index.js';
import { broadcastToUsers } from '../routes/websocket.js';
import type { PresenceStatus, UserPresence } from '../db/schema.js';

const PRESENCE_TTL = 300;  // 5 minutes - require heartbeat to maintain

// In-memory presence cache (Redis would be better for multi-instance, but in-memory works for single instance)
// Structure: Map<userId, { status, lastSeen, visibilityList }>
const presenceCache = new Map<string, {
  status: PresenceStatus;
  lastSeen: Date;
  visibilityList: string[];
}>();

class PresenceService {
  /**
   * User connected via WebSocket - mark as online
   * Loads persisted status from database or defaults to 'online'
   */
  async userConnected(userId: string): Promise<void> {
    // Load persisted status from database (or create default)
    const result = await query(
      `INSERT INTO user_presence (user_id, status, last_seen, updated_at)
       VALUES ($1, 'online', NOW(), NOW())
       ON CONFLICT (user_id) DO UPDATE
       SET last_seen = NOW(), updated_at = NOW()
       RETURNING *`,
      [userId]
    );

    const row = result.rows[0];
    presenceCache.set(userId, {
      status: row.status,
      lastSeen: new Date(),
      visibilityList: row.visibility_list || [],
    });

    // Broadcast to friends
    await this.broadcastStatus(userId);
  }

  /**
   * User disconnected - update last_seen and broadcast offline
   */
  async userDisconnected(userId: string): Promise<void> {
    const now = new Date();

    // Update database
    await query(
      `UPDATE user_presence SET last_seen = $1, updated_at = $1 WHERE user_id = $2`,
      [now, userId]
    );

    // Update cache (keep for last-seen queries)
    const cached = presenceCache.get(userId);
    if (cached) {
      cached.lastSeen = now;
    }

    // Remove from active connections (done by websocket handler)
    presenceCache.delete(userId);

    // Broadcast offline to friends
    await this.broadcastStatus(userId);
  }

  /**
   * Update user's status (online/away/dnd/invisible)
   */
  async updateStatus(
    userId: string,
    status: PresenceStatus,
    visibilityList?: string[]
  ): Promise<void> {
    const now = new Date();

    // Update database
    const updates = visibilityList !== undefined
      ? await query(
          `UPDATE user_presence
           SET status = $1, visibility_list = $2, updated_at = NOW()
           WHERE user_id = $3
           RETURNING *`,
          [status, visibilityList, userId]
        )
      : await query(
          `UPDATE user_presence SET status = $1, updated_at = NOW() WHERE user_id = $2 RETURNING *`,
          [status, userId]
        );

    // Update cache
    const row = updates.rows[0];
    if (row) {
      presenceCache.set(userId, {
        status: row.status,
        lastSeen: row.last_seen,
        visibilityList: row.visibility_list || [],
      });
    }

    // Broadcast to friends
    await this.broadcastStatus(userId);
  }

  /**
   * Get user's visible status (respects selective visibility for invisible mode)
   */
  async getVisibleStatus(
    targetUserId: string,
    viewerUserId: string
  ): Promise<{ status: string; lastSeen: Date | null } | null> {
    // Check cache first
    let presence = presenceCache.get(targetUserId);

    // If not in cache, check database for last-seen
    if (!presence) {
      const result = await query(
        `SELECT * FROM user_presence WHERE user_id = $1`,
        [targetUserId]
      );
      if (result.rows[0]) {
        const row = result.rows[0];
        presence = {
          status: 'offline' as PresenceStatus,  // Not in cache = offline
          lastSeen: row.last_seen,
          visibilityList: row.visibility_list || [],
        };
      } else {
        return null;  // Never been online
      }
    }

    // Handle invisible mode with selective visibility
    if (presence.status === 'invisible') {
      if (presence.visibilityList.includes(viewerUserId)) {
        return { status: 'online', lastSeen: presence.lastSeen };
      } else {
        return { status: 'offline', lastSeen: presence.lastSeen };
      }
    }

    // Check if user is actually online (in cache = connected)
    const isOnline = presenceCache.has(targetUserId);
    return {
      status: isOnline ? presence.status : 'offline',
      lastSeen: presence.lastSeen,
    };
  }

  /**
   * Get visible statuses for multiple users (batch for efficiency)
   */
  async getBatchVisibleStatus(
    targetUserIds: string[],
    viewerUserId: string
  ): Promise<Map<string, { status: string; lastSeen: Date | null }>> {
    const results = new Map<string, { status: string; lastSeen: Date | null }>();

    for (const targetId of targetUserIds) {
      const status = await this.getVisibleStatus(targetId, viewerUserId);
      if (status) {
        results.set(targetId, status);
      }
    }

    return results;
  }

  /**
   * Update visibility list for invisible mode
   */
  async setVisibilityList(userId: string, visibilityList: string[]): Promise<void> {
    await query(
      `UPDATE user_presence SET visibility_list = $1, updated_at = NOW() WHERE user_id = $2`,
      [visibilityList, userId]
    );

    const cached = presenceCache.get(userId);
    if (cached) {
      cached.visibilityList = visibilityList;
    }

    // Re-broadcast to update friends' views
    await this.broadcastStatus(userId);
  }

  /**
   * Get user's visibility list
   */
  async getVisibilityList(userId: string): Promise<string[]> {
    const cached = presenceCache.get(userId);
    if (cached) return cached.visibilityList;

    const result = await query(
      `SELECT visibility_list FROM user_presence WHERE user_id = $1`,
      [userId]
    );
    return result.rows[0]?.visibility_list || [];
  }

  /**
   * Handle heartbeat to prevent ghost users
   */
  async heartbeat(userId: string): Promise<void> {
    const cached = presenceCache.get(userId);
    if (cached) {
      cached.lastSeen = new Date();
    }
  }

  /**
   * Check if user is online (connected)
   */
  isOnline(userId: string): boolean {
    return presenceCache.has(userId);
  }

  /**
   * Broadcast status update to all friends
   */
  private async broadcastStatus(userId: string): Promise<void> {
    // Get user's friends
    const friendsResult = await query(
      `SELECT CASE WHEN requester_id = $1 THEN addressee_id ELSE requester_id END as friend_id
       FROM friend_requests
       WHERE (requester_id = $1 OR addressee_id = $1) AND status = 'accepted'`,
      [userId]
    );

    const friendIds: string[] = friendsResult.rows.map((r: any) => r.friend_id);
    if (friendIds.length === 0) return;

    // Get user's username for status display
    const userResult = await query(
      `SELECT username, email FROM users WHERE id = $1`,
      [userId]
    );
    const username = userResult.rows[0]?.username || userResult.rows[0]?.email?.split('@')[0] || 'User';

    // Send personalized status to each friend (respects visibility)
    for (const friendId of friendIds) {
      const visibleStatus = await this.getVisibleStatus(userId, friendId);
      if (visibleStatus) {
        broadcastToUsers([friendId], {
          type: 'presence_update',
          userId,
          username,
          status: visibleStatus.status,
          lastSeen: visibleStatus.lastSeen?.toISOString() || null,
        });
      }
    }
  }
}

export const presenceService = new PresenceService();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Presence service created with status management, visibility logic, WebSocket integration</done>
</task>

<task type="auto">
  <name>Task 2: Create presence REST routes</name>
  <files>backend/src/routes/presence.ts</files>
  <action>
Create `backend/src/routes/presence.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { presenceService } from '../services/presenceService.js';
import type { PresenceStatus } from '../db/schema.js';

const presenceRoutes: FastifyPluginAsync = async (fastify) => {
  // Update own status (requires auth)
  fastify.put('/status', {
    preValidation: [fastify.authenticate],
  }, async (request, reply) => {
    const userId = (request.user as { userId: string }).userId;
    const { status, visibilityList } = request.body as {
      status: PresenceStatus;
      visibilityList?: string[];
    };

    // Validate status
    if (!['online', 'away', 'dnd', 'invisible'].includes(status)) {
      return reply.code(400).send({ error: 'Invalid status' });
    }

    await presenceService.updateStatus(userId, status, visibilityList);
    return { success: true };
  });

  // Get own status (requires auth)
  fastify.get('/status', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const userId = (request.user as { userId: string }).userId;
    const visibilityList = await presenceService.getVisibilityList(userId);
    const isOnline = presenceService.isOnline(userId);

    return {
      status: isOnline ? 'online' : 'offline',
      visibilityList,
    };
  });

  // Get another user's status (requires auth)
  fastify.get('/:userId', {
    preValidation: [fastify.authenticate],
  }, async (request, reply) => {
    const viewerId = (request.user as { userId: string }).userId;
    const { userId } = request.params as { userId: string };

    const status = await presenceService.getVisibleStatus(userId, viewerId);
    if (!status) {
      return reply.code(404).send({ error: 'User not found' });
    }

    return status;
  });

  // Get batch statuses for multiple users (requires auth)
  fastify.post('/batch', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const viewerId = (request.user as { userId: string }).userId;
    const { userIds } = request.body as { userIds: string[] };

    const statuses = await presenceService.getBatchVisibleStatus(userIds, viewerId);

    // Convert Map to object for JSON response
    const result: Record<string, { status: string; lastSeen: string | null }> = {};
    statuses.forEach((value, key) => {
      result[key] = {
        status: value.status,
        lastSeen: value.lastSeen?.toISOString() || null,
      };
    });

    return { statuses: result };
  });

  // Update visibility list (requires auth)
  fastify.put('/visibility', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const userId = (request.user as { userId: string }).userId;
    const { visibilityList } = request.body as { visibilityList: string[] };

    await presenceService.setVisibilityList(userId, visibilityList);
    return { success: true };
  });

  // Get visibility list (requires auth)
  fastify.get('/visibility', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const userId = (request.user as { userId: string }).userId;
    const visibilityList = await presenceService.getVisibilityList(userId);
    return { visibilityList };
  });
};

export default presenceRoutes;
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify routes compile</verify>
  <done>Presence routes created for status management and visibility list</done>
</task>

<task type="auto">
  <name>Task 3: Integrate presence with WebSocket and register routes</name>
  <files>backend/src/routes/websocket.ts, backend/src/server.ts</files>
  <action>
1. Update `backend/src/routes/websocket.ts` to track presence on connect/disconnect:

Add import at top:
```typescript
import { presenceService } from '../services/presenceService.js';
```

After storing connection in activeConnections (where userId is logged on connect):
```typescript
// Store connection
activeConnections.set(userId, socket);
fastify.log.info(`User ${userId} connected via WebSocket`);

// Track presence
await presenceService.userConnected(userId);
```

In socket.on('close') handler:
```typescript
socket.on('close', async () => {
  activeConnections.delete(userId);
  fastify.log.info(`User ${userId} disconnected`);

  // Update presence
  await presenceService.userDisconnected(userId);
});
```

Add presence_heartbeat handler in message switch:
```typescript
else if (msg.type === 'presence_heartbeat') {
  await presenceService.heartbeat(userId);
}

else if (msg.type === 'presence_update') {
  // Allow status update via WebSocket
  const status = msg.status as PresenceStatus;
  if (['online', 'away', 'dnd', 'invisible'].includes(status)) {
    await presenceService.updateStatus(userId, status);
  }
}
```

Update IncomingMessage type to include presence types:
```typescript
interface IncomingMessage {
  type: 'message' | 'group-message' | 'typing' | 'read' |
        'call-offer' | 'call-answer' | 'call-ice-candidate' |
        'call-accept' | 'call-reject' | 'call-hangup' |
        'presence_heartbeat' | 'presence_update';
  // ... existing fields ...
  status?: string;  // For presence_update
}
```

2. Register presence routes in `backend/src/server.ts`:

Add import:
```typescript
import presenceRoutes from './routes/presence.js';
```

Register route:
```typescript
// Presence routes
fastify.register(presenceRoutes, { prefix: '/api/presence' });
```
  </action>
  <verify>Rebuild backend with `docker compose up -d --build backend` and check logs</verify>
  <done>Presence integrated with WebSocket, routes registered at /api/presence</done>
</task>

</tasks>

<verification>
1. WebSocket connection triggers userConnected, broadcasts online to friends
2. WebSocket disconnect triggers userDisconnected, broadcasts offline
3. PUT /api/presence/status updates status and broadcasts
4. GET /api/presence/:userId returns correct visible status
5. Invisible mode shows 'online' to visibility list, 'offline' to others
6. presence_heartbeat WebSocket message refreshes connection
</verification>

<success_criteria>
- Status broadcasts on connect/disconnect
- Selective visibility works for invisible mode
- Heartbeat prevents ghost users
- Last-seen timestamps persist across sessions
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-03-SUMMARY.md`
</output>
