---
phase: 06-social-features
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/src/services/blockService.ts
  - backend/src/routes/blocks.ts
  - backend/src/routes/websocket.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "User can block another user"
    - "User can unblock a blocked user"
    - "Blocked user cannot send messages to blocker"
    - "Blocker can optionally delete conversation history on block"
  artifacts:
    - path: "backend/src/services/blockService.ts"
      provides: "Block/unblock logic, relationship checks"
      exports: ["blockService"]
    - path: "backend/src/routes/blocks.ts"
      provides: "REST routes for blocking"
      exports: ["default"]
  key_links:
    - from: "backend/src/routes/websocket.ts"
      to: "backend/src/services/blockService.ts"
      via: "Block check before message delivery"
    - from: "backend/src/services/blockService.ts"
      to: "backend/src/services/friendService.ts"
      via: "Auto-unfriend on block"
---

<objective>
Create backend blocking service with auto-unfriend and message filtering.

Purpose: Enable users to block others, prevent harassment, control conversation visibility
Output: Block service with REST routes, WebSocket integration for message filtering
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-01-SUMMARY.md
@backend/src/routes/websocket.ts
@backend/src/services/friendService.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create block service</name>
  <files>backend/src/services/blockService.ts</files>
  <action>
Create `backend/src/services/blockService.ts`:

```typescript
import { query } from '../db/index.js';
import { friendService } from './friendService.js';
import type { Block } from '../db/schema.js';

class BlockService {
  /**
   * Block a user
   * - Creates block record
   * - Auto-unfriends (removes friendship)
   * - Optionally deletes conversation history
   */
  async blockUser(
    blockerId: string,
    blockedId: string,
    deleteHistory: boolean = false
  ): Promise<void> {
    // Prevent self-blocking
    if (blockerId === blockedId) {
      throw new Error('Cannot block yourself');
    }

    // Insert block record (ignore if already blocked)
    await query(
      `INSERT INTO blocks (blocker_id, blocked_id, created_at)
       VALUES ($1, $2, NOW())
       ON CONFLICT (blocker_id, blocked_id) DO NOTHING`,
      [blockerId, blockedId]
    );

    // Auto-unfriend (remove friendship in both directions)
    await friendService.removeFriend(blockerId, blockedId);

    // Optionally delete conversation history
    if (deleteHistory) {
      await this.deleteConversationHistory(blockerId, blockedId);
    }
  }

  /**
   * Unblock a user
   * Note: Does NOT restore friendship - user must send new friend request
   */
  async unblockUser(blockerId: string, blockedId: string): Promise<void> {
    await query(
      `DELETE FROM blocks WHERE blocker_id = $1 AND blocked_id = $2`,
      [blockerId, blockedId]
    );
  }

  /**
   * Check if userA has blocked userB
   */
  async isBlocked(blockerId: string, blockedId: string): Promise<boolean> {
    const result = await query(
      `SELECT 1 FROM blocks WHERE blocker_id = $1 AND blocked_id = $2`,
      [blockerId, blockedId]
    );
    return result.rows.length > 0;
  }

  /**
   * Check if either user has blocked the other (bidirectional)
   * Used to prevent messaging in either direction
   */
  async isBlockedBidirectional(userId1: string, userId2: string): Promise<boolean> {
    const result = await query(
      `SELECT 1 FROM blocks
       WHERE (blocker_id = $1 AND blocked_id = $2)
          OR (blocker_id = $2 AND blocked_id = $1)`,
      [userId1, userId2]
    );
    return result.rows.length > 0;
  }

  /**
   * Get list of users blocked by blocker
   */
  async getBlockedUsers(blockerId: string): Promise<Array<{ blockedId: string; blockedAt: Date; username: string | null }>> {
    const result = await query(
      `SELECT b.blocked_id, b.created_at, u.username
       FROM blocks b
       JOIN users u ON u.id = b.blocked_id
       WHERE b.blocker_id = $1
       ORDER BY b.created_at DESC`,
      [blockerId]
    );

    return result.rows.map((row: any) => ({
      blockedId: row.blocked_id,
      blockedAt: row.created_at,
      username: row.username,
    }));
  }

  /**
   * Get list of users who have blocked this user
   * (User doesn't see this directly, but needed for message filtering)
   */
  async getUsersWhoBlockedMe(userId: string): Promise<string[]> {
    const result = await query(
      `SELECT blocker_id FROM blocks WHERE blocked_id = $1`,
      [userId]
    );
    return result.rows.map((row: any) => row.blocker_id);
  }

  /**
   * Delete conversation history between two users
   * Called when blocking with deleteHistory=true
   */
  private async deleteConversationHistory(userId1: string, userId2: string): Promise<number> {
    const result = await query(
      `DELETE FROM messages
       WHERE (sender_id = $1 AND recipient_id = $2)
          OR (sender_id = $2 AND recipient_id = $1)`,
      [userId1, userId2]
    );
    return result.rowCount || 0;
  }

  /**
   * Check if a message should be hidden from viewer due to blocking
   * Used for group messages where blocked users might have sent messages
   */
  async shouldHideMessage(messageOwnerId: string, viewerId: string): Promise<boolean> {
    return this.isBlocked(viewerId, messageOwnerId);
  }

  private mapRow(row: any): Block {
    return {
      blocker_id: row.blocker_id,
      blocked_id: row.blocked_id,
      created_at: row.created_at,
    };
  }
}

export const blockService = new BlockService();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Block service created with block/unblock, bidirectional check, history deletion</done>
</task>

<task type="auto">
  <name>Task 2: Create block REST routes</name>
  <files>backend/src/routes/blocks.ts</files>
  <action>
Create `backend/src/routes/blocks.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { blockService } from '../services/blockService.js';

const blockRoutes: FastifyPluginAsync = async (fastify) => {
  // Block a user (requires auth)
  fastify.post('/:userId', {
    preValidation: [fastify.authenticate],
  }, async (request, reply) => {
    const blockerId = (request.user as { userId: string }).userId;
    const { userId: blockedId } = request.params as { userId: string };
    const { deleteHistory } = request.body as { deleteHistory?: boolean } || {};

    try {
      await blockService.blockUser(blockerId, blockedId, deleteHistory || false);
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Block failed';
      return reply.code(400).send({ error: message });
    }
  });

  // Unblock a user (requires auth)
  fastify.delete('/:userId', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const blockerId = (request.user as { userId: string }).userId;
    const { userId: blockedId } = request.params as { userId: string };

    await blockService.unblockUser(blockerId, blockedId);
    return { success: true };
  });

  // Get list of blocked users (requires auth)
  fastify.get('/', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const blockerId = (request.user as { userId: string }).userId;
    const blockedUsers = await blockService.getBlockedUsers(blockerId);
    return { blockedUsers };
  });

  // Check if a specific user is blocked (requires auth)
  fastify.get('/:userId', {
    preValidation: [fastify.authenticate],
  }, async (request) => {
    const blockerId = (request.user as { userId: string }).userId;
    const { userId: blockedId } = request.params as { userId: string };

    const isBlocked = await blockService.isBlocked(blockerId, blockedId);
    const isBlockedByThem = await blockService.isBlocked(blockedId, blockerId);

    return {
      isBlocked,        // You blocked them
      isBlockedByThem,  // They blocked you
    };
  });
};

export default blockRoutes;
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify routes compile</verify>
  <done>Block routes created with POST block, DELETE unblock, GET list, GET check</done>
</task>

<task type="auto">
  <name>Task 3: Integrate block checks into WebSocket and register routes</name>
  <files>backend/src/routes/websocket.ts, backend/src/server.ts</files>
  <action>
1. Update `backend/src/routes/websocket.ts` to check blocks before message delivery:

Add import at top:
```typescript
import { blockService } from '../services/blockService.js';
```

In the message type handler (after checking if users are friends), add block check:
```typescript
if (msg.type === 'message') {
  // Validate required fields
  if (!msg.recipientId || !msg.encryptedContent) {
    socket.send(JSON.stringify({
      type: 'error',
      message: 'recipientId and encryptedContent are required',
    } as ErrorMessage));
    return;
  }

  // Check if blocked (bidirectional - either user blocked the other)
  const isBlocked = await blockService.isBlockedBidirectional(userId, msg.recipientId);
  if (isBlocked) {
    socket.send(JSON.stringify({
      type: 'error',
      message: "You can't message this user",
    } as ErrorMessage));
    return;
  }

  // Check if users are friends (existing check)
  const areFriends = await friendService.areFriends(userId, msg.recipientId);
  // ... rest of existing code
}
```

Similarly for group-message, add block check when broadcasting:
In the loop where messages are broadcast to members, add:
```typescript
// In group message broadcast loop
for (const memberId of memberIds) {
  if (memberId === userId) continue;

  // Check if member blocked the sender (don't deliver to people who blocked sender)
  const memberBlockedSender = await blockService.isBlocked(memberId, userId);
  if (memberBlockedSender) continue;  // Skip delivery to this member

  const memberSocket = activeConnections.get(memberId);
  // ... rest of existing broadcast code
}
```

2. Register block routes in `backend/src/server.ts`:

Add import:
```typescript
import blockRoutes from './routes/blocks.js';
```

Register route:
```typescript
// Block routes
fastify.register(blockRoutes, { prefix: '/api/blocks' });
```
  </action>
  <verify>Rebuild backend with `docker compose up -d --build backend` and check logs</verify>
  <done>Block checks integrated into WebSocket, routes registered at /api/blocks</done>
</task>

</tasks>

<verification>
1. POST /api/blocks/:userId creates block record
2. DELETE /api/blocks/:userId removes block record
3. GET /api/blocks returns list of blocked users
4. Blocked user sees "You can't message this user" error
5. Blocking auto-unfriends (friendship removed)
6. Group messages not delivered to members who blocked sender
</verification>

<success_criteria>
- Block/unblock creates and removes block records
- Bidirectional check prevents messaging in both directions
- Auto-unfriend on block
- Optional history deletion works
- WebSocket message delivery respects blocks
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-04-SUMMARY.md`
</output>
