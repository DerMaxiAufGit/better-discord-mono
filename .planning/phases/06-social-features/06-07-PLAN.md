---
phase: 06-social-features
plan: 07
type: execute
wave: 3
depends_on: ["06-04"]
files_modified:
  - frontend/src/stores/blockStore.ts
  - frontend/src/components/blocking/BlockButton.tsx
  - frontend/src/components/blocking/BlockedMessagePlaceholder.tsx
  - frontend/src/components/blocking/BlockConfirmDialog.tsx
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User can block another user via UI"
    - "User can unblock from blocked users list"
    - "Blocked user's messages show placeholder in groups"
    - "Block confirmation prompts for history deletion"
  artifacts:
    - path: "frontend/src/stores/blockStore.ts"
      provides: "Block state and relationship checks"
      exports: ["useBlockStore"]
    - path: "frontend/src/components/blocking/BlockButton.tsx"
      provides: "Block/unblock toggle button"
      exports: ["BlockButton"]
    - path: "frontend/src/components/blocking/BlockedMessagePlaceholder.tsx"
      provides: "Placeholder for blocked user messages"
      exports: ["BlockedMessagePlaceholder"]
  key_links:
    - from: "frontend/src/stores/blockStore.ts"
      to: "frontend/src/lib/api.ts"
      via: "blocksApi calls"
    - from: "frontend/src/components/blocking/BlockedMessagePlaceholder.tsx"
      to: "frontend/src/stores/blockStore.ts"
      via: "Check if sender is blocked"
---

<objective>
Create frontend blocking UI with block button, confirmation dialog, and message placeholders.

Purpose: Enable users to block/unblock others and control visibility of blocked content
Output: Block store, block button, confirmation dialog, message placeholder component
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-04-SUMMARY.md
@frontend/src/lib/api.ts
@frontend/src/stores/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blocks API and store</name>
  <files>frontend/src/lib/api.ts, frontend/src/stores/blockStore.ts</files>
  <action>
1. Add blocks API methods to `frontend/src/lib/api.ts`:

```typescript
export const blocksApi = {
  // Block a user
  async block(userId: string, deleteHistory: boolean = false): Promise<void> {
    await apiRequest(`/api/blocks/${userId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ deleteHistory }),
    });
  },

  // Unblock a user
  async unblock(userId: string): Promise<void> {
    await apiRequest(`/api/blocks/${userId}`, { method: 'DELETE' });
  },

  // Get blocked users list
  async getBlocked(): Promise<{
    blockedUsers: Array<{
      blockedId: string;
      blockedAt: string;
      username: string | null;
    }>
  }> {
    return apiRequest('/api/blocks');
  },

  // Check if specific user is blocked
  async checkBlock(userId: string): Promise<{
    isBlocked: boolean;
    isBlockedByThem: boolean;
  }> {
    return apiRequest(`/api/blocks/${userId}`);
  },
};

// Add to api export
export const api = {
  auth: authApi,
  keys: keyApi,
  messages: messageApi,
  users: usersApi,
  friends: friendsApi,
  turn: turnApi,
  avatars: avatarApi,
  presence: presenceApi,
  blocks: blocksApi,
};
```

2. Create `frontend/src/stores/blockStore.ts`:

```typescript
import { create } from 'zustand';
import { blocksApi } from '@/lib/api';

interface BlockedUser {
  blockedId: string;
  blockedAt: Date;
  username: string | null;
}

interface BlockState {
  // Set of blocked user IDs (for quick lookup)
  blockedIds: Set<string>;

  // Full blocked users list with details
  blockedUsers: BlockedUser[];

  // Loading state
  isLoading: boolean;

  // Actions
  loadBlockedUsers: () => Promise<void>;
  blockUser: (userId: string, deleteHistory?: boolean) => Promise<void>;
  unblockUser: (userId: string) => Promise<void>;
  isBlocked: (userId: string) => boolean;
  checkBlockStatus: (userId: string) => Promise<{ isBlocked: boolean; isBlockedByThem: boolean }>;
}

export const useBlockStore = create<BlockState>((set, get) => ({
  blockedIds: new Set(),
  blockedUsers: [],
  isLoading: false,

  loadBlockedUsers: async () => {
    set({ isLoading: true });

    try {
      const response = await blocksApi.getBlocked();
      const blockedUsers = response.blockedUsers.map((u) => ({
        blockedId: u.blockedId,
        blockedAt: new Date(u.blockedAt),
        username: u.username,
      }));

      set({
        blockedUsers,
        blockedIds: new Set(blockedUsers.map((u) => u.blockedId)),
        isLoading: false,
      });
    } catch {
      set({ isLoading: false });
    }
  },

  blockUser: async (userId: string, deleteHistory = false) => {
    await blocksApi.block(userId, deleteHistory);

    // Optimistically update local state
    set((state) => ({
      blockedIds: new Set(state.blockedIds).add(userId),
      blockedUsers: [
        ...state.blockedUsers,
        { blockedId: userId, blockedAt: new Date(), username: null },
      ],
    }));
  },

  unblockUser: async (userId: string) => {
    await blocksApi.unblock(userId);

    // Optimistically update local state
    set((state) => {
      const newBlockedIds = new Set(state.blockedIds);
      newBlockedIds.delete(userId);

      return {
        blockedIds: newBlockedIds,
        blockedUsers: state.blockedUsers.filter((u) => u.blockedId !== userId),
      };
    });
  },

  isBlocked: (userId: string) => get().blockedIds.has(userId),

  checkBlockStatus: async (userId: string) => {
    return blocksApi.checkBlock(userId);
  },
}));
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Blocks API and store created with block/unblock and lookup functionality</done>
</task>

<task type="auto">
  <name>Task 2: Create block button and confirmation dialog</name>
  <files>frontend/src/components/blocking/BlockButton.tsx, frontend/src/components/blocking/BlockConfirmDialog.tsx</files>
  <action>
1. Create directory `frontend/src/components/blocking/`

2. Create `frontend/src/components/blocking/BlockConfirmDialog.tsx`:

```typescript
import { useState } from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';

interface BlockConfirmDialogProps {
  open: boolean;
  username: string | null;
  onConfirm: (deleteHistory: boolean) => void;
  onCancel: () => void;
}

export function BlockConfirmDialog({
  open,
  username,
  onConfirm,
  onCancel,
}: BlockConfirmDialogProps) {
  const [deleteHistory, setDeleteHistory] = useState(false);

  const handleConfirm = () => {
    onConfirm(deleteHistory);
    setDeleteHistory(false); // Reset for next time
  };

  const handleCancel = () => {
    setDeleteHistory(false);
    onCancel();
  };

  return (
    <AlertDialog open={open} onOpenChange={(open) => !open && handleCancel()}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Block {username || 'this user'}?</AlertDialogTitle>
          <AlertDialogDescription className="space-y-3">
            <p>
              Blocking will prevent {username || 'them'} from messaging you.
              This will also remove them from your friends list.
            </p>
            <p>
              {username || 'They'} won't be notified that you blocked them.
              You'll need to send a new friend request to message them again after unblocking.
            </p>
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="flex items-center space-x-2 py-2">
          <Checkbox
            id="delete-history"
            checked={deleteHistory}
            onCheckedChange={(checked) => setDeleteHistory(checked === true)}
          />
          <Label htmlFor="delete-history" className="text-sm">
            Delete conversation history
          </Label>
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel onClick={handleCancel}>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={handleConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90">
            Block
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

3. Create `frontend/src/components/blocking/BlockButton.tsx`:

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { useBlockStore } from '@/stores/blockStore';
import { BlockConfirmDialog } from './BlockConfirmDialog';
import { Ban, Check } from 'lucide-react';
import { showSuccess, showError } from '@/lib/toast';

interface BlockButtonProps {
  userId: string;
  username: string | null;
  variant?: 'default' | 'outline' | 'ghost' | 'destructive';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  showLabel?: boolean;
}

export function BlockButton({
  userId,
  username,
  variant = 'outline',
  size = 'sm',
  showLabel = true,
}: BlockButtonProps) {
  const [showConfirm, setShowConfirm] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const { isBlocked, blockUser, unblockUser } = useBlockStore();
  const blocked = isBlocked(userId);

  const handleBlock = async (deleteHistory: boolean) => {
    setShowConfirm(false);
    setIsLoading(true);

    try {
      await blockUser(userId, deleteHistory);
      showSuccess(`Blocked ${username || 'user'}`);
    } catch (error) {
      showError(error instanceof Error ? error.message : 'Failed to block user');
    } finally {
      setIsLoading(false);
    }
  };

  const handleUnblock = async () => {
    setIsLoading(true);

    try {
      await unblockUser(userId);
      showSuccess(`Unblocked ${username || 'user'}`);
    } catch (error) {
      showError(error instanceof Error ? error.message : 'Failed to unblock user');
    } finally {
      setIsLoading(false);
    }
  };

  if (blocked) {
    return (
      <Button
        variant={variant}
        size={size}
        onClick={handleUnblock}
        disabled={isLoading}
      >
        <Check className="h-4 w-4" />
        {showLabel && <span className="ml-2">Unblock</span>}
      </Button>
    );
  }

  return (
    <>
      <Button
        variant={variant}
        size={size}
        onClick={() => setShowConfirm(true)}
        disabled={isLoading}
      >
        <Ban className="h-4 w-4" />
        {showLabel && <span className="ml-2">Block</span>}
      </Button>

      <BlockConfirmDialog
        open={showConfirm}
        username={username}
        onConfirm={handleBlock}
        onCancel={() => setShowConfirm(false)}
      />
    </>
  );
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify components compile</verify>
  <done>Block button and confirmation dialog created with history deletion option</done>
</task>

<task type="auto">
  <name>Task 3: Create blocked message placeholder and index</name>
  <files>frontend/src/components/blocking/BlockedMessagePlaceholder.tsx, frontend/src/components/blocking/index.ts</files>
  <action>
1. Create `frontend/src/components/blocking/BlockedMessagePlaceholder.tsx`:

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { EyeOff, Eye } from 'lucide-react';
import { cn } from '@/lib/utils';

interface BlockedMessagePlaceholderProps {
  children: React.ReactNode;
  senderName?: string;
  className?: string;
}

export function BlockedMessagePlaceholder({
  children,
  senderName,
  className,
}: BlockedMessagePlaceholderProps) {
  const [revealed, setRevealed] = useState(false);

  if (revealed) {
    return (
      <div className={cn('relative', className)}>
        {children}
        <Button
          variant="ghost"
          size="sm"
          className="absolute -top-2 -right-2 h-6 px-2 text-xs opacity-60 hover:opacity-100"
          onClick={() => setRevealed(false)}
        >
          <EyeOff className="h-3 w-3 mr-1" />
          Hide
        </Button>
      </div>
    );
  }

  return (
    <div
      className={cn(
        'flex items-center justify-between gap-2 px-3 py-2 rounded-lg',
        'bg-muted/50 border border-dashed border-muted-foreground/20',
        className
      )}
    >
      <span className="text-sm text-muted-foreground">
        Message from {senderName ? `blocked user (${senderName})` : 'blocked user'}
      </span>
      <Button
        variant="ghost"
        size="sm"
        className="h-7 text-xs"
        onClick={() => setRevealed(true)}
      >
        <Eye className="h-3 w-3 mr-1" />
        Show
      </Button>
    </div>
  );
}
```

2. Create `frontend/src/components/blocking/index.ts`:

```typescript
export { BlockButton } from './BlockButton';
export { BlockConfirmDialog } from './BlockConfirmDialog';
export { BlockedMessagePlaceholder } from './BlockedMessagePlaceholder';
```

3. Load blocked users on app initialization. Add to the main app initialization logic (where friends are loaded):

In the appropriate location (e.g., App.tsx or MessagesPage.tsx useEffect):
```typescript
import { useBlockStore } from '@/stores/blockStore';

// In useEffect or initialization:
useBlockStore.getState().loadBlockedUsers();
```
  </action>
  <verify>Run `npm run build` to verify all components compile</verify>
  <done>Blocked message placeholder and component exports created</done>
</task>

</tasks>

<verification>
1. BlockButton shows "Block" for non-blocked, "Unblock" for blocked
2. Block confirmation dialog appears with history deletion checkbox
3. BlockedMessagePlaceholder shows/hides content on click
4. Block store tracks blocked user IDs
5. isBlocked() check returns correct boolean
</verification>

<success_criteria>
- Block/unblock actions update server and local state
- Confirmation dialog prompts for history deletion
- Message placeholder toggles visibility
- Blocked users list loads on app start
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-07-SUMMARY.md`
</output>
