---
phase: 06-social-features
plan: 06
type: execute
wave: 3
depends_on: ["06-03"]
files_modified:
  - frontend/src/stores/presenceStore.ts
  - frontend/src/lib/presence/presenceTracker.ts
  - frontend/src/lib/api.ts
  - frontend/src/lib/websocket/useMessaging.ts
autonomous: true

must_haves:
  truths:
    - "User can set their status (Online/Away/DND/Invisible)"
    - "User sees friends' online status in real-time"
    - "Auto-away triggers after 5 minutes idle"
    - "Status persists across page refreshes"
  artifacts:
    - path: "frontend/src/stores/presenceStore.ts"
      provides: "Presence state and status updates"
      exports: ["usePresenceStore"]
    - path: "frontend/src/lib/presence/presenceTracker.ts"
      provides: "Activity tracking and auto-away logic"
      exports: ["presenceTracker"]
  key_links:
    - from: "frontend/src/lib/websocket/useMessaging.ts"
      to: "frontend/src/stores/presenceStore.ts"
      via: "Handle presence_update WebSocket messages"
    - from: "frontend/src/lib/presence/presenceTracker.ts"
      to: "frontend/src/stores/presenceStore.ts"
      via: "Auto-away status updates"
---

<objective>
Create frontend presence tracking with auto-away and status management.

Purpose: Enable users to see friends' online status and manage their own presence
Output: Presence store, activity tracker, WebSocket integration for real-time updates
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-03-SUMMARY.md
@frontend/src/lib/websocket/useMessaging.ts
@frontend/src/stores/contactStore.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create presence API and store</name>
  <files>frontend/src/lib/api.ts, frontend/src/stores/presenceStore.ts</files>
  <action>
1. Add presence API methods to `frontend/src/lib/api.ts`:

```typescript
export type PresenceStatus = 'online' | 'away' | 'dnd' | 'invisible';

export const presenceApi = {
  // Update own status
  async updateStatus(status: PresenceStatus, visibilityList?: string[]): Promise<void> {
    await apiRequest('/api/presence/status', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status, visibilityList }),
    });
  },

  // Get own status
  async getStatus(): Promise<{ status: string; visibilityList: string[] }> {
    return apiRequest('/api/presence/status');
  },

  // Get another user's status
  async getUserStatus(userId: string): Promise<{ status: string; lastSeen: string | null }> {
    return apiRequest(`/api/presence/${userId}`);
  },

  // Get batch statuses
  async getBatchStatus(userIds: string[]): Promise<{
    statuses: Record<string, { status: string; lastSeen: string | null }>
  }> {
    return apiRequest('/api/presence/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userIds }),
    });
  },

  // Update visibility list
  async setVisibilityList(visibilityList: string[]): Promise<void> {
    await apiRequest('/api/presence/visibility', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ visibilityList }),
    });
  },

  // Get visibility list
  async getVisibilityList(): Promise<{ visibilityList: string[] }> {
    return apiRequest('/api/presence/visibility');
  },
};

// Add to api export
export const api = {
  auth: authApi,
  keys: keyApi,
  messages: messageApi,
  users: usersApi,
  friends: friendsApi,
  turn: turnApi,
  avatars: avatarApi,
  presence: presenceApi,
};
```

2. Create `frontend/src/stores/presenceStore.ts`:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { presenceApi, type PresenceStatus } from '@/lib/api';

interface UserPresence {
  status: string;
  lastSeen: Date | null;
}

interface PresenceState {
  // Own status
  myStatus: PresenceStatus;
  visibilityList: string[];

  // Others' status (Map: userId -> status)
  presenceMap: Map<string, UserPresence>;

  // Actions
  setMyStatus: (status: PresenceStatus) => Promise<void>;
  setVisibilityList: (list: string[]) => Promise<void>;
  updateUserPresence: (userId: string, status: string, lastSeen: string | null) => void;
  fetchUserPresence: (userId: string) => Promise<UserPresence | null>;
  fetchBatchPresence: (userIds: string[]) => Promise<void>;
  getPresence: (userId: string) => UserPresence | undefined;
  loadInitialStatus: () => Promise<void>;
}

export const usePresenceStore = create<PresenceState>()(
  persist(
    (set, get) => ({
      myStatus: 'online',
      visibilityList: [],
      presenceMap: new Map(),

      setMyStatus: async (status: PresenceStatus) => {
        set({ myStatus: status });
        await presenceApi.updateStatus(status);
      },

      setVisibilityList: async (list: string[]) => {
        set({ visibilityList: list });
        await presenceApi.setVisibilityList(list);
      },

      updateUserPresence: (userId: string, status: string, lastSeen: string | null) => {
        set((state) => ({
          presenceMap: new Map(state.presenceMap).set(userId, {
            status,
            lastSeen: lastSeen ? new Date(lastSeen) : null,
          }),
        }));
      },

      fetchUserPresence: async (userId: string) => {
        try {
          const response = await presenceApi.getUserStatus(userId);
          const presence: UserPresence = {
            status: response.status,
            lastSeen: response.lastSeen ? new Date(response.lastSeen) : null,
          };

          set((state) => ({
            presenceMap: new Map(state.presenceMap).set(userId, presence),
          }));

          return presence;
        } catch {
          return null;
        }
      },

      fetchBatchPresence: async (userIds: string[]) => {
        if (userIds.length === 0) return;

        try {
          const response = await presenceApi.getBatchStatus(userIds);

          set((state) => {
            const newMap = new Map(state.presenceMap);
            for (const [userId, data] of Object.entries(response.statuses)) {
              newMap.set(userId, {
                status: data.status,
                lastSeen: data.lastSeen ? new Date(data.lastSeen) : null,
              });
            }
            return { presenceMap: newMap };
          });
        } catch {
          // Silently fail - presence is non-critical
        }
      },

      getPresence: (userId: string) => get().presenceMap.get(userId),

      loadInitialStatus: async () => {
        try {
          const response = await presenceApi.getStatus();
          const visibilityResponse = await presenceApi.getVisibilityList();

          set({
            visibilityList: visibilityResponse.visibilityList,
          });
        } catch {
          // Use persisted status on error
        }
      },
    }),
    {
      name: 'presence-store',
      partialize: (state) => ({
        myStatus: state.myStatus,
        visibilityList: state.visibilityList,
      }),
    }
  )
);
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Presence API and store created with status management and caching</done>
</task>

<task type="auto">
  <name>Task 2: Create presence tracker with auto-away</name>
  <files>frontend/src/lib/presence/presenceTracker.ts</files>
  <action>
Create directory and file `frontend/src/lib/presence/presenceTracker.ts`:

```typescript
import { usePresenceStore } from '@/stores/presenceStore';
import type { PresenceStatus } from '@/lib/api';

const AUTO_AWAY_TIMEOUT = 5 * 60 * 1000; // 5 minutes
const HEARTBEAT_INTERVAL = 2 * 60 * 1000; // 2 minutes

class PresenceTracker {
  private activityTimer: number | null = null;
  private heartbeatInterval: number | null = null;
  private wasAway = false;
  private ws: WebSocket | null = null;

  /**
   * Start tracking user activity for auto-away
   */
  start(ws: WebSocket) {
    this.ws = ws;
    this.setupActivityTracking();
    this.startHeartbeat();
  }

  /**
   * Stop tracking (on logout/disconnect)
   */
  stop() {
    this.cleanup();
    this.ws = null;
  }

  private setupActivityTracking() {
    const resetTimer = () => {
      // Clear existing timer
      if (this.activityTimer) {
        window.clearTimeout(this.activityTimer);
      }

      // If was away due to inactivity, restore to online
      if (this.wasAway) {
        this.wasAway = false;
        const store = usePresenceStore.getState();
        if (store.myStatus === 'away') {
          store.setMyStatus('online');
          this.sendStatusUpdate('online');
        }
      }

      // Only auto-away if currently online
      const currentStatus = usePresenceStore.getState().myStatus;
      if (currentStatus === 'online') {
        this.activityTimer = window.setTimeout(() => {
          this.wasAway = true;
          usePresenceStore.getState().setMyStatus('away');
          this.sendStatusUpdate('away');
        }, AUTO_AWAY_TIMEOUT);
      }
    };

    // Track user activity events
    const events = ['mousemove', 'keydown', 'click', 'scroll', 'touchstart'];
    events.forEach((event) => {
      document.addEventListener(event, resetTimer, { passive: true });
    });

    // Initial timer
    resetTimer();
  }

  private startHeartbeat() {
    // Clear existing interval
    if (this.heartbeatInterval) {
      window.clearInterval(this.heartbeatInterval);
    }

    // Send heartbeat every 2 minutes
    this.heartbeatInterval = window.setInterval(() => {
      this.sendHeartbeat();
    }, HEARTBEAT_INTERVAL);
  }

  private sendStatusUpdate(status: PresenceStatus) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'presence_update',
        status,
      }));
    }
  }

  private sendHeartbeat() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'presence_heartbeat',
      }));
    }
  }

  private cleanup() {
    if (this.activityTimer) {
      window.clearTimeout(this.activityTimer);
      this.activityTimer = null;
    }
    if (this.heartbeatInterval) {
      window.clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
}

// Singleton instance
export const presenceTracker = new PresenceTracker();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Presence tracker created with auto-away and heartbeat functionality</done>
</task>

<task type="auto">
  <name>Task 3: Integrate presence with WebSocket messaging hook</name>
  <files>frontend/src/lib/websocket/useMessaging.ts</files>
  <action>
Update `frontend/src/lib/websocket/useMessaging.ts` to handle presence updates:

1. Add import at top:
```typescript
import { usePresenceStore } from '@/stores/presenceStore';
import { presenceTracker } from '@/lib/presence/presenceTracker';
```

2. In the WebSocket message handler (switch/case for message types), add presence_update handler:
```typescript
case 'presence_update': {
  const { userId, status, lastSeen } = data;
  usePresenceStore.getState().updateUserPresence(userId, status, lastSeen);
  break;
}
```

3. In the WebSocket connection success handler, start presence tracking:
```typescript
// After socket opens successfully
presenceTracker.start(socket);

// Load initial status from server
usePresenceStore.getState().loadInitialStatus();
```

4. In the WebSocket close/cleanup handler, stop presence tracking:
```typescript
// On disconnect/cleanup
presenceTracker.stop();
```

5. When fetching friends/contacts, also fetch their presence:
```typescript
// After loading friends list, fetch their presence
const friendIds = friends.map(f => f.id);
usePresenceStore.getState().fetchBatchPresence(friendIds);
```

The exact integration points depend on the current structure of useMessaging.ts.
Key requirement: presence_update messages from server update presenceStore.
  </action>
  <verify>Run `npm run build` to verify compilation and integration</verify>
  <done>Presence integrated with WebSocket, real-time updates working</done>
</task>

</tasks>

<verification>
1. Status persists across page refresh (localStorage)
2. presence_update WebSocket messages update presenceStore
3. Auto-away triggers after 5 minutes idle when status is 'online'
4. Activity (mouse/keyboard) cancels auto-away timer
5. Heartbeat sent every 2 minutes via WebSocket
6. Batch presence fetch works for multiple users
</verification>

<success_criteria>
- Status changes broadcast via WebSocket
- Friends' status visible in real-time
- Auto-away respects current status (only when 'online')
- Activity restores from auto-away
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-06-SUMMARY.md`
</output>
