---
phase: 06-social-features
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/messaging/ConversationView.tsx
  - frontend/src/components/messaging/MessageList.tsx
  - frontend/src/components/messaging/ConversationList.tsx
  - frontend/src/pages/ContactsPage.tsx
  - frontend/src/pages/SettingsPage.tsx
  - frontend/src/pages/MessagesPage.tsx
  - frontend/src/stores/presenceStore.ts
  - frontend/src/stores/messageStore.ts
  - frontend/src/components/search/SearchResults.tsx
  - backend/src/routes/presence.ts
  - backend/src/services/presenceService.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Avatar displays in message list and conversation header show actual uploaded avatars"
    - "Presence status updates live in friend list without page refresh"
    - "Last seen text appears in DM conversation header and updates reactively"
    - "Invisible mode with whitelist correctly shows user as online to whitelisted friends"
    - "Block button is accessible in conversation header and contacts page"
    - "Settings page has Blocked Users section showing blocked list with unblock option"
    - "Search results show actual usernames, not UUIDs"
    - "Clicking search result navigates to conversation and highlights the specific message"
  artifacts:
    - path: "frontend/src/components/messaging/ConversationView.tsx"
      provides: "AvatarDisplay with userId and LastSeenText in header"
      contains: "AvatarDisplay"
    - path: "frontend/src/components/messaging/MessageList.tsx"
      provides: "AvatarDisplay replacing Avatar in message bubbles"
      contains: "AvatarDisplay"
    - path: "frontend/src/pages/SettingsPage.tsx"
      provides: "Blocked Users section with list and unblock functionality"
      contains: "Blocked Users"
    - path: "backend/src/routes/presence.ts"
      provides: "GET /status returns actual persisted status, not just online/offline"
      contains: "status: cached.status"
  key_links:
    - from: "ConversationView.tsx"
      to: "presenceStore"
      via: "usePresenceStore selector for contactId"
      pattern: "usePresenceStore.*presenceMap"
    - from: "ContactsPage.tsx"
      to: "presenceStore"
      via: "direct presenceMap subscription"
      pattern: "usePresenceStore.*presenceMap"
    - from: "MessagesPage.tsx"
      to: "MessageList"
      via: "highlightMessageId prop"
      pattern: "highlightMessageId"
---

<objective>
Fix 8 UAT gaps discovered during Phase 6 social features testing.

Purpose: Address integration issues where components exist but are not properly wired together, ensuring social features work end-to-end as designed.

Output: Updated frontend components and one backend route fix that make avatars, presence, blocking, and search work correctly.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Existing components to wire:
@frontend/src/components/avatar/AvatarDisplay.tsx - Has userId, size, showStatus, status props
@frontend/src/components/presence/LastSeenText.tsx - Has lastSeen, status, className props
@frontend/src/components/blocking/BlockButton.tsx - Has userId, username props
@frontend/src/stores/presenceStore.ts - Has getPresence() but needs selector subscription
@frontend/src/stores/blockStore.ts - Has blockedUsers array and isBlocked()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Avatar with AvatarDisplay in messaging components</name>
  <files>
    frontend/src/components/messaging/ConversationView.tsx
    frontend/src/components/messaging/MessageList.tsx
    frontend/src/components/messaging/ConversationList.tsx
  </files>
  <action>
Gap 1 fix: Replace generic Avatar components with AvatarDisplay that fetches and displays actual user avatars.

In ConversationView.tsx:
1. Add import: `import { AvatarDisplay } from '@/components/avatar/AvatarDisplay';`
2. Add import: `import { usePresenceStore } from '@/stores/presenceStore';`
3. Inside component, subscribe to presence for contactId:
   ```typescript
   const presence = usePresenceStore((state) => state.presenceMap.get(contactId));
   ```
4. Replace header Avatar with:
   ```tsx
   <AvatarDisplay
     userId={contactId}
     size="small"
     showStatus
     status={(presence?.status as any) || 'offline'}
   />
   ```

In MessageList.tsx:
1. Add import: `import { AvatarDisplay } from '@/components/avatar/AvatarDisplay';`
2. For non-own messages, replace `<Avatar className="h-8 w-8" fallback={contactUsername || '?'} />` with:
   ```tsx
   <AvatarDisplay
     userId={message.senderId}
     size="tiny"
   />
   ```
   (Do this in BOTH the blocked message placeholder section AND the main message rendering section - there are two Avatar usages)

In ConversationList.tsx:
1. Add import: `import { AvatarDisplay } from '@/components/avatar/AvatarDisplay';`
2. Replace `<Avatar fallback={conv.contactUsername} className="h-10 w-10" />` with:
   ```tsx
   <AvatarDisplay userId={conv.contactId} size="small" />
   ```
  </action>
  <verify>
Build passes: `cd frontend && npm run build`
Visual check: Avatar images appear in conversations instead of just initials
  </verify>
  <done>
Message bubbles, conversation headers, and conversation list items all display actual user avatars via AvatarDisplay component
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix presence reactivity and add LastSeenText to DMs</name>
  <files>
    frontend/src/pages/ContactsPage.tsx
    frontend/src/components/messaging/ConversationView.tsx
  </files>
  <action>
Gap 2 and 3 fix: Fix Zustand subscription bug where getPresence() doesn't trigger re-renders, and add LastSeenText to conversation header.

In ContactsPage.tsx:
The current code calls `getPresence(friend.oderId)` which is a function that reads state imperatively - this doesn't create a subscription. Fix by subscribing to presenceMap directly:

1. Replace the current destructuring:
   ```typescript
   // OLD:
   const { getPresence, fetchBatchPresence } = usePresenceStore();

   // NEW - subscribe to presenceMap for reactivity:
   const presenceMap = usePresenceStore((state) => state.presenceMap);
   const fetchBatchPresence = usePresenceStore((state) => state.fetchBatchPresence);
   ```

2. In the friend list rendering, change from:
   ```typescript
   status={getPresence(friend.oderId)?.status as any || 'offline'}
   // and
   lastSeen={getPresence(friend.oderId)?.lastSeen || null}
   status={getPresence(friend.oderId)?.status || 'offline'}
   ```
   To:
   ```typescript
   status={(presenceMap.get(friend.oderId)?.status as any) || 'offline'}
   // and
   lastSeen={presenceMap.get(friend.oderId)?.lastSeen || null}
   status={presenceMap.get(friend.oderId)?.status || 'offline'}
   ```

In ConversationView.tsx:
1. Add import: `import { LastSeenText } from '@/components/presence/LastSeenText';`
2. You already added presence subscription in Task 1. Now add LastSeenText below the contact username in the header:
   After `<h2 className="font-semibold">{contactUsername}</h2>`, add:
   ```tsx
   <LastSeenText
     lastSeen={presence?.lastSeen || null}
     status={presence?.status || 'offline'}
     className="text-xs"
   />
   ```
3. Remove the existing "End-to-end encrypted" text OR move it below the LastSeenText (user preference - keep it but make it secondary):
   ```tsx
   <div className="flex-1">
     <h2 className="font-semibold">{contactUsername}</h2>
     <LastSeenText
       lastSeen={presence?.lastSeen || null}
       status={presence?.status || 'offline'}
       className="text-xs"
     />
   </div>
   ```
  </action>
  <verify>
Build passes: `cd frontend && npm run build`
Open two browser windows with different users, change status - friend list updates without refresh
  </verify>
  <done>
Presence status in friend list updates reactively when contacts come online/offline. DM conversation headers show last seen text.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix invisible whitelist backend bug</name>
  <files>backend/src/routes/presence.ts</files>
  <action>
Gap 4 fix: The GET /status endpoint returns only online/offline based on isOnline(), ignoring the user's actual persisted status (online/away/dnd/invisible).

In presence.ts, find the GET /status handler (around line 26-37):
```typescript
// Current broken code:
fastify.get('/status', {
  preValidation: [fastify.authenticate],
}, async (request) => {
  const userId = (request.user as { userId: string }).userId;
  const visibilityList = await presenceService.getVisibilityList(userId);
  const isOnline = presenceService.isOnline(userId);

  return {
    status: isOnline ? 'online' : 'offline',  // BUG: Ignores actual status
    visibilityList,
  };
});
```

Replace with:
```typescript
fastify.get('/status', {
  preValidation: [fastify.authenticate],
}, async (request) => {
  const userId = (request.user as { userId: string }).userId;
  const visibilityList = await presenceService.getVisibilityList(userId);

  // Get actual persisted status from presenceService
  // If user is in cache, use their status; otherwise query DB
  const cached = presenceService.getCachedPresence(userId);
  let status: string;

  if (cached) {
    status = cached.status;
  } else {
    // User not in cache = offline, but we still need their persisted status preference
    // for when they reconnect
    const dbStatus = await presenceService.getPersistedStatus(userId);
    status = dbStatus || 'online';
  }

  return {
    status,
    visibilityList,
  };
});
```

In presenceService.ts, add two helper methods to the PresenceService class:
```typescript
/**
 * Get cached presence data (for internal use)
 */
getCachedPresence(userId: string): { status: PresenceStatus; lastSeen: Date; visibilityList: string[] } | undefined {
  return presenceCache.get(userId);
}

/**
 * Get persisted status from database (for when user is offline but we need their preference)
 */
async getPersistedStatus(userId: string): Promise<PresenceStatus | null> {
  const result = await query(
    `SELECT status FROM user_presence WHERE user_id = $1`,
    [userId]
  );
  return result.rows[0]?.status || null;
}
```

Add to backend/src/services/presenceService.ts after the isOnline method (around line 214).
  </action>
  <verify>
Backend builds: `cd backend && npm run build`
Test: Set status to "invisible", reload page, GET /status should return "invisible" not "online"
  </verify>
  <done>
GET /status endpoint returns actual user status (online/away/dnd/invisible) not just connection state. Invisible whitelist feature works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add BlockButton to conversation and contacts</name>
  <files>
    frontend/src/components/messaging/ConversationView.tsx
    frontend/src/pages/ContactsPage.tsx
  </files>
  <action>
Gap 5 fix: BlockButton component exists but is not integrated into the UI.

In ConversationView.tsx:
1. Add import: `import { BlockButton } from '@/components/blocking/BlockButton';`
2. Add import for MoreVertical icon: Update lucide import to include `MoreVertical`
3. Add import: `import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';`
4. After the Phone button in the header (around line 116-125), add a dropdown menu with block option:
   ```tsx
   <DropdownMenu>
     <DropdownMenuTrigger asChild>
       <Button variant="ghost" size="icon">
         <MoreVertical className="h-5 w-5" />
       </Button>
     </DropdownMenuTrigger>
     <DropdownMenuContent align="end">
       <DropdownMenuItem asChild>
         <BlockButton
           userId={contactId}
           username={contactUsername}
           variant="ghost"
           size="sm"
           showLabel
         />
       </DropdownMenuItem>
     </DropdownMenuContent>
   </DropdownMenu>
   ```

In ContactsPage.tsx:
1. Add import: `import { BlockButton } from '@/components/blocking/BlockButton';`
2. In the friends list, after the Message button (around line 310), add BlockButton:
   ```tsx
   <BlockButton
     userId={friend.oderId}
     username={friend.username}
     variant="ghost"
     size="icon"
     showLabel={false}
   />
   ```
  </action>
  <verify>
Build passes: `cd frontend && npm run build`
Block button visible in conversation header dropdown and contacts page
  </verify>
  <done>
Users can block contacts from conversation header menu and from contacts page friend list
  </done>
</task>

<task type="auto">
  <name>Task 5: Add Blocked Users section to Settings</name>
  <files>frontend/src/pages/SettingsPage.tsx</files>
  <action>
Gap 6 fix: Settings page is missing a Blocked Users management section.

In SettingsPage.tsx:
1. Add imports at top:
   ```typescript
   import { useBlockStore } from '@/stores/blockStore';
   import { Ban } from 'lucide-react';
   ```
2. Inside the component, add:
   ```typescript
   const { blockedUsers, loadBlockedUsers, unblockUser, isLoading: isBlockLoading } = useBlockStore();
   const [unblocking, setUnblocking] = React.useState<string | null>(null);

   React.useEffect(() => {
     loadBlockedUsers();
   }, [loadBlockedUsers]);

   const handleUnblock = async (userId: string) => {
     setUnblocking(userId);
     try {
       await unblockUser(userId);
     } finally {
       setUnblocking(null);
     }
   };
   ```

3. After the Audio section and before the Info/About section (around line 128), add:
   ```tsx
   {/* Blocked Users Section */}
   <section className="space-y-4">
     <h2 className="text-lg font-semibold">Blocked Users</h2>
     {isBlockLoading ? (
       <p className="text-sm text-muted-foreground">Loading...</p>
     ) : blockedUsers.length === 0 ? (
       <p className="text-sm text-muted-foreground">No blocked users</p>
     ) : (
       <div className="space-y-2">
         {blockedUsers.map((blocked) => (
           <div
             key={blocked.blockedId}
             className="flex items-center justify-between p-3 rounded-lg border"
           >
             <div className="flex items-center gap-3">
               <Ban className="h-4 w-4 text-muted-foreground" />
               <div>
                 <p className="font-medium">{blocked.username || 'Unknown user'}</p>
                 <p className="text-xs text-muted-foreground">
                   Blocked {blocked.blockedAt.toLocaleDateString()}
                 </p>
               </div>
             </div>
             <Button
               variant="outline"
               size="sm"
               onClick={() => handleUnblock(blocked.blockedId)}
               disabled={unblocking === blocked.blockedId}
             >
               {unblocking === blocked.blockedId ? 'Unblocking...' : 'Unblock'}
             </Button>
           </div>
         ))}
       </div>
     )}
   </section>
   ```
  </action>
  <verify>
Build passes: `cd frontend && npm run build`
Settings page shows Blocked Users section with list and unblock buttons
  </verify>
  <done>
Settings page has Blocked Users section showing list of blocked users with unblock functionality
  </done>
</task>

<task type="auto">
  <name>Task 6: Fix search showing UUID and add message highlighting</name>
  <files>
    frontend/src/stores/messageStore.ts
    frontend/src/pages/MessagesPage.tsx
    frontend/src/components/messaging/MessageList.tsx
  </files>
  <action>
Gap 7 and 8 fix: Search shows UUID instead of username, and clicking search result doesn't highlight the message.

In messageStore.ts (loadHistory function around line 182-186):
The bug is that senderName lookup uses contactId (the conversation partner) for ALL messages, but for messages sent BY the current user, it should use current user's username.

Find this code:
```typescript
// Prepare message for search indexing
messagesToIndex.push({
  id: msg.id,
  conversationId: contactId,
  conversationType: 'dm',
  senderId: msg.senderId,
  senderName: contact?.username || msg.senderId,  // BUG: Always uses contact name
  plaintext: content,
  timestamp,
});
```

Fix: Need to get current user's info. Add at the top of loadHistory, after getting contactStore:
```typescript
// Get current user info for proper sender name attribution
const authStore = await import('@/stores/auth').then(m => m.useAuthStore.getState());
const currentUser = authStore.user;
```

Then fix the senderName assignment:
```typescript
// Determine correct sender name
let senderName: string;
if (currentUser && msg.senderId === String(currentUser.id)) {
  senderName = currentUser.username || currentUser.email?.split('@')[0] || 'You';
} else {
  senderName = contact?.username || msg.senderId;
}

messagesToIndex.push({
  id: msg.id,
  conversationId: contactId,
  conversationType: 'dm',
  senderId: msg.senderId,
  senderName,
  plaintext: content,
  timestamp,
});
```

In MessagesPage.tsx:
1. Add state for highlighted message:
   ```typescript
   const [highlightMessageId, setHighlightMessageId] = React.useState<number | null>(null);
   ```

2. Update the SearchResults onResultClick handler (around line 454-468):
   ```typescript
   onResultClick={(conversationId, messageId) => {
     // Navigate to conversation
     const group = groups.find(g => g.id === conversationId);
     if (group) {
       setSelectedGroupId(conversationId);
       navigate('/messages');
     } else {
       setSelectedGroupId(null);
       navigate(`/messages/${conversationId}`);
     }
     // Set highlight message ID
     setHighlightMessageId(messageId);
     setShowSearch(false);
     clearSearch();
   }}
   ```

3. Pass highlightMessageId to MessageList in both mobile and desktop ConversationView usage AND in group view. But ConversationView doesn't expose MessageList props directly. Instead, we need to handle this differently.

   Actually, since ConversationView wraps MessageList internally, we need to pass it through. Add to ConversationViewProps interface and component:

   In ConversationView.tsx, add prop to interface:
   ```typescript
   highlightMessageId?: number | null;
   ```

   Add to destructuring and pass to MessageList:
   ```tsx
   <MessageList
     messages={messages}
     currentUserId={currentUserId}
     contactUsername={contactUsername}
     onReply={handleReply}
     highlightMessageId={highlightMessageId}
   />
   ```

4. Back in MessagesPage.tsx, pass highlightMessageId to ConversationView:
   ```tsx
   <ConversationView
     contactId={contactId}
     contactUsername={activeContact.username}
     currentUserId={String(user.id)}
     messages={activeMessages}
     onSendMessage={handleSendMessage}
     isLoading={isLoadingHistory}
     onBack={() => navigate('/messages')}
     typingUsers={typingUsers}
     onInputChange={onInputChange}
     highlightMessageId={highlightMessageId}
   />
   ```

5. Clear highlight after a delay or when conversation changes:
   ```typescript
   React.useEffect(() => {
     if (highlightMessageId) {
       const timer = setTimeout(() => setHighlightMessageId(null), 3000);
       return () => clearTimeout(timer);
     }
   }, [highlightMessageId]);
   ```

In MessageList.tsx:
1. Add to interface:
   ```typescript
   highlightMessageId?: number | null;
   ```
2. Add to destructuring
3. Add useEffect to scroll to highlighted message:
   ```typescript
   // Scroll to and highlight searched message
   React.useEffect(() => {
     if (highlightMessageId) {
       const element = document.getElementById(`message-${highlightMessageId}`);
       if (element) {
         element.scrollIntoView({ behavior: 'smooth', block: 'center' });
         element.classList.add('bg-yellow-500/20');
         setTimeout(() => element.classList.remove('bg-yellow-500/20'), 3000);
       }
     }
   }, [highlightMessageId, messages]);
   ```
  </action>
  <verify>
Build passes: `cd frontend && npm run build`
Search shows "You" or contact username, not UUID. Clicking result scrolls to and highlights message.
  </verify>
  <done>
Search results display proper usernames. Clicking a search result navigates to conversation and highlights the specific message with a yellow flash.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && npm run build` - no TypeScript errors
2. `cd backend && npm run build` - no TypeScript errors
3. `docker compose up -d --build` - containers start healthy
4. Manual UAT re-test of all 8 gaps:
   - Avatars show in messages
   - Presence updates live
   - Last seen in DM header
   - Invisible whitelist works
   - Block button accessible
   - Blocked users in settings
   - Search shows names not UUIDs
   - Search highlights messages
</verification>

<success_criteria>
- All 8 UAT gaps are closed
- No regression in existing functionality
- Build passes for frontend and backend
- Docker containers healthy
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-11-SUMMARY.md`
</output>
