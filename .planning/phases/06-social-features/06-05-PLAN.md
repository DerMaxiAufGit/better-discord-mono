---
phase: 06-social-features
plan: 05
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - frontend/package.json
  - frontend/src/stores/avatarStore.ts
  - frontend/src/components/avatar/AvatarCropper.tsx
  - frontend/src/components/avatar/AvatarUpload.tsx
  - frontend/src/components/avatar/AvatarDisplay.tsx
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User can select an image file for avatar upload"
    - "User can crop image to square region with zoom/pan"
    - "Cropped avatar uploads to server"
    - "Avatar displays at appropriate sizes throughout app"
  artifacts:
    - path: "frontend/src/stores/avatarStore.ts"
      provides: "Avatar upload state and cache"
      exports: ["useAvatarStore"]
    - path: "frontend/src/components/avatar/AvatarCropper.tsx"
      provides: "Interactive cropping modal"
      exports: ["AvatarCropper"]
    - path: "frontend/src/components/avatar/AvatarDisplay.tsx"
      provides: "Reusable avatar display component"
      exports: ["AvatarDisplay"]
  key_links:
    - from: "frontend/src/components/avatar/AvatarUpload.tsx"
      to: "frontend/src/components/avatar/AvatarCropper.tsx"
      via: "Opens cropper modal on file select"
    - from: "frontend/src/stores/avatarStore.ts"
      to: "frontend/src/lib/api.ts"
      via: "avatarApi.upload/delete calls"
---

<objective>
Create frontend avatar upload with react-easy-crop cropper and avatar display component.

Purpose: Enable users to upload and crop profile avatars with a polished UI
Output: Avatar cropper modal, upload component, display component with size variants
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-02-SUMMARY.md
@frontend/src/lib/api.ts
@frontend/src/stores/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-easy-crop and create avatar store</name>
  <files>frontend/package.json, frontend/src/stores/avatarStore.ts, frontend/src/lib/api.ts</files>
  <action>
1. Install react-easy-crop in frontend:
```bash
cd frontend && npm install react-easy-crop
```

2. Add avatar API methods to `frontend/src/lib/api.ts`:

```typescript
export const avatarApi = {
  // Upload cropped avatar image
  async upload(blob: Blob): Promise<{
    avatar: {
      id: string;
      tinyUrl: string;
      smallUrl: string;
      largeUrl: string;
    }
  }> {
    const formData = new FormData();
    formData.append('avatar', blob, 'avatar.jpg');

    const accessToken = localStorage.getItem('accessToken');
    const response = await fetch(`${API_URL}/api/avatars`, {
      method: 'POST',
      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {},
      body: formData,
      credentials: 'include',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Upload failed' }));
      throw new Error(error.error || 'Upload failed');
    }

    return response.json();
  },

  // Delete own avatar
  async delete(): Promise<void> {
    await apiRequest('/api/avatars', { method: 'DELETE' });
  },

  // Get avatar URLs for user
  async get(userId: string): Promise<{
    avatar: {
      tinyUrl: string;
      smallUrl: string;
      largeUrl: string;
    } | null
  }> {
    return apiRequest(`/api/avatars/${userId}`);
  },

  // Get full avatar URL
  getUrl(userId: string, size: 'tiny' | 'small' | 'large'): string {
    return `${API_URL}/api/avatars/${userId}/${size}`;
  },
};

// Add to api export
export const api = {
  auth: authApi,
  keys: keyApi,
  messages: messageApi,
  users: usersApi,
  friends: friendsApi,
  turn: turnApi,
  avatars: avatarApi,
};
```

3. Create `frontend/src/stores/avatarStore.ts`:

```typescript
import { create } from 'zustand';
import { avatarApi } from '@/lib/api';

interface AvatarUrls {
  tinyUrl: string;
  smallUrl: string;
  largeUrl: string;
}

interface AvatarState {
  // Cache of user avatars
  avatarCache: Map<string, AvatarUrls | null>;

  // Upload state
  isUploading: boolean;
  uploadError: string | null;

  // Actions
  fetchAvatar: (userId: string) => Promise<AvatarUrls | null>;
  uploadAvatar: (blob: Blob) => Promise<AvatarUrls>;
  deleteAvatar: () => Promise<void>;
  clearCache: (userId?: string) => void;
  getAvatarUrl: (userId: string, size: 'tiny' | 'small' | 'large') => string | null;
}

export const useAvatarStore = create<AvatarState>((set, get) => ({
  avatarCache: new Map(),
  isUploading: false,
  uploadError: null,

  fetchAvatar: async (userId: string) => {
    // Check cache first
    const cached = get().avatarCache.get(userId);
    if (cached !== undefined) return cached;

    try {
      const response = await avatarApi.get(userId);
      const urls = response.avatar;

      set((state) => ({
        avatarCache: new Map(state.avatarCache).set(userId, urls),
      }));

      return urls;
    } catch {
      // User has no avatar
      set((state) => ({
        avatarCache: new Map(state.avatarCache).set(userId, null),
      }));
      return null;
    }
  },

  uploadAvatar: async (blob: Blob) => {
    set({ isUploading: true, uploadError: null });

    try {
      const response = await avatarApi.upload(blob);
      const urls = response.avatar;

      // Update cache for current user
      const userId = localStorage.getItem('userId');
      if (userId) {
        set((state) => ({
          avatarCache: new Map(state.avatarCache).set(userId, urls),
          isUploading: false,
        }));
      } else {
        set({ isUploading: false });
      }

      return urls;
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Upload failed';
      set({ isUploading: false, uploadError: message });
      throw error;
    }
  },

  deleteAvatar: async () => {
    set({ isUploading: true, uploadError: null });

    try {
      await avatarApi.delete();

      // Clear cache for current user
      const userId = localStorage.getItem('userId');
      if (userId) {
        set((state) => ({
          avatarCache: new Map(state.avatarCache).set(userId, null),
          isUploading: false,
        }));
      } else {
        set({ isUploading: false });
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Delete failed';
      set({ isUploading: false, uploadError: message });
      throw error;
    }
  },

  clearCache: (userId?: string) => {
    if (userId) {
      set((state) => {
        const newCache = new Map(state.avatarCache);
        newCache.delete(userId);
        return { avatarCache: newCache };
      });
    } else {
      set({ avatarCache: new Map() });
    }
  },

  getAvatarUrl: (userId: string, size: 'tiny' | 'small' | 'large') => {
    const cached = get().avatarCache.get(userId);
    if (!cached) return null;

    switch (size) {
      case 'tiny': return cached.tinyUrl;
      case 'small': return cached.smallUrl;
      case 'large': return cached.largeUrl;
    }
  },
}));
```
  </action>
  <verify>Run `npm run build` in frontend to verify installation and compilation</verify>
  <done>react-easy-crop installed, avatar API and store created</done>
</task>

<task type="auto">
  <name>Task 2: Create avatar cropper modal component</name>
  <files>frontend/src/components/avatar/AvatarCropper.tsx</files>
  <action>
Create directory and file `frontend/src/components/avatar/AvatarCropper.tsx`:

```typescript
import { useState, useCallback } from 'react';
import Cropper from 'react-easy-crop';
import type { Area, Point } from 'react-easy-crop';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { X, ZoomIn } from 'lucide-react';

interface AvatarCropperProps {
  imageSrc: string;
  onComplete: (blob: Blob) => void;
  onCancel: () => void;
}

export function AvatarCropper({ imageSrc, onComplete, onCancel }: AvatarCropperProps) {
  const [crop, setCrop] = useState<Point>({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState<Area | null>(null);

  const onCropComplete = useCallback((_croppedArea: Area, croppedAreaPixels: Area) => {
    setCroppedAreaPixels(croppedAreaPixels);
  }, []);

  const handleSave = async () => {
    if (!croppedAreaPixels) return;

    // Create canvas to crop image
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const image = new Image();
    image.crossOrigin = 'anonymous';
    image.src = imageSrc;

    await new Promise<void>((resolve) => {
      image.onload = () => resolve();
    });

    // Set canvas to cropped area size (max 512px for reasonable file size)
    const maxSize = 512;
    const scale = Math.min(1, maxSize / Math.max(croppedAreaPixels.width, croppedAreaPixels.height));
    canvas.width = croppedAreaPixels.width * scale;
    canvas.height = croppedAreaPixels.height * scale;

    // Draw cropped portion
    ctx.drawImage(
      image,
      croppedAreaPixels.x,
      croppedAreaPixels.y,
      croppedAreaPixels.width,
      croppedAreaPixels.height,
      0,
      0,
      canvas.width,
      canvas.height
    );

    // Convert to blob
    canvas.toBlob(
      (blob) => {
        if (blob) {
          onComplete(blob);
        }
      },
      'image/jpeg',
      0.92
    );
  };

  return (
    <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
      <div className="bg-background rounded-lg w-full max-w-md flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="text-lg font-semibold">Crop Avatar</h3>
          <Button variant="ghost" size="icon" onClick={onCancel}>
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Cropper area */}
        <div className="relative h-[300px] bg-muted">
          <Cropper
            image={imageSrc}
            crop={crop}
            zoom={zoom}
            aspect={1}
            cropShape="round"
            showGrid={false}
            onCropChange={setCrop}
            onZoomChange={setZoom}
            onCropComplete={onCropComplete}
          />
        </div>

        {/* Zoom slider */}
        <div className="p-4 flex items-center gap-3">
          <ZoomIn className="h-4 w-4 text-muted-foreground" />
          <Slider
            value={[zoom]}
            min={1}
            max={3}
            step={0.1}
            onValueChange={([value]) => setZoom(value)}
            className="flex-1"
          />
        </div>

        {/* Actions */}
        <div className="flex gap-2 p-4 border-t">
          <Button variant="outline" className="flex-1" onClick={onCancel}>
            Cancel
          </Button>
          <Button className="flex-1" onClick={handleSave}>
            Save Avatar
          </Button>
        </div>
      </div>
    </div>
  );
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify component compiles</verify>
  <done>Avatar cropper modal created with zoom slider and round crop shape</done>
</task>

<task type="auto">
  <name>Task 3: Create avatar upload and display components</name>
  <files>frontend/src/components/avatar/AvatarUpload.tsx, frontend/src/components/avatar/AvatarDisplay.tsx, frontend/src/components/avatar/index.ts</files>
  <action>
1. Create `frontend/src/components/avatar/AvatarUpload.tsx`:

```typescript
import { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { AvatarCropper } from './AvatarCropper';
import { AvatarDisplay } from './AvatarDisplay';
import { useAvatarStore } from '@/stores/avatarStore';
import { useAuthStore } from '@/stores/auth';
import { Camera, Trash2, Loader2 } from 'lucide-react';
import { showSuccess, showError } from '@/lib/toast';

export function AvatarUpload() {
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const { user } = useAuthStore();
  const { isUploading, uploadAvatar, deleteAvatar } = useAvatarStore();

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    if (!file.type.startsWith('image/')) {
      showError('Please select an image file');
      return;
    }

    // Validate file size (5MB)
    if (file.size > 5 * 1024 * 1024) {
      showError('Image must be less than 5MB');
      return;
    }

    // Read file and open cropper
    const reader = new FileReader();
    reader.onload = () => {
      setImageSrc(reader.result as string);
    };
    reader.readAsDataURL(file);

    // Reset input so same file can be selected again
    e.target.value = '';
  };

  const handleCropComplete = async (blob: Blob) => {
    setImageSrc(null);

    try {
      await uploadAvatar(blob);
      showSuccess('Avatar updated');
    } catch (error) {
      showError(error instanceof Error ? error.message : 'Upload failed');
    }
  };

  const handleDelete = async () => {
    try {
      await deleteAvatar();
      showSuccess('Avatar removed');
    } catch (error) {
      showError(error instanceof Error ? error.message : 'Delete failed');
    }
  };

  if (!user) return null;

  return (
    <div className="flex flex-col items-center gap-4">
      {/* Current avatar */}
      <AvatarDisplay userId={user.id.toString()} size="large" className="h-24 w-24" />

      {/* Actions */}
      <div className="flex gap-2">
        <input
          ref={inputRef}
          type="file"
          accept="image/*"
          onChange={handleFileSelect}
          className="hidden"
        />

        <Button
          variant="outline"
          size="sm"
          onClick={() => inputRef.current?.click()}
          disabled={isUploading}
        >
          {isUploading ? (
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
          ) : (
            <Camera className="h-4 w-4 mr-2" />
          )}
          Change Avatar
        </Button>

        <Button
          variant="outline"
          size="sm"
          onClick={handleDelete}
          disabled={isUploading}
        >
          <Trash2 className="h-4 w-4 mr-2" />
          Remove
        </Button>
      </div>

      {/* Cropper modal */}
      {imageSrc && (
        <AvatarCropper
          imageSrc={imageSrc}
          onComplete={handleCropComplete}
          onCancel={() => setImageSrc(null)}
        />
      )}
    </div>
  );
}
```

2. Create `frontend/src/components/avatar/AvatarDisplay.tsx`:

```typescript
import { useEffect } from 'react';
import { useAvatarStore } from '@/stores/avatarStore';
import { avatarApi } from '@/lib/api';
import { User } from 'lucide-react';
import { cn } from '@/lib/utils';

interface AvatarDisplayProps {
  userId: string;
  size?: 'tiny' | 'small' | 'large';
  className?: string;
  showStatus?: boolean;
  status?: 'online' | 'away' | 'dnd' | 'offline';
}

const sizeClasses = {
  tiny: 'h-6 w-6',
  small: 'h-8 w-8',
  large: 'h-16 w-16',
};

const statusColors = {
  online: 'bg-green-500',
  away: 'bg-yellow-500',
  dnd: 'bg-red-500',
  offline: 'bg-gray-400',
};

export function AvatarDisplay({
  userId,
  size = 'small',
  className,
  showStatus = false,
  status = 'offline',
}: AvatarDisplayProps) {
  const { avatarCache, fetchAvatar } = useAvatarStore();

  // Fetch avatar on mount if not cached
  useEffect(() => {
    if (!avatarCache.has(userId)) {
      fetchAvatar(userId);
    }
  }, [userId, avatarCache, fetchAvatar]);

  const avatarUrls = avatarCache.get(userId);
  const avatarUrl = avatarUrls ? avatarApi.getUrl(userId, size) : null;

  return (
    <div className={cn('relative inline-block', className)}>
      <div
        className={cn(
          'rounded-full overflow-hidden bg-muted flex items-center justify-center',
          sizeClasses[size]
        )}
      >
        {avatarUrl ? (
          <img
            src={avatarUrl}
            alt="Avatar"
            className="h-full w-full object-cover"
            onError={(e) => {
              // Hide broken image, show fallback
              e.currentTarget.style.display = 'none';
            }}
          />
        ) : (
          <User className={cn(
            'text-muted-foreground',
            size === 'tiny' ? 'h-3 w-3' : size === 'small' ? 'h-4 w-4' : 'h-8 w-8'
          )} />
        )}
      </div>

      {/* Status indicator */}
      {showStatus && (
        <div
          className={cn(
            'absolute bottom-0 right-0 rounded-full border-2 border-background',
            statusColors[status],
            size === 'tiny' ? 'h-2 w-2' : size === 'small' ? 'h-2.5 w-2.5' : 'h-4 w-4'
          )}
        />
      )}
    </div>
  );
}
```

3. Create `frontend/src/components/avatar/index.ts`:

```typescript
export { AvatarCropper } from './AvatarCropper';
export { AvatarUpload } from './AvatarUpload';
export { AvatarDisplay } from './AvatarDisplay';
```
  </action>
  <verify>Run `npm run build` to verify all components compile</verify>
  <done>Avatar upload, cropper, and display components created</done>
</task>

</tasks>

<verification>
1. File input triggers cropper modal with selected image
2. Cropper allows drag/pan and zoom with slider
3. Save uploads cropped image to server
4. AvatarDisplay shows user avatar or placeholder
5. Status indicator appears when showStatus=true
6. Avatar cache prevents redundant fetches
</verification>

<success_criteria>
- react-easy-crop integrated with round crop shape
- Upload creates proper JPEG blob
- Display component shows avatars at 3 sizes
- Status indicator overlay works
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-05-SUMMARY.md`
</output>
