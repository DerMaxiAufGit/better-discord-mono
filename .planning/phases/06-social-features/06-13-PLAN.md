---
phase: 06-social-features
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/presence/VisibilityList.tsx
  - frontend/src/components/messaging/MessageList.tsx
  - backend/src/services/friendService.ts
  - backend/src/services/blockService.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Whitelisted friends see invisible user as Online with status indicator"
    - "Blocked user messages hidden live in groups without refresh"
    - "Unblock automatically restores friendship for immediate messaging"
  artifacts:
    - path: "frontend/src/components/presence/VisibilityList.tsx"
      provides: "Visibility list with correct property access"
      contains: "f.oderId"
    - path: "frontend/src/components/messaging/MessageList.tsx"
      provides: "Message list with reactive block filtering"
      contains: "blockedIds"
    - path: "backend/src/services/friendService.ts"
      provides: "Friend service with restoreFriendship method"
      exports: ["restoreFriendship"]
    - path: "backend/src/services/blockService.ts"
      provides: "Block service using restoreFriendship"
      contains: "restoreFriendship"
  key_links:
    - from: "frontend/src/components/presence/VisibilityList.tsx"
      to: "friendsApi.getFriends()"
      via: "f.oderId property access"
      pattern: "f\\.oderId"
    - from: "frontend/src/components/messaging/MessageList.tsx"
      to: "useBlockStore"
      via: "blockedIds state subscription"
      pattern: "blockedIds"
    - from: "backend/src/services/blockService.ts"
      to: "friendService.restoreFriendship"
      via: "unblock auto-restore"
      pattern: "restoreFriendship"
---

<objective>
Fix 3 diagnosed UAT gaps in Phase 06 Social Features:
1. Invisible whitelist typo preventing friend selection
2. Blocked messages not hiding live due to Zustand subscription issue
3. Unblock not auto-restoring friendship due to wrong method call

Purpose: Close remaining UAT gaps so all social features work correctly.
Output: Fixed components and services passing all UAT criteria.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/components/presence/VisibilityList.tsx
@frontend/src/components/messaging/MessageList.tsx
@frontend/src/stores/blockStore.ts
@backend/src/services/friendService.ts
@backend/src/services/blockService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix VisibilityList property typo</name>
  <files>frontend/src/components/presence/VisibilityList.tsx</files>
  <action>
On line 36, change `f.otherId` to `f.oderId`.

The `FriendWithUser` interface in `friendService.ts` defines the property as `oderId` (the "other" user's ID),
but VisibilityList.tsx mistakenly uses `otherId`. This typo causes the visibility list to be populated with
undefined values, breaking the invisible mode whitelist feature.

Change:
```typescript
const friendsList = response.friends.map((f: any) => ({
  id: f.otherId,  // WRONG
  username: f.username,
}));
```

To:
```typescript
const friendsList = response.friends.map((f: any) => ({
  id: f.oderId,  // CORRECT - matches FriendWithUser interface
  username: f.username,
}));
```
  </action>
  <verify>
1. `grep -n "f.oderId" frontend/src/components/presence/VisibilityList.tsx` shows line 36
2. `grep -n "f.otherId" frontend/src/components/presence/VisibilityList.tsx` returns no results
3. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>VisibilityList correctly maps friend IDs using f.oderId property</done>
</task>

<task type="auto">
  <name>Task 2: Fix MessageList Zustand subscription for live block updates</name>
  <files>frontend/src/components/messaging/MessageList.tsx</files>
  <action>
The issue is that line 79 extracts only the `isBlocked` function:
```typescript
const { isBlocked } = useBlockStore();
```

The `isBlocked` function internally calls `get().blockedIds.has(userId)`, but because we're only extracting
the function (not the state), the component doesn't re-render when `blockedIds` changes. The function
reference stays stable even when the Set updates.

Fix by also subscribing to `blockedIds` state to trigger re-renders:
```typescript
const { blockedIds, isBlocked } = useBlockStore();
```

The component will now re-render when blockedIds changes because:
1. Zustand tracks which state properties are accessed
2. When blockedIds Set is replaced (on block/unblock), the reference changes
3. This triggers a re-render, and isBlocked will return updated values

Note: We need blockedIds in scope even if not directly used in JSX - its presence in the
destructuring causes Zustand to subscribe to its changes.
  </action>
  <verify>
1. `grep -n "blockedIds, isBlocked" frontend/src/components/messaging/MessageList.tsx` shows the updated line
2. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>MessageList subscribes to blockedIds state, triggering re-renders when users are blocked/unblocked</done>
</task>

<task type="auto">
  <name>Task 3: Add restoreFriendship method and fix unblock auto-restore</name>
  <files>backend/src/services/friendService.ts, backend/src/services/blockService.ts</files>
  <action>
**In friendService.ts**, add a new method `restoreFriendship` that creates an accepted friendship directly
(bypassing the pending request flow). Add after the `removeFriend` method (around line 105):

```typescript
/**
 * Restore a friendship directly (used when unblocking)
 * Creates an accepted friend_request record without requiring acceptance
 */
async restoreFriendship(userId1: string, userId2: string): Promise<void> {
  // Check if friendship already exists
  const existing = await query(
    `SELECT * FROM friend_requests
     WHERE (requester_id = $1 AND addressee_id = $2)
        OR (requester_id = $2 AND addressee_id = $1)`,
    [userId1, userId2]
  );

  if (existing.rows.length > 0) {
    const req = existing.rows[0];
    if (req.status === 'accepted') {
      return; // Already friends
    }
    // Update existing record to accepted
    await query(
      `UPDATE friend_requests
       SET status = 'accepted', updated_at = NOW()
       WHERE id = $1`,
      [req.id]
    );
    return;
  }

  // Create new accepted friendship
  await query(
    `INSERT INTO friend_requests (requester_id, addressee_id, status)
     VALUES ($1, $2, 'accepted')`,
    [userId1, userId2]
  );
}
```

**In blockService.ts**, update `unblockUser` method (line 51) to use `restoreFriendship` instead of `sendRequest`:

Change:
```typescript
await friendService.sendRequest(blockerId, blockedId);
```

To:
```typescript
await friendService.restoreFriendship(blockerId, blockedId);
```

This ensures unblocking immediately restores the friendship as accepted, allowing immediate messaging
without requiring the other user to accept a new friend request.
  </action>
  <verify>
1. `grep -n "restoreFriendship" backend/src/services/friendService.ts` shows the new method
2. `grep -n "restoreFriendship" backend/src/services/blockService.ts` shows it's being called
3. TypeScript compiles without errors: `cd backend && npx tsc --noEmit`
  </verify>
  <done>Unblocking a user immediately restores accepted friendship status for instant messaging</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Rebuild containers: `docker compose up -d --build`
2. Test invisible whitelist: Set status to Invisible, whitelist a friend, verify they can see you online
3. Test live block in groups: Block a user while in group chat, verify their messages hide immediately
4. Test unblock restore: Block then unblock a friend, verify you can message them immediately without re-friending
</verification>

<success_criteria>
- VisibilityList correctly loads friend IDs (not undefined)
- MessageList re-renders when blockedIds changes (live hide/show)
- Unblock creates accepted friendship (immediate messaging capability)
- All 3 UAT gaps closed
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-13-SUMMARY.md`
</output>
