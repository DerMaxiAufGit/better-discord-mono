---
phase: 06-social-features
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/src/services/avatarService.ts
  - backend/src/routes/avatars.ts
  - backend/src/server.ts
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "User can upload an avatar image"
    - "Avatar is resized to 3 sizes (32px, 64px, 256px)"
    - "User can delete their avatar"
    - "User can fetch avatar URLs for any user"
  artifacts:
    - path: "backend/src/services/avatarService.ts"
      provides: "Avatar upload, resize, delete logic"
      exports: ["avatarService"]
    - path: "backend/src/routes/avatars.ts"
      provides: "REST routes for avatar CRUD"
      exports: ["default"]
  key_links:
    - from: "backend/src/routes/avatars.ts"
      to: "backend/src/services/avatarService.ts"
      via: "avatarService import"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/avatars.ts"
      via: "fastify.register(avatarRoutes)"
---

<objective>
Create backend avatar service with Sharp for image processing and REST routes for upload/delete.

Purpose: Enable users to upload profile avatars with automatic multi-size generation
Output: Avatar service generating 3 WebP sizes, REST routes for upload/delete/fetch
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-social-features/06-CONTEXT.md
@.planning/phases/06-social-features/06-RESEARCH.md
@.planning/phases/06-social-features/06-01-SUMMARY.md
@backend/src/server.ts
@backend/src/services/fileService.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sharp and create avatar service</name>
  <files>backend/package.json, backend/src/services/avatarService.ts</files>
  <action>
1. Install Sharp in backend:
```bash
cd backend && npm install sharp
```

2. Create `backend/src/services/avatarService.ts`:

```typescript
import sharp from 'sharp';
import fs from 'fs/promises';
import path from 'path';
import { query } from '../db/index.js';
import type { Avatar } from '../db/schema.js';

const AVATAR_DIR = process.env.AVATAR_DIR || './data/avatars';
const SIZES = {
  tiny: 32,
  small: 64,
  large: 256
};

class AvatarService {
  /**
   * Generate 3 avatar sizes from uploaded image and save to disk
   */
  async uploadAvatar(userId: string, imageBuffer: Buffer): Promise<Avatar> {
    // Validate image with Sharp
    const metadata = await sharp(imageBuffer, { limitInputPixels: 16777216 }).metadata();
    if (!metadata.width || !metadata.height) {
      throw new Error('Invalid image file');
    }
    if (metadata.width > 4096 || metadata.height > 4096) {
      throw new Error('Image dimensions too large (max 4096x4096)');
    }

    // Create user avatar directory
    const userDir = path.join(AVATAR_DIR, userId);
    await fs.mkdir(userDir, { recursive: true });

    // Generate 3 sizes in parallel as WebP
    const [tinyPath, smallPath, largePath] = await Promise.all([
      this.resizeAndSave(imageBuffer, userDir, 'tiny', SIZES.tiny),
      this.resizeAndSave(imageBuffer, userDir, 'small', SIZES.small),
      this.resizeAndSave(imageBuffer, userDir, 'large', SIZES.large),
    ]);

    // Upsert avatar record in database
    const result = await query(
      `INSERT INTO avatars (user_id, tiny_path, small_path, large_path, updated_at)
       VALUES ($1, $2, $3, $4, NOW())
       ON CONFLICT (user_id) DO UPDATE
       SET tiny_path = $2, small_path = $3, large_path = $4, updated_at = NOW()
       RETURNING *`,
      [userId, tinyPath, smallPath, largePath]
    );

    return this.mapRow(result.rows[0]);
  }

  /**
   * Resize image to square and save as WebP
   */
  private async resizeAndSave(
    buffer: Buffer,
    dir: string,
    sizeName: string,
    size: number
  ): Promise<string> {
    const filename = `${sizeName}.webp`;
    const filepath = path.join(dir, filename);

    await sharp(buffer)
      .resize(size, size, { fit: 'cover', position: 'center' })
      .webp({ quality: sizeName === 'large' ? 90 : 85 })
      .toFile(filepath);

    return filepath;
  }

  /**
   * Get avatar record for user (null if no avatar)
   */
  async getAvatar(userId: string): Promise<Avatar | null> {
    const result = await query(
      `SELECT * FROM avatars WHERE user_id = $1`,
      [userId]
    );
    return result.rows[0] ? this.mapRow(result.rows[0]) : null;
  }

  /**
   * Delete avatar (files and database record)
   */
  async deleteAvatar(userId: string): Promise<void> {
    // Delete files
    const userDir = path.join(AVATAR_DIR, userId);
    await fs.rm(userDir, { recursive: true, force: true });

    // Delete database record
    await query(`DELETE FROM avatars WHERE user_id = $1`, [userId]);
  }

  /**
   * Get avatar URL for user and size
   * Returns null if user has no avatar
   */
  getAvatarUrl(userId: string, size: 'tiny' | 'small' | 'large'): string {
    return `/api/avatars/${userId}/${size}`;
  }

  /**
   * Get avatar file path for serving
   */
  async getAvatarPath(userId: string, size: 'tiny' | 'small' | 'large'): Promise<string | null> {
    const avatar = await this.getAvatar(userId);
    if (!avatar) return null;

    switch (size) {
      case 'tiny': return avatar.tiny_path;
      case 'small': return avatar.small_path;
      case 'large': return avatar.large_path;
    }
  }

  private mapRow(row: any): Avatar {
    return {
      id: row.id,
      user_id: row.user_id,
      tiny_path: row.tiny_path,
      small_path: row.small_path,
      large_path: row.large_path,
      created_at: row.created_at,
      updated_at: row.updated_at,
    };
  }
}

export const avatarService = new AvatarService();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>Avatar service created with Sharp integration, generates 3 WebP sizes</done>
</task>

<task type="auto">
  <name>Task 2: Create avatar REST routes</name>
  <files>backend/src/routes/avatars.ts</files>
  <action>
Create `backend/src/routes/avatars.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { avatarService } from '../services/avatarService.js';
import fs from 'fs/promises';

const avatarRoutes: FastifyPluginAsync = async (fastify) => {
  // Upload avatar (requires auth)
  fastify.post('/', {
    preValidation: [fastify.authenticate],
  }, async (request, reply) => {
    const userId = (request.user as { userId: string }).userId;

    // Get multipart file
    const data = await request.file();
    if (!data) {
      return reply.code(400).send({ error: 'No file uploaded' });
    }

    // Validate mime type
    if (!data.mimetype.startsWith('image/')) {
      return reply.code(400).send({ error: 'File must be an image' });
    }

    // Convert to buffer
    const buffer = await data.toBuffer();

    // Validate file size (5MB max)
    if (buffer.length > 5 * 1024 * 1024) {
      return reply.code(400).send({ error: 'File too large (max 5MB)' });
    }

    try {
      const avatar = await avatarService.uploadAvatar(userId, buffer);
      return {
        avatar: {
          id: avatar.id,
          tinyUrl: avatarService.getAvatarUrl(userId, 'tiny'),
          smallUrl: avatarService.getAvatarUrl(userId, 'small'),
          largeUrl: avatarService.getAvatarUrl(userId, 'large'),
        }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Upload failed';
      return reply.code(400).send({ error: message });
    }
  });

  // Delete avatar (requires auth)
  fastify.delete('/', {
    preValidation: [fastify.authenticate],
  }, async (request, reply) => {
    const userId = (request.user as { userId: string }).userId;
    await avatarService.deleteAvatar(userId);
    return reply.code(204).send();
  });

  // Get avatar URLs for user (public endpoint)
  fastify.get('/:userId', async (request, reply) => {
    const { userId } = request.params as { userId: string };
    const avatar = await avatarService.getAvatar(userId);

    if (!avatar) {
      return { avatar: null };
    }

    return {
      avatar: {
        tinyUrl: avatarService.getAvatarUrl(userId, 'tiny'),
        smallUrl: avatarService.getAvatarUrl(userId, 'small'),
        largeUrl: avatarService.getAvatarUrl(userId, 'large'),
      }
    };
  });

  // Serve avatar image (public endpoint with caching)
  fastify.get('/:userId/:size', async (request, reply) => {
    const { userId, size } = request.params as { userId: string; size: string };

    if (!['tiny', 'small', 'large'].includes(size)) {
      return reply.code(400).send({ error: 'Invalid size' });
    }

    const filepath = await avatarService.getAvatarPath(userId, size as 'tiny' | 'small' | 'large');
    if (!filepath) {
      return reply.code(404).send({ error: 'Avatar not found' });
    }

    try {
      const file = await fs.readFile(filepath);
      return reply
        .header('Content-Type', 'image/webp')
        .header('Cache-Control', 'public, max-age=86400')  // 24h cache
        .send(file);
    } catch {
      return reply.code(404).send({ error: 'Avatar not found' });
    }
  });
};

export default avatarRoutes;
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify routes compile</verify>
  <done>Avatar routes created with POST upload, DELETE, GET URLs, GET image endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register avatar routes and configure multipart</name>
  <files>backend/src/server.ts</files>
  <action>
1. Import and register avatar routes in server.ts:

Add import near top:
```typescript
import avatarRoutes from './routes/avatars.js';
```

Register route after existing routes (before WebSocket):
```typescript
// Avatar routes
fastify.register(avatarRoutes, { prefix: '/api/avatars' });
```

2. Ensure multipart is configured (should already exist from Phase 5 file uploads):
```typescript
import multipart from '@fastify/multipart';

// In server setup (if not already present):
await fastify.register(multipart, {
  limits: {
    fileSize: 5 * 1024 * 1024,  // 5MB max for avatars
    files: 1
  }
});
```

3. Create data/avatars directory in Docker volume (update docker-compose.yml if needed):
Add volume mapping:
```yaml
volumes:
  - ./data/avatars:/app/data/avatars
```
  </action>
  <verify>Start backend with `docker compose up -d --build backend` and check logs for startup errors</verify>
  <done>Avatar routes registered at /api/avatars, multipart configured, volume mounted</done>
</task>

</tasks>

<verification>
1. POST /api/avatars with image file uploads and returns avatar URLs
2. GET /api/avatars/:userId returns avatar URLs or null
3. GET /api/avatars/:userId/small serves WebP image with correct headers
4. DELETE /api/avatars removes files and database record
5. Sharp generates 3 sizes: 32px, 64px, 256px
</verification>

<success_criteria>
- Avatar upload creates 3 WebP files on disk
- Avatar URLs return correct paths
- Large images (>4096px) rejected
- Non-image files rejected
- 5MB file size limit enforced
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-social-features/06-02-SUMMARY.md`
</output>
