---
phase: 02-e2e-encrypted-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - postgres/init.sql
  - backend/package.json
  - backend/src/server.ts
  - backend/src/routes/websocket.ts
  - backend/src/middleware/wsAuth.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket connections require valid JWT authentication"
    - "Messages table exists with sender, recipient, encrypted content, timestamps"
    - "Users table stores public key for E2E encryption"
  artifacts:
    - path: "postgres/init.sql"
      provides: "messages table schema, public_key column on users"
      contains: "CREATE TABLE messages"
    - path: "backend/src/routes/websocket.ts"
      provides: "WebSocket route with authentication"
      exports: "default (Fastify plugin)"
    - path: "backend/src/middleware/wsAuth.ts"
      provides: "JWT verification for WebSocket connections"
      exports: "wsAuthHook"
  key_links:
    - from: "backend/src/server.ts"
      to: "backend/src/routes/websocket.ts"
      via: "fastify.register()"
      pattern: "register.*websocket"
    - from: "backend/src/routes/websocket.ts"
      to: "backend/src/middleware/wsAuth.ts"
      via: "preValidation hook"
      pattern: "addHook.*preValidation"
---

<objective>
Create the database schema for encrypted messaging and establish WebSocket infrastructure with JWT authentication.

Purpose: Foundation for real-time encrypted message delivery - messages table stores encrypted content, WebSocket enables instant delivery
Output: Database migrations, @fastify/websocket registered, authenticated WebSocket endpoint at /ws
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md

# Existing codebase references
@backend/src/server.ts
@backend/src/routes/auth.ts
@backend/package.json
@postgres/init.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema for messaging</name>
  <files>postgres/init.sql</files>
  <action>
Add to the existing init.sql file:

1. Add public_key column to users table:
   - Column: public_key TEXT (nullable, set after key generation)
   - This stores the user's X25519 public key (base64 encoded)

2. Create messages table:
   - id: SERIAL PRIMARY KEY
   - sender_id: UUID REFERENCES users(id) NOT NULL
   - recipient_id: UUID REFERENCES users(id) NOT NULL
   - encrypted_content: TEXT NOT NULL (client-encrypted, base64)
   - created_at: TIMESTAMPTZ DEFAULT NOW()
   - delivered_at: TIMESTAMPTZ (null until delivered via WebSocket)
   - read_at: TIMESTAMPTZ (null until marked read)

3. Create indexes:
   - idx_messages_sender_id on messages(sender_id)
   - idx_messages_recipient_id on messages(recipient_id)
   - idx_messages_conversation on messages(sender_id, recipient_id, created_at)

NOTE: The encrypted_content is already E2E encrypted by the client. The server cannot decrypt it. We do NOT use pgcrypto for additional encryption (simplifies v1, can add later if needed).
  </action>
  <verify>Check SQL syntax is valid by reviewing the file structure</verify>
  <done>users table has public_key column, messages table exists with all fields and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Install @fastify/websocket and create auth middleware</name>
  <files>backend/package.json, backend/src/middleware/wsAuth.ts</files>
  <action>
1. Install @fastify/websocket:
   ```bash
   cd backend && npm install @fastify/websocket
   ```

2. Create backend/src/middleware/wsAuth.ts:
   - Export wsAuthHook function for Fastify preValidation
   - Extract JWT from query parameter (WebSocket can't use headers easily)
   - Verify token using fastify.jwt.verify()
   - Attach decoded user to request.user
   - Return 401 if token invalid or missing

Pattern from research:
```typescript
export const wsAuthHook = async (request: FastifyRequest, reply: FastifyReply) => {
  try {
    // WebSocket connections pass token as query parameter
    const token = (request.query as { token?: string }).token;
    if (!token) {
      return reply.code(401).send({ error: 'Missing authentication token' });
    }

    // Verify and decode JWT
    const decoded = await request.server.jwt.verify(token);
    request.user = decoded;
  } catch (err) {
    return reply.code(401).send({ error: 'Invalid authentication token' });
  }
};
```

Add TypeScript type augmentation for request.user if not already present.
  </action>
  <verify>npm run build compiles without errors in backend</verify>
  <done>@fastify/websocket installed, wsAuth middleware exports wsAuthHook function that verifies JWT from query param</done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket route with authentication</name>
  <files>backend/src/routes/websocket.ts, backend/src/server.ts</files>
  <action>
1. Create backend/src/routes/websocket.ts:
   - Import @fastify/websocket types
   - Import wsAuthHook from middleware
   - Export default Fastify plugin
   - Register preValidation hook with wsAuthHook
   - Create GET /ws route with { websocket: true } option
   - In connection handler:
     - Get userId from request.user
     - Store connection in a Map (userId -> WebSocket)
     - Log connection: "User {userId} connected"
     - Handle 'message' event (log for now, actual handling in Plan 03)
     - Handle 'close' event (remove from Map, log disconnection)
     - Handle 'error' event (log error)

2. Update backend/src/server.ts:
   - Import @fastify/websocket plugin
   - Register websocket plugin BEFORE routes: await fastify.register(websocket)
   - Import and register websocket routes: await fastify.register(wsRoutes, { prefix: '/api' })

Connection storage pattern:
```typescript
const activeConnections = new Map<string, WebSocket>();

// In handler:
activeConnections.set(userId, socket);
socket.on('close', () => activeConnections.delete(userId));
```

Export activeConnections so message service can use it later.
  </action>
  <verify>npm run build compiles without TypeScript errors</verify>
  <done>WebSocket route at /api/ws requires JWT in query param, stores connections by userId, logs connect/disconnect</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database schema verification:
   - postgres/init.sql contains ALTER TABLE users ADD COLUMN public_key
   - postgres/init.sql contains CREATE TABLE messages with all required columns
   - Indexes defined for message queries

2. WebSocket infrastructure verification:
   - @fastify/websocket in backend/package.json dependencies
   - wsAuth.ts exports wsAuthHook function
   - websocket.ts exports default plugin and activeConnections
   - server.ts registers websocket plugin and routes

3. Build verification:
   - npm run build in backend succeeds without errors
</verification>

<success_criteria>
- Database schema extended with public_key and messages table
- WebSocket plugin registered in Fastify
- WebSocket connections authenticated via JWT query parameter
- Active connections tracked in Map for message routing
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-01-SUMMARY.md`
</output>
