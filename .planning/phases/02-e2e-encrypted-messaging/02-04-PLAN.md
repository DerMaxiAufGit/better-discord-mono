---
phase: 02-e2e-encrypted-messaging
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - frontend/src/stores/cryptoStore.ts
  - frontend/src/stores/messageStore.ts
  - frontend/src/stores/contactStore.ts
  - frontend/src/lib/websocket/useMessaging.ts
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User's keypair is generated and stored on first login"
    - "Session keys are derived for each contact"
    - "Messages are encrypted before sending via WebSocket"
    - "Incoming messages are decrypted and stored in state"
    - "WebSocket reconnects automatically on disconnect"
  artifacts:
    - path: "frontend/src/stores/cryptoStore.ts"
      provides: "Key pair and session keys state management"
      exports: "useCryptoStore"
    - path: "frontend/src/stores/messageStore.ts"
      provides: "Message state management"
      exports: "useMessageStore"
    - path: "frontend/src/stores/contactStore.ts"
      provides: "Contact list state management"
      exports: "useContactStore"
    - path: "frontend/src/lib/websocket/useMessaging.ts"
      provides: "WebSocket hook for encrypted messaging"
      exports: "useMessaging"
  key_links:
    - from: "frontend/src/lib/websocket/useMessaging.ts"
      to: "frontend/src/stores/cryptoStore.ts"
      via: "import useCryptoStore"
      pattern: "useCryptoStore"
    - from: "frontend/src/lib/websocket/useMessaging.ts"
      to: "frontend/src/lib/crypto/messageEncryption.ts"
      via: "import encrypt/decrypt"
      pattern: "encryptMessage|decryptMessage"
    - from: "frontend/src/stores/messageStore.ts"
      to: "frontend/src/lib/api.ts"
      via: "API calls for history"
      pattern: "messageApi"
    - from: "frontend/src/stores/cryptoStore.ts"
      to: "frontend/src/lib/crypto/keyExchange.ts"
      via: "session key derivation with role-based direction"
      pattern: "deriveSessionKeys.*isClient"
      note: "CRITICAL: User A's tx key MUST equal User B's rx key for bidirectional encryption. The isClient flag (userId < contactId) ensures deterministic role assignment. Verify in 02-06 checkpoint that both users can decrypt each other's messages."
---

<objective>
Create frontend state management for cryptographic keys, messages, and contacts, plus WebSocket hook for real-time encrypted messaging.

Purpose: Manage client-side encryption state and enable real-time encrypted message exchange
Output: Zustand stores for crypto/messages/contacts, WebSocket hook with automatic encryption/decryption
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md
@.planning/phases/02-e2e-encrypted-messaging/02-02-SUMMARY.md
@.planning/phases/02-e2e-encrypted-messaging/02-03-SUMMARY.md

# Existing codebase references
@frontend/src/stores/auth.ts
@frontend/src/lib/api.ts
@frontend/src/lib/crypto/keyManager.ts
@frontend/src/lib/crypto/messageEncryption.ts
@frontend/src/lib/crypto/keyExchange.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crypto store and extend API client</name>
  <files>frontend/src/stores/cryptoStore.ts, frontend/src/lib/api.ts</files>
  <action>
1. Extend frontend/src/lib/api.ts to add key and message API methods:

```typescript
// Add to existing api.ts file

export const keyApi = {
  // Upload current user's public key
  setPublicKey: async (publicKey: string): Promise<void> => {
    await apiFetch('/api/keys', {
      method: 'POST',
      body: JSON.stringify({ publicKey }),
    });
  },

  // Get another user's public key
  getPublicKey: async (userId: string): Promise<string | null> => {
    try {
      const response = await apiFetch(`/api/keys/${userId}`);
      return response.publicKey;
    } catch (e) {
      if ((e as Error).message.includes('404')) return null;
      throw e;
    }
  },
};

export const messageApi = {
  // Get message history with a contact
  getHistory: async (contactId: string, limit?: number, beforeId?: number) => {
    const params = new URLSearchParams();
    if (limit) params.set('limit', limit.toString());
    if (beforeId) params.set('beforeId', beforeId.toString());
    const query = params.toString() ? `?${params.toString()}` : '';
    return apiFetch(`/api/messages/${contactId}${query}`);
  },

  // Mark messages as read
  markRead: async (contactId: string): Promise<void> => {
    await apiFetch(`/api/messages/${contactId}/read`, { method: 'POST' });
  },
};
```

2. Create frontend/src/stores/cryptoStore.ts:

```typescript
import { create } from 'zustand';
import { generateKeyPair, storeKeyPair, getKeyPair, hasStoredKeys } from '@/lib/crypto/keyManager';
import { deriveSessionKeys } from '@/lib/crypto/keyExchange';
import { keyApi } from '@/lib/api';

interface KeyPair {
  publicKey: string;
  privateKey: string;
}

interface SessionKeys {
  rx: Uint8Array;
  tx: Uint8Array;
}

interface CryptoState {
  keyPair: KeyPair | null;
  sessionKeys: Map<string, SessionKeys>;
  isInitialized: boolean;

  // Actions
  initializeKeys: (userId: string) => Promise<void>;
  getOrDeriveSessionKeys: (userId: string, contactId: string, contactPublicKey: string) => Promise<SessionKeys>;
  clearKeys: () => void;
}

export const useCryptoStore = create<CryptoState>((set, get) => ({
  keyPair: null,
  sessionKeys: new Map(),
  isInitialized: false,

  initializeKeys: async (userId: string) => {
    // Check if keys already exist in IndexedDB
    const hasKeys = await hasStoredKeys(userId);

    let keyPair: KeyPair;
    if (hasKeys) {
      keyPair = await getKeyPair(userId);
    } else {
      // Generate new keypair
      keyPair = await generateKeyPair();
      await storeKeyPair(userId, keyPair);
      // Upload public key to server
      await keyApi.setPublicKey(keyPair.publicKey);
    }

    set({ keyPair, isInitialized: true });
  },

  getOrDeriveSessionKeys: async (userId: string, contactId: string, contactPublicKey: string) => {
    const { keyPair, sessionKeys } = get();
    if (!keyPair) throw new Error('Keys not initialized');

    // Check cache first
    const cached = sessionKeys.get(contactId);
    if (cached) return cached;

    // Determine who is "client" role (lower userId lexicographically)
    // CRITICAL: crypto_kx guarantees bidirectional symmetry:
    //   - User A (client, lower ID): encrypts with tx, decrypts with rx
    //   - User B (server, higher ID): encrypts with tx, decrypts with rx
    //   - crypto_kx ensures: client.tx == server.rx AND client.rx == server.tx
    // This means when A sends to B:
    //   A encrypts with A.tx -> B decrypts with B.rx (B.rx == A.tx)
    // And when B sends to A:
    //   B encrypts with B.tx -> A decrypts with A.rx (A.rx == B.tx)
    const isClient = userId < contactId;

    const keys = await deriveSessionKeys(
      keyPair.publicKey,
      keyPair.privateKey,
      contactPublicKey,
      isClient
    );

    // Cache session keys
    set((state) => ({
      sessionKeys: new Map(state.sessionKeys).set(contactId, keys),
    }));

    return keys;
  },

  clearKeys: () => {
    set({ keyPair: null, sessionKeys: new Map(), isInitialized: false });
  },
}));
```

NOTE: Session keys are cached per contact. The isClient flag (based on lexicographic userId comparison) ensures deterministic role assignment. crypto_kx guarantees that client.tx == server.rx and client.rx == server.tx, enabling bidirectional encryption/decryption.
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>cryptoStore manages keypair and session keys; api.ts exports keyApi and messageApi</done>
</task>

<task type="auto">
  <name>Task 2: Create message store and contact store</name>
  <files>frontend/src/stores/messageStore.ts, frontend/src/stores/contactStore.ts</files>
  <action>
1. Create frontend/src/stores/contactStore.ts:

```typescript
import { create } from 'zustand';
import { keyApi } from '@/lib/api';

interface Contact {
  id: string;
  email: string;
  publicKey: string | null;
  lastMessageAt?: Date;
}

interface ContactState {
  contacts: Map<string, Contact>;
  activeContactId: string | null;

  // Actions
  addContact: (contact: Contact) => void;
  setActiveContact: (contactId: string | null) => void;
  fetchContactPublicKey: (contactId: string) => Promise<string | null>;
  getContact: (contactId: string) => Contact | undefined;
}

export const useContactStore = create<ContactState>((set, get) => ({
  contacts: new Map(),
  activeContactId: null,

  addContact: (contact: Contact) => {
    set((state) => ({
      contacts: new Map(state.contacts).set(contact.id, contact),
    }));
  },

  setActiveContact: (contactId: string | null) => {
    set({ activeContactId: contactId });
  },

  fetchContactPublicKey: async (contactId: string) => {
    const contact = get().contacts.get(contactId);
    if (contact?.publicKey) return contact.publicKey;

    const publicKey = await keyApi.getPublicKey(contactId);
    if (publicKey && contact) {
      set((state) => ({
        contacts: new Map(state.contacts).set(contactId, {
          ...contact,
          publicKey,
        }),
      }));
    }
    return publicKey;
  },

  getContact: (contactId: string) => get().contacts.get(contactId),
}));
```

2. Create frontend/src/stores/messageStore.ts:

```typescript
import { create } from 'zustand';
import { messageApi } from '@/lib/api';

interface Message {
  id: number;
  senderId: string;
  recipientId: string;
  content: string; // Decrypted plaintext
  timestamp: Date;
  status: 'sending' | 'sent' | 'delivered' | 'read';
}

interface MessageState {
  // Messages keyed by contact ID
  conversations: Map<string, Message[]>;
  isLoadingHistory: boolean;

  // Actions
  addMessage: (contactId: string, message: Message) => void;
  updateMessageStatus: (contactId: string, messageId: number, status: Message['status']) => void;
  loadHistory: (contactId: string, decrypt: (encrypted: string) => Promise<string | null>) => Promise<void>;
  clearMessages: () => void;
}

export const useMessageStore = create<MessageState>((set, get) => ({
  conversations: new Map(),
  isLoadingHistory: false,

  addMessage: (contactId: string, message: Message) => {
    set((state) => {
      const messages = state.conversations.get(contactId) || [];
      // Avoid duplicates by ID
      if (messages.some((m) => m.id === message.id)) {
        return state;
      }
      return {
        conversations: new Map(state.conversations).set(contactId, [...messages, message]),
      };
    });
  },

  updateMessageStatus: (contactId: string, messageId: number, status: Message['status']) => {
    set((state) => {
      const messages = state.conversations.get(contactId);
      if (!messages) return state;

      const updated = messages.map((m) =>
        m.id === messageId ? { ...m, status } : m
      );
      return {
        conversations: new Map(state.conversations).set(contactId, updated),
      };
    });
  },

  loadHistory: async (contactId: string, decrypt: (encrypted: string) => Promise<string | null>) => {
    set({ isLoadingHistory: true });

    try {
      const { messages: encryptedMessages } = await messageApi.getHistory(contactId, 50);

      const decryptedMessages: Message[] = [];
      for (const msg of encryptedMessages) {
        const content = await decrypt(msg.encryptedContent);
        if (content) {
          decryptedMessages.push({
            id: msg.id,
            senderId: msg.senderId,
            recipientId: msg.recipientId,
            content,
            timestamp: new Date(msg.createdAt),
            status: msg.readAt ? 'read' : msg.deliveredAt ? 'delivered' : 'sent',
          });
        }
      }

      set((state) => ({
        conversations: new Map(state.conversations).set(contactId, decryptedMessages),
        isLoadingHistory: false,
      }));
    } catch (e) {
      console.error('Failed to load message history:', e);
      set({ isLoadingHistory: false });
    }
  },

  clearMessages: () => {
    set({ conversations: new Map() });
  },
}));
```

NOTE: Messages are stored decrypted in memory (Zustand store). The decrypt function is passed in to avoid coupling the store to crypto implementation.
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>messageStore manages decrypted conversations; contactStore manages contacts and public keys</done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket messaging hook</name>
  <files>frontend/src/lib/websocket/useMessaging.ts</files>
  <action>
Create frontend/src/lib/websocket/useMessaging.ts:

```typescript
import { useEffect, useRef, useCallback, useState } from 'react';
import { useAuthStore } from '@/stores/auth';
import { useCryptoStore } from '@/stores/cryptoStore';
import { useMessageStore } from '@/stores/messageStore';
import { useContactStore } from '@/stores/contactStore';
import { encryptMessage, decryptMessage } from '@/lib/crypto/messageEncryption';

interface UseMessagingOptions {
  onError?: (error: Error) => void;
}

export function useMessaging(options: UseMessagingOptions = {}) {
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<number | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  const { accessToken, user } = useAuthStore();
  const { getOrDeriveSessionKeys, isInitialized: cryptoReady } = useCryptoStore();
  const { addMessage, updateMessageStatus } = useMessageStore();
  const { fetchContactPublicKey } = useContactStore();

  // Connect to WebSocket
  const connect = useCallback(() => {
    if (!accessToken || !cryptoReady || !user) return;

    // Determine WebSocket URL (same host, /api/ws path)
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/api/ws?token=${accessToken}`;

    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log('WebSocket connected');
      setIsConnected(true);
    };

    ws.onmessage = async (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.type === 'message') {
          // Incoming message from another user
          const { id, senderId, encryptedContent, timestamp } = data;

          // Get sender's public key and derive session keys
          const publicKey = await fetchContactPublicKey(senderId);
          if (!publicKey) {
            console.error('No public key for sender:', senderId);
            return;
          }

          const sessionKeys = await getOrDeriveSessionKeys(user.id, senderId, publicKey);

          // Decrypt message
          const content = await decryptMessage(encryptedContent, sessionKeys.rx);
          if (content) {
            addMessage(senderId, {
              id,
              senderId,
              recipientId: user.id,
              content,
              timestamp: new Date(timestamp),
              status: 'delivered',
            });
          }
        } else if (data.type === 'message_ack') {
          // Acknowledgment for sent message
          // Message ID is assigned, update status
          // Note: We'd need to track pending messages to update them
          console.log('Message acknowledged:', data.id);
        } else if (data.type === 'error') {
          console.error('WebSocket error:', data.message);
          options.onError?.(new Error(data.message));
        }
      } catch (e) {
        console.error('Failed to process WebSocket message:', e);
      }
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected, reconnecting in 3s...');
      setIsConnected(false);
      wsRef.current = null;

      // Reconnect after delay
      reconnectTimeoutRef.current = window.setTimeout(() => {
        connect();
      }, 3000);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }, [accessToken, cryptoReady, user, fetchContactPublicKey, getOrDeriveSessionKeys, addMessage, options]);

  // Send encrypted message
  const sendMessage = useCallback(async (recipientId: string, plaintext: string) => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected');
    }
    if (!user) throw new Error('Not authenticated');

    // Get recipient's public key
    const publicKey = await fetchContactPublicKey(recipientId);
    if (!publicKey) {
      throw new Error('Recipient has no public key');
    }

    // Derive session keys
    const sessionKeys = await getOrDeriveSessionKeys(user.id, recipientId, publicKey);

    // Encrypt message
    const encryptedContent = await encryptMessage(plaintext, sessionKeys.tx);

    // Add optimistic message to store
    const tempId = -Date.now(); // Temporary negative ID
    addMessage(recipientId, {
      id: tempId,
      senderId: user.id,
      recipientId,
      content: plaintext,
      timestamp: new Date(),
      status: 'sending',
    });

    // Send via WebSocket
    wsRef.current.send(JSON.stringify({
      type: 'message',
      recipientId,
      encryptedContent,
    }));
  }, [user, fetchContactPublicKey, getOrDeriveSessionKeys, addMessage]);

  // Connect on mount, disconnect on unmount
  useEffect(() => {
    connect();

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      wsRef.current?.close();
    };
  }, [connect]);

  return {
    isConnected,
    sendMessage,
  };
}
```

NOTE: The hook handles:
- Automatic connection when authenticated and crypto is ready
- Automatic reconnection on disconnect (3s delay)
- Message encryption/decryption using session keys
- Optimistic UI updates for sent messages
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>useMessaging hook connects WebSocket, encrypts/decrypts messages, manages reconnection</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Store verification:
   - cryptoStore.ts exports useCryptoStore with initializeKeys, getOrDeriveSessionKeys, clearKeys
   - messageStore.ts exports useMessageStore with addMessage, updateMessageStatus, loadHistory
   - contactStore.ts exports useContactStore with addContact, setActiveContact, fetchContactPublicKey

2. API client verification:
   - api.ts exports keyApi with setPublicKey, getPublicKey
   - api.ts exports messageApi with getHistory, markRead

3. WebSocket hook verification:
   - useMessaging.ts exports useMessaging
   - Hook returns isConnected and sendMessage
   - Handles message encryption before send
   - Handles message decryption on receive
   - Implements automatic reconnection

4. Build verification:
   - npm run build succeeds without errors
</verification>

<success_criteria>
- Crypto store initializes and caches keypair and session keys
- Message store holds decrypted conversations
- Contact store manages contact list and public keys
- WebSocket hook encrypts outgoing, decrypts incoming
- Automatic reconnection on disconnect
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-04-SUMMARY.md`
</output>
