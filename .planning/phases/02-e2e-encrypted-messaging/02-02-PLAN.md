---
phase: 02-e2e-encrypted-messaging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/lib/crypto/libsodium.ts
  - frontend/src/lib/crypto/keyManager.ts
  - frontend/src/lib/crypto/messageEncryption.ts
  - frontend/src/lib/crypto/keyExchange.ts
autonomous: true

must_haves:
  truths:
    - "libsodium initializes successfully in browser"
    - "Key pairs can be generated and stored in IndexedDB"
    - "Messages can be encrypted and decrypted with session keys"
    - "Session keys can be derived from key pairs"
  artifacts:
    - path: "frontend/src/lib/crypto/libsodium.ts"
      provides: "Initialized libsodium instance"
      exports: "sodium, initSodium"
    - path: "frontend/src/lib/crypto/keyManager.ts"
      provides: "Key generation, storage, retrieval from IndexedDB"
      exports: "generateKeyPair, storeKeyPair, getKeyPair, hasStoredKeys"
    - path: "frontend/src/lib/crypto/messageEncryption.ts"
      provides: "Message encrypt/decrypt functions"
      exports: "encryptMessage, decryptMessage"
    - path: "frontend/src/lib/crypto/keyExchange.ts"
      provides: "Session key derivation"
      exports: "deriveSessionKeys"
  key_links:
    - from: "frontend/src/lib/crypto/messageEncryption.ts"
      to: "frontend/src/lib/crypto/libsodium.ts"
      via: "import"
      pattern: "from.*libsodium"
    - from: "frontend/src/lib/crypto/keyManager.ts"
      to: "frontend/src/lib/crypto/libsodium.ts"
      via: "import"
      pattern: "from.*libsodium"
---

<objective>
Create the frontend cryptography library using libsodium.js for E2E encryption.

Purpose: Enable client-side encryption so messages are encrypted before leaving the device and only decryptable by the intended recipient
Output: Crypto utilities for key generation, storage, session key derivation, and message encryption/decryption
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md

# Existing codebase references
@frontend/package.json
@frontend/src/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install libsodium and create initialization wrapper</name>
  <files>frontend/package.json, frontend/src/lib/crypto/libsodium.ts</files>
  <action>
1. Install libsodium-wrappers and types:
   ```bash
   cd frontend && npm install libsodium-wrappers @types/libsodium-wrappers
   ```

2. Create frontend/src/lib/crypto/libsodium.ts:
   - Import sodium from 'libsodium-wrappers'
   - Create initSodium() async function that awaits sodium.ready
   - Export both the sodium instance and initSodium function
   - Add a ready flag to prevent multiple initializations

```typescript
import sodium from 'libsodium-wrappers';

let isReady = false;

export async function initSodium(): Promise<typeof sodium> {
  if (!isReady) {
    await sodium.ready;
    isReady = true;
  }
  return sodium;
}

export { sodium };
```

NOTE: libsodium.ready is a Promise that resolves when WASM is loaded. Must await before using any crypto functions.
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>libsodium-wrappers installed, initSodium function exported and initializes sodium correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create key manager with IndexedDB storage</name>
  <files>frontend/src/lib/crypto/keyManager.ts</files>
  <action>
Create frontend/src/lib/crypto/keyManager.ts with:

1. Interface definitions:
   ```typescript
   interface KeyPair {
     publicKey: string;  // base64 encoded
     privateKey: string; // base64 encoded
   }
   ```

2. IndexedDB helper functions:
   - openKeyStore(): Opens 'crypto-keys' database with 'keypairs' object store
   - Use IDBDatabase API directly (no additional library needed)

3. Key management functions:
   - generateKeyPair(): Generate X25519 keypair using sodium.crypto_box_keypair()
   - storeKeyPair(userId: string, keyPair: KeyPair): Store in IndexedDB
   - getKeyPair(userId: string): Retrieve from IndexedDB
   - hasStoredKeys(userId: string): Check if keys exist
   - deleteKeyPair(userId: string): Remove keys (for logout/reset)

Storage pattern:
```typescript
async function openKeyStore(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('crypto-keys', 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains('keypairs')) {
        db.createObjectStore('keypairs');
      }
    };
  });
}
```

Key generation:
```typescript
export async function generateKeyPair(): Promise<KeyPair> {
  const s = await initSodium();
  const keyPair = s.crypto_box_keypair();
  return {
    publicKey: s.to_base64(keyPair.publicKey),
    privateKey: s.to_base64(keyPair.privateKey),
  };
}
```

Export all functions.
  </action>
  <verify>TypeScript compiles without errors (npm run build)</verify>
  <done>keyManager exports generateKeyPair, storeKeyPair, getKeyPair, hasStoredKeys, deleteKeyPair using IndexedDB</done>
</task>

<task type="auto">
  <name>Task 3: Create message encryption and key exchange utilities</name>
  <files>frontend/src/lib/crypto/messageEncryption.ts, frontend/src/lib/crypto/keyExchange.ts</files>
  <action>
1. Create frontend/src/lib/crypto/keyExchange.ts:

Derive symmetric session keys for bidirectional messaging:

```typescript
import { initSodium } from './libsodium';

interface SessionKeys {
  rx: Uint8Array; // Receive key (decrypt incoming)
  tx: Uint8Array; // Transmit key (encrypt outgoing)
}

export async function deriveSessionKeys(
  myPublicKey: string,
  myPrivateKey: string,
  peerPublicKey: string,
  isInitiator: boolean // true if we initiated the conversation
): Promise<SessionKeys> {
  const s = await initSodium();

  const myPub = s.from_base64(myPublicKey);
  const myPriv = s.from_base64(myPrivateKey);
  const peerPub = s.from_base64(peerPublicKey);

  // Client (initiator) and server (responder) derive different key directions
  const keys = isInitiator
    ? s.crypto_kx_client_session_keys(myPub, myPriv, peerPub)
    : s.crypto_kx_server_session_keys(myPub, myPriv, peerPub);

  return {
    rx: keys.sharedRx,
    tx: keys.sharedTx,
  };
}
```

Determine isInitiator by comparing user IDs lexicographically (user with lower ID is client).

2. Create frontend/src/lib/crypto/messageEncryption.ts:

```typescript
import { initSodium } from './libsodium';

export async function encryptMessage(
  plaintext: string,
  sessionKey: Uint8Array
): Promise<string> {
  const s = await initSodium();

  // Generate random nonce (XChaCha20 has 192-bit nonce, safe for random)
  const nonce = s.randombytes_buf(s.crypto_secretbox_NONCEBYTES);
  const message = s.from_string(plaintext);

  // Encrypt with authenticated encryption
  const ciphertext = s.crypto_secretbox_easy(message, nonce, sessionKey);

  // Prepend nonce to ciphertext and encode as base64
  const combined = new Uint8Array(nonce.length + ciphertext.length);
  combined.set(nonce);
  combined.set(ciphertext, nonce.length);

  return s.to_base64(combined);
}

export async function decryptMessage(
  encrypted: string,
  sessionKey: Uint8Array
): Promise<string | null> {
  const s = await initSodium();

  try {
    const data = s.from_base64(encrypted);

    // Extract nonce and ciphertext
    const nonce = data.slice(0, s.crypto_secretbox_NONCEBYTES);
    const ciphertext = data.slice(s.crypto_secretbox_NONCEBYTES);

    // Decrypt and verify authentication tag
    const plaintext = s.crypto_secretbox_open_easy(ciphertext, nonce, sessionKey);
    return s.to_string(plaintext);
  } catch (e) {
    console.error('Decryption failed:', e);
    return null; // Invalid ciphertext or wrong key
  }
}
```

NOTE: Using random nonce per message with XChaCha20's 192-bit nonce is safe (no nonce reuse risk with random generation for reasonable message volumes).
  </action>
  <verify>npm run build compiles without TypeScript errors</verify>
  <done>keyExchange exports deriveSessionKeys, messageEncryption exports encryptMessage and decryptMessage functions</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Dependency verification:
   - libsodium-wrappers in frontend/package.json
   - @types/libsodium-wrappers in frontend/package.json

2. File structure verification:
   - frontend/src/lib/crypto/ directory exists
   - libsodium.ts, keyManager.ts, messageEncryption.ts, keyExchange.ts all exist

3. Export verification:
   - libsodium.ts exports: initSodium, sodium
   - keyManager.ts exports: generateKeyPair, storeKeyPair, getKeyPair, hasStoredKeys, deleteKeyPair
   - messageEncryption.ts exports: encryptMessage, decryptMessage
   - keyExchange.ts exports: deriveSessionKeys

4. Build verification:
   - npm run build succeeds without errors
</verification>

<success_criteria>
- libsodium-wrappers installed and initializable
- Key pairs can be generated (X25519) and stored in IndexedDB
- Session keys derivable from key pairs (crypto_kx)
- Messages encryptable/decryptable with session keys (crypto_secretbox)
- All functions typed and exported
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-02-SUMMARY.md`
</output>
