---
phase: 02-e2e-encrypted-messaging
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/services/keyService.ts
  - backend/src/services/messageService.ts
  - backend/src/routes/keys.ts
  - backend/src/routes/messages.ts
  - backend/src/routes/websocket.ts
  - backend/src/server.ts
  - backend/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Users can upload their public key to the server"
    - "Users can fetch another user's public key"
    - "Messages are persisted to database with encrypted content"
    - "Message history is retrievable via HTTP API"
    - "Messages delivered to online recipients within seconds"
  artifacts:
    - path: "backend/src/services/keyService.ts"
      provides: "Public key CRUD operations"
      exports: "keyService"
    - path: "backend/src/services/messageService.ts"
      provides: "Message persistence and retrieval"
      exports: "messageService"
    - path: "backend/src/routes/keys.ts"
      provides: "Public key API endpoints"
      exports: "default (Fastify plugin)"
    - path: "backend/src/routes/messages.ts"
      provides: "Message history API endpoints"
      exports: "default (Fastify plugin)"
  key_links:
    - from: "backend/src/routes/websocket.ts"
      to: "backend/src/services/messageService.ts"
      via: "import and call"
      pattern: "messageService.*save"
    - from: "backend/src/routes/messages.ts"
      to: "backend/src/services/messageService.ts"
      via: "import and call"
      pattern: "messageService.*getHistory"
---

<objective>
Create backend services for public key management and message persistence, plus API endpoints for key exchange and message history.

Purpose: Enable key discovery between users and provide persistent storage for encrypted messages with history retrieval
Output: Key and message services, REST endpoints for keys and history, WebSocket message handling
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md
@.planning/phases/02-e2e-encrypted-messaging/02-01-SUMMARY.md

# Existing codebase references
@backend/src/server.ts
@backend/src/db/index.ts
@backend/src/types/index.ts
@backend/src/services/auth.service.ts
@backend/src/routes/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create key service and API routes</name>
  <files>backend/src/services/keyService.ts, backend/src/routes/keys.ts, backend/src/types/index.ts, backend/src/server.ts</files>
  <action>
1. Update backend/src/types/index.ts to add:
   ```typescript
   export interface PublicKeyResponse {
     userId: string;
     publicKey: string | null;
   }
   ```

2. Create backend/src/services/keyService.ts:

```typescript
import { query } from '../db/index.js';

class KeyService {
  // Save or update user's public key
  async setPublicKey(userId: string, publicKey: string): Promise<void> {
    await query(
      'UPDATE users SET public_key = $1 WHERE id = $2',
      [publicKey, userId]
    );
  }

  // Get a user's public key
  async getPublicKey(userId: string): Promise<string | null> {
    const result = await query(
      'SELECT public_key FROM users WHERE id = $1',
      [userId]
    );
    return result.rows[0]?.public_key ?? null;
  }

  // Get public keys for multiple users (for batch operations)
  async getPublicKeys(userIds: string[]): Promise<Map<string, string>> {
    const result = await query(
      'SELECT id, public_key FROM users WHERE id = ANY($1) AND public_key IS NOT NULL',
      [userIds]
    );
    const keys = new Map<string, string>();
    for (const row of result.rows) {
      keys.set(row.id, row.public_key);
    }
    return keys;
  }
}

export const keyService = new KeyService();
```

3. Create backend/src/routes/keys.ts:

```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { keyService } from '../services/keyService.js';

interface SetKeyBody {
  publicKey: string;
}

interface GetKeyParams {
  userId: string;
}

export default async function keyRoutes(fastify: FastifyInstance) {
  // Set current user's public key
  fastify.post<{ Body: SetKeyBody }>(
    '/keys',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Body: SetKeyBody }>, reply: FastifyReply) => {
      const userId = (request.user as { userId: string }).userId;
      const { publicKey } = request.body;

      if (!publicKey || typeof publicKey !== 'string') {
        return reply.code(400).send({ error: 'publicKey is required' });
      }

      await keyService.setPublicKey(userId, publicKey);
      return { success: true };
    }
  );

  // Get another user's public key
  fastify.get<{ Params: GetKeyParams }>(
    '/keys/:userId',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Params: GetKeyParams }>, reply: FastifyReply) => {
      const { userId } = request.params;

      const publicKey = await keyService.getPublicKey(userId);
      if (!publicKey) {
        return reply.code(404).send({ error: 'User not found or no public key' });
      }

      return { userId, publicKey };
    }
  );
}
```

4. Add fastify.authenticate decorator in server.ts (if not exists) and register key routes:
   - Add after jwt.register: fastify.decorate('authenticate', async function(request, reply) {...})
   - Register: await fastify.register(keyRoutes, { prefix: '/api' });

NOTE: fastify.authenticate should verify JWT from Authorization header (Bearer token) for REST endpoints.
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>keyService exports setPublicKey, getPublicKey, getPublicKeys; key routes at POST /api/keys and GET /api/keys/:userId</done>
</task>

<task type="auto">
  <name>Task 2: Create message service and history API</name>
  <files>backend/src/services/messageService.ts, backend/src/routes/messages.ts, backend/src/types/index.ts</files>
  <action>
1. Update backend/src/types/index.ts to add:
   ```typescript
   export interface Message {
     id: number;
     senderId: string;
     recipientId: string;
     encryptedContent: string;
     createdAt: Date;
     deliveredAt: Date | null;
     readAt: Date | null;
   }

   export interface MessageHistoryResponse {
     messages: Message[];
     hasMore: boolean;
   }
   ```

2. Create backend/src/services/messageService.ts:

```typescript
import { query } from '../db/index.js';
import { Message } from '../types/index.js';

class MessageService {
  // Save encrypted message to database
  async saveMessage(
    senderId: string,
    recipientId: string,
    encryptedContent: string
  ): Promise<Message> {
    const result = await query(
      `INSERT INTO messages (sender_id, recipient_id, encrypted_content)
       VALUES ($1, $2, $3)
       RETURNING id, sender_id, recipient_id, encrypted_content, created_at, delivered_at, read_at`,
      [senderId, recipientId, encryptedContent]
    );
    return this.mapRow(result.rows[0]);
  }

  // Get message history between two users (paginated)
  async getHistory(
    userId: string,
    contactId: string,
    limit: number = 50,
    beforeId?: number
  ): Promise<{ messages: Message[]; hasMore: boolean }> {
    let queryText = `
      SELECT id, sender_id, recipient_id, encrypted_content, created_at, delivered_at, read_at
      FROM messages
      WHERE (sender_id = $1 AND recipient_id = $2) OR (sender_id = $2 AND recipient_id = $1)
    `;
    const params: (string | number)[] = [userId, contactId];

    if (beforeId) {
      queryText += ' AND id < $3';
      params.push(beforeId);
    }

    queryText += ' ORDER BY created_at DESC LIMIT $' + (params.length + 1);
    params.push(limit + 1); // Fetch one extra to check hasMore

    const result = await query(queryText, params);
    const hasMore = result.rows.length > limit;
    const messages = result.rows.slice(0, limit).map(this.mapRow);

    return { messages: messages.reverse(), hasMore }; // Return in chronological order
  }

  // Mark message as delivered
  async markDelivered(messageId: number): Promise<void> {
    await query(
      'UPDATE messages SET delivered_at = NOW() WHERE id = $1 AND delivered_at IS NULL',
      [messageId]
    );
  }

  // Mark messages as read
  async markRead(userId: string, contactId: string): Promise<void> {
    await query(
      `UPDATE messages SET read_at = NOW()
       WHERE recipient_id = $1 AND sender_id = $2 AND read_at IS NULL`,
      [userId, contactId]
    );
  }

  private mapRow(row: any): Message {
    return {
      id: row.id,
      senderId: row.sender_id,
      recipientId: row.recipient_id,
      encryptedContent: row.encrypted_content,
      createdAt: row.created_at,
      deliveredAt: row.delivered_at,
      readAt: row.read_at,
    };
  }
}

export const messageService = new MessageService();
```

3. Create backend/src/routes/messages.ts:

```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { messageService } from '../services/messageService.js';

interface HistoryParams {
  contactId: string;
}

interface HistoryQuery {
  limit?: string;
  beforeId?: string;
}

export default async function messageRoutes(fastify: FastifyInstance) {
  // Get message history with a contact
  fastify.get<{ Params: HistoryParams; Querystring: HistoryQuery }>(
    '/messages/:contactId',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Params: HistoryParams; Querystring: HistoryQuery }>, reply: FastifyReply) => {
      const userId = (request.user as { userId: string }).userId;
      const { contactId } = request.params;
      const limit = Math.min(parseInt(request.query.limit || '50', 10), 100);
      const beforeId = request.query.beforeId ? parseInt(request.query.beforeId, 10) : undefined;

      const { messages, hasMore } = await messageService.getHistory(
        userId,
        contactId,
        limit,
        beforeId
      );

      return { messages, hasMore };
    }
  );

  // Mark messages as read
  fastify.post<{ Params: HistoryParams }>(
    '/messages/:contactId/read',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Params: HistoryParams }>, reply: FastifyReply) => {
      const userId = (request.user as { userId: string }).userId;
      const { contactId } = request.params;

      await messageService.markRead(userId, contactId);
      return { success: true };
    }
  );
}
```

4. Register message routes in server.ts:
   ```typescript
   await fastify.register(messageRoutes, { prefix: '/api' });
   ```
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>messageService exports saveMessage, getHistory, markDelivered, markRead; message routes at GET /api/messages/:contactId and POST /api/messages/:contactId/read</done>
</task>

<task type="auto">
  <name>Task 3: Wire WebSocket to message service for real-time delivery</name>
  <files>backend/src/routes/websocket.ts</files>
  <action>
Update backend/src/routes/websocket.ts to handle message sending:

1. Import messageService from '../services/messageService.js'

2. Define incoming message structure:
   ```typescript
   interface IncomingMessage {
     type: 'message';
     recipientId: string;
     encryptedContent: string;
   }

   interface OutgoingMessage {
     type: 'message';
     id: number;
     senderId: string;
     encryptedContent: string;
     timestamp: string;
   }
   ```

3. Update the socket.on('message') handler:
   - Parse incoming JSON
   - Validate message structure
   - Save message to database using messageService.saveMessage()
   - Get the saved message with ID and timestamp
   - Send confirmation back to sender with message ID
   - If recipient is online (in activeConnections), forward the message
   - If forwarded, mark as delivered

```typescript
socket.on('message', async (data) => {
  try {
    const msg: IncomingMessage = JSON.parse(data.toString());

    if (msg.type === 'message') {
      // Save to database
      const saved = await messageService.saveMessage(
        userId,
        msg.recipientId,
        msg.encryptedContent
      );

      // Acknowledge to sender
      socket.send(JSON.stringify({
        type: 'message_ack',
        id: saved.id,
        timestamp: saved.createdAt.toISOString(),
      }));

      // Forward to recipient if online
      const recipientSocket = activeConnections.get(msg.recipientId);
      if (recipientSocket && recipientSocket.readyState === 1) {
        recipientSocket.send(JSON.stringify({
          type: 'message',
          id: saved.id,
          senderId: userId,
          encryptedContent: saved.encryptedContent,
          timestamp: saved.createdAt.toISOString(),
        }));
        await messageService.markDelivered(saved.id);
      }
    }
  } catch (err) {
    fastify.log.error(err, 'WebSocket message handling error');
    socket.send(JSON.stringify({
      type: 'error',
      message: 'Failed to process message',
    }));
  }
});
```

4. Add typing/status message types for future use (stub handlers):
   - type: 'typing' - forward typing indicator to recipient
   - type: 'read' - mark messages as read and notify sender

These can be implemented minimally now or left as TODOs.
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>WebSocket route saves incoming messages to database, forwards to online recipients, sends delivery confirmations</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Service verification:
   - keyService.ts exports keyService with setPublicKey, getPublicKey, getPublicKeys
   - messageService.ts exports messageService with saveMessage, getHistory, markDelivered, markRead

2. Route verification:
   - keys.ts registered at /api with POST /keys and GET /keys/:userId
   - messages.ts registered at /api with GET /messages/:contactId and POST /messages/:contactId/read
   - Both require authentication (preValidation hook)

3. WebSocket verification:
   - websocket.ts handles incoming messages with type: 'message'
   - Messages saved to database with messageService
   - Messages forwarded to online recipients
   - Acknowledgment sent to sender

4. Build verification:
   - npm run build succeeds without errors
</verification>

<success_criteria>
- Public key endpoints work (set own, get other's)
- Message history endpoint returns paginated, chronologically ordered messages
- WebSocket saves messages and forwards to online recipients
- Delivery status tracked (delivered_at timestamp)
- All endpoints require authentication
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-03-SUMMARY.md`
</output>
