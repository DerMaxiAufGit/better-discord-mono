---
phase: 02-e2e-encrypted-messaging
plan: 07
type: execute
wave: 5
depends_on: ["02-06"]
files_modified:
  - frontend/src/pages/MessagesPage.tsx
  - frontend/src/routes/index.tsx
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can select a user and send them a message"
    - "Recipient sees the message appear in real-time"
    - "Messages persist and show after page refresh"
    - "Encryption keys are initialized on login"
    - "Both users can decrypt each other's messages (bidirectional symmetry)"
  artifacts:
    - path: "frontend/src/pages/MessagesPage.tsx"
      provides: "Main messaging page with conversation list and view"
      exports: "MessagesPage"
  key_links:
    - from: "frontend/src/pages/MessagesPage.tsx"
      to: "frontend/src/lib/websocket/useMessaging.ts"
      via: "import hook"
      pattern: "useMessaging"
    - from: "frontend/src/pages/MessagesPage.tsx"
      to: "frontend/src/components/messaging/ConversationView.tsx"
      via: "import component"
      pattern: "ConversationView"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/stores/cryptoStore.ts"
      via: "initialize on auth"
      pattern: "initializeKeys"
    - from: "frontend/src/stores/cryptoStore.ts"
      to: "frontend/src/lib/crypto/keyExchange.ts"
      via: "session key derivation ensures bidirectional symmetry"
      pattern: "deriveSessionKeys"
      note: "CRITICAL VERIFICATION: User A encrypts with tx, User B decrypts with rx. crypto_kx guarantees A.tx == B.rx. Checkpoint must verify BOTH users can decrypt EACH OTHER's messages."
---

<objective>
Create MessagesPage, initialize crypto on login, and verify complete E2E messaging flow with bidirectional encryption.

Purpose: Complete the integration so users can send encrypted messages and verify the E2E encryption promise works bidirectionally
Output: Working E2E encrypted messaging with full integration and human verification of the flow
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md
@.planning/phases/02-e2e-encrypted-messaging/02-04-SUMMARY.md
@.planning/phases/02-e2e-encrypted-messaging/02-05-SUMMARY.md
@.planning/phases/02-e2e-encrypted-messaging/02-06-SUMMARY.md

# Existing codebase references
@frontend/src/App.tsx
@frontend/src/routes/index.tsx
@frontend/src/components/layout/Sidebar.tsx
@frontend/src/stores/auth.ts
@frontend/src/stores/cryptoStore.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MessagesPage with full integration</name>
  <files>frontend/src/pages/MessagesPage.tsx, frontend/src/routes/index.tsx</files>
  <action>
1. Create frontend/src/pages/MessagesPage.tsx:

```typescript
import * as React from 'react';
import { useParams, useNavigate } from 'react-router';
import { ConversationList, ConversationView } from '@/components/messaging';
import { useAuthStore } from '@/stores/auth';
import { useMessageStore } from '@/stores/messageStore';
import { useContactStore } from '@/stores/contactStore';
import { useCryptoStore } from '@/stores/cryptoStore';
import { useMessaging } from '@/lib/websocket/useMessaging';
import { decryptMessage } from '@/lib/crypto/messageEncryption';
import { usersApi } from '@/lib/api';

export function MessagesPage() {
  const { contactId } = useParams<{ contactId?: string }>();
  const navigate = useNavigate();

  const { user } = useAuthStore();
  const { conversations, loadHistory, isLoadingHistory } = useMessageStore();
  const { contacts, addContact, setActiveContact, fetchContactPublicKey } = useContactStore();
  const { getOrDeriveSessionKeys, isInitialized: cryptoReady } = useCryptoStore();
  const { isConnected, sendMessage } = useMessaging();

  // Set active contact when route changes
  React.useEffect(() => {
    setActiveContact(contactId || null);
  }, [contactId, setActiveContact]);

  // Load contact info if navigating directly to a conversation
  React.useEffect(() => {
    if (contactId && !contacts.get(contactId)) {
      usersApi.getUser(contactId).then((contactUser) => {
        addContact({
          id: contactUser.id,
          email: contactUser.email,
          publicKey: null,
        });
      }).catch(console.error);
    }
  }, [contactId, contacts, addContact]);

  // Load message history when contact changes
  React.useEffect(() => {
    if (!contactId || !user || !cryptoReady) return;

    const loadMessages = async () => {
      try {
        // Fetch public key first
        const publicKey = await fetchContactPublicKey(contactId);
        if (!publicKey) {
          console.error('Contact has no public key');
          return;
        }

        // Get session keys for decryption
        // NOTE: Session key derivation uses crypto_kx which guarantees:
        // - User with lower ID (client): tx for encrypt, rx for decrypt
        // - User with higher ID (server): tx for encrypt, rx for decrypt
        // - client.tx == server.rx AND client.rx == server.tx
        // This ensures bidirectional message encryption/decryption works correctly.
        const sessionKeys = await getOrDeriveSessionKeys(user.id, contactId, publicKey);

        // Load and decrypt history
        // Use rx key for decryption - this receives messages FROM the contact
        await loadHistory(contactId, async (encrypted) => {
          return decryptMessage(encrypted, sessionKeys.rx);
        });
      } catch (e) {
        console.error('Failed to load messages:', e);
      }
    };

    loadMessages();
  }, [contactId, user, cryptoReady, fetchContactPublicKey, getOrDeriveSessionKeys, loadHistory]);

  const handleSendMessage = async (content: string) => {
    if (!contactId) return;
    try {
      await sendMessage(contactId, content);
    } catch (e) {
      console.error('Failed to send message:', e);
    }
  };

  const handleSelectConversation = (id: string) => {
    navigate(`/messages/${id}`);
  };

  // Build conversation list from contacts
  const conversationList = React.useMemo(() => {
    return Array.from(contacts.values()).map((contact) => {
      const msgs = conversations.get(contact.id) || [];
      const lastMsg = msgs[msgs.length - 1];
      return {
        contactId: contact.id,
        contactEmail: contact.email,
        lastMessage: lastMsg?.content,
        lastMessageAt: lastMsg?.timestamp,
      };
    }).sort((a, b) => {
      const aTime = a.lastMessageAt?.getTime() || 0;
      const bTime = b.lastMessageAt?.getTime() || 0;
      return bTime - aTime;
    });
  }, [contacts, conversations]);

  const activeContact = contactId ? contacts.get(contactId) : null;
  const activeMessages = contactId ? conversations.get(contactId) || [] : [];

  return (
    <div className="flex h-full">
      {/* Conversation list sidebar */}
      <div className="w-64 border-r flex-shrink-0">
        <div className="p-4 border-b">
          <h2 className="font-semibold">Messages</h2>
        </div>
        <ConversationList
          conversations={conversationList}
          activeId={contactId || null}
          onSelect={handleSelectConversation}
        />
      </div>

      {/* Conversation view */}
      <div className="flex-1">
        {contactId && activeContact && user ? (
          <ConversationView
            contactId={contactId}
            contactEmail={activeContact.email}
            currentUserId={user.id}
            messages={activeMessages}
            onSendMessage={handleSendMessage}
            isConnected={isConnected}
            isLoading={isLoadingHistory}
          />
        ) : (
          <div className="flex items-center justify-center h-full text-muted-foreground">
            Select a conversation or find a user to start chatting
          </div>
        )}
      </div>
    </div>
  );
}
```

2. Update frontend/src/routes/index.tsx to add MessagesPage routes:
   - Import MessagesPage from pages
   - Add route: { path: '/messages', element: <ProtectedRoute><MessagesPage /></ProtectedRoute> }
   - Add route: { path: '/messages/:contactId', element: <ProtectedRoute><MessagesPage /></ProtectedRoute> }
  </action>
  <verify>npm run build compiles without errors in frontend</verify>
  <done>MessagesPage with conversation list and view; routes at /messages and /messages/:contactId configured</done>
</task>

<task type="auto">
  <name>Task 2: Initialize crypto on login and update sidebar navigation</name>
  <files>frontend/src/App.tsx, frontend/src/components/layout/Sidebar.tsx</files>
  <action>
1. Update frontend/src/App.tsx to initialize crypto after auth:

```typescript
// Add import:
import { useCryptoStore } from '@/stores/cryptoStore';

// Inside App component, after existing useEffect for checkAuth:
const { initializeKeys } = useCryptoStore();
const { isAuthenticated, user } = useAuthStore();

React.useEffect(() => {
  // Initialize encryption keys after successful authentication
  if (isAuthenticated && user) {
    initializeKeys(user.id).catch((e) => {
      console.error('Failed to initialize encryption keys:', e);
    });
  }
}, [isAuthenticated, user, initializeKeys]);
```

2. Update frontend/src/components/layout/Sidebar.tsx:
   - Add imports: import { MessageCircle, Users } from 'lucide-react'
   - Add imports: import { Link, useLocation } from 'react-router'
   - Add navigation items for Messages and Contacts:

```typescript
// Add to imports at top
import { MessageCircle, Users, LogOut, Moon, Sun } from 'lucide-react';
import { Link, useLocation } from 'react-router';

// Inside Sidebar component:
const location = useLocation();

// Navigation items (add above theme toggle section)
const navItems = [
  { href: '/messages', icon: MessageCircle, label: 'Messages' },
  { href: '/contacts', icon: Users, label: 'Contacts' },
];

// In the JSX, add navigation section:
<nav className="flex-1 p-2 space-y-1">
  {navItems.map((item) => {
    const Icon = item.icon;
    const isActive = location.pathname.startsWith(item.href);
    return (
      <Link
        key={item.href}
        to={item.href}
        className={cn(
          'flex items-center gap-3 px-3 py-2 rounded-lg transition-colors',
          'hover:bg-accent',
          isActive && 'bg-accent',
          !isExpanded && 'justify-center'
        )}
      >
        <Icon className="h-5 w-5" />
        {isExpanded && <span>{item.label}</span>}
      </Link>
    );
  })}
</nav>
```

3. Clear crypto keys on logout in Sidebar:
   - Import useCryptoStore
   - In logout handler, also call useCryptoStore.getState().clearKeys()
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>Crypto initialized on login, sidebar has Messages and Contacts navigation, keys cleared on logout</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete E2E encrypted messaging system with:
    - Key generation and storage in IndexedDB
    - Public key exchange via server
    - Session key derivation for each contact (with bidirectional symmetry via crypto_kx)
    - Message encryption/decryption with libsodium
    - Real-time delivery via WebSocket
    - Message history persistence and retrieval
    - Messaging UI with conversation list and message view
  </what-built>
  <how-to-verify>
    1. Start the application:
       ```bash
       docker compose up -d --build
       ```

    2. Open browser and go to http://localhost (or your configured port)

    3. Create two accounts:
       - Open browser window 1, sign up as user1@test.com
       - Open browser window 2 (or incognito), sign up as user2@test.com

    4. Test contact discovery:
       - In window 1, go to Contacts page
       - Search for or find user2@test.com
       - Click "Message" button

    5. **CRITICAL: Test bidirectional messaging (verifies session key symmetry)**
       - In window 1 (user1), send a message: "Hello from user1"
       - In window 2 (user2), verify message appears and is readable
       - In window 2 (user2), reply: "Hello from user2"
       - In window 1 (user1), verify reply appears and is readable
       - **Both directions must decrypt successfully - this proves crypto_kx bidirectional symmetry is working**

    6. Test persistence:
       - Refresh both browser windows
       - Go to Messages page
       - Verify message history is loaded and decrypted correctly for BOTH users

    7. Verify encryption (optional advanced check):
       - Connect to database: psql -h 172.16.70.14 -U dev -d chatapp
       - Query: SELECT encrypted_content FROM messages LIMIT 5;
       - Verify content is base64-encoded ciphertext (not readable plaintext)

    Expected results:
    - Messages appear instantly for both users
    - BOTH users can read messages from EACH OTHER (bidirectional)
    - Messages persist across page refresh
    - Database shows encrypted (unreadable) message content
    - E2E encryption indicator shows in conversation header
  </how-to-verify>
  <resume-signal>Type "verified" if all tests pass (especially bidirectional messaging), or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Frontend verification:
   - MessagesPage integrates all stores and WebSocket hook
   - Routes configured for /messages and /messages/:contactId
   - Crypto keys initialized on login, cleared on logout
   - Sidebar has navigation to Messages and Contacts

2. Integration verification:
   - Complete flow works: login -> find contact -> send message -> receive message
   - **Bidirectional messaging works: user A sends to B, B receives; B sends to A, A receives**
   - Messages persist and decrypt after refresh
   - WebSocket reconnects automatically

3. Build verification:
   - npm run build succeeds for frontend
</verification>

<success_criteria>
Phase 2 Success Criteria (from ROADMAP.md):
1. User can send message to another user and see it appear in real-time
2. User can view message history with a contact after logging back in
3. Messages stored on server cannot be decrypted without client keys
4. User's encryption keys never leave their device unencrypted
5. **Bidirectional encryption works: both users can decrypt each other's messages**

All criteria verifiable via human checkpoint.
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-07-SUMMARY.md`
</output>
