---
phase: 02-e2e-encrypted-messaging
plan: 06
type: execute
wave: 4
depends_on: ["02-04", "02-05"]
files_modified:
  - frontend/src/pages/MessagesPage.tsx
  - frontend/src/pages/ContactsPage.tsx
  - frontend/src/routes/index.tsx
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/src/App.tsx
  - backend/src/routes/users.ts
  - backend/src/server.ts
autonomous: false

must_haves:
  truths:
    - "User can see list of users to start conversations"
    - "User can select a user and send them a message"
    - "Recipient sees the message appear in real-time"
    - "Messages persist and show after page refresh"
    - "Encryption keys are initialized on login"
  artifacts:
    - path: "frontend/src/pages/MessagesPage.tsx"
      provides: "Main messaging page with conversation list and view"
      exports: "MessagesPage"
    - path: "frontend/src/pages/ContactsPage.tsx"
      provides: "User directory to start new conversations"
      exports: "ContactsPage"
    - path: "backend/src/routes/users.ts"
      provides: "User list endpoint for contact discovery"
      exports: "default (Fastify plugin)"
  key_links:
    - from: "frontend/src/pages/MessagesPage.tsx"
      to: "frontend/src/lib/websocket/useMessaging.ts"
      via: "import hook"
      pattern: "useMessaging"
    - from: "frontend/src/pages/MessagesPage.tsx"
      to: "frontend/src/components/messaging/ConversationView.tsx"
      via: "import component"
      pattern: "ConversationView"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/stores/cryptoStore.ts"
      via: "initialize on auth"
      pattern: "initializeKeys"
---

<objective>
Wire all pieces together: create messaging page, contacts page, initialize encryption on login, and verify the complete E2E messaging flow.

Purpose: Complete the integration so users can discover contacts, send encrypted messages, and verify the E2E encryption promise
Output: Working E2E encrypted messaging with contacts page, full integration, and human verification of the flow
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-e2e-encrypted-messaging/02-RESEARCH.md
@.planning/phases/02-e2e-encrypted-messaging/02-04-SUMMARY.md
@.planning/phases/02-e2e-encrypted-messaging/02-05-SUMMARY.md

# Existing codebase references
@frontend/src/App.tsx
@frontend/src/routes/index.tsx
@frontend/src/components/layout/Sidebar.tsx
@frontend/src/stores/auth.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create users API endpoint for contact discovery</name>
  <files>backend/src/routes/users.ts, backend/src/server.ts</files>
  <action>
1. Create backend/src/routes/users.ts:

```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { query } from '../db/index.js';

interface UserListQuery {
  search?: string;
}

export default async function userRoutes(fastify: FastifyInstance) {
  // Get list of users (for contact discovery)
  fastify.get<{ Querystring: UserListQuery }>(
    '/users',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Querystring: UserListQuery }>, reply: FastifyReply) => {
      const currentUserId = (request.user as { userId: string }).userId;
      const { search } = request.query;

      let queryText = `
        SELECT id, email, created_at
        FROM users
        WHERE id != $1
      `;
      const params: (string)[] = [currentUserId];

      if (search) {
        queryText += ` AND email ILIKE $2`;
        params.push(`%${search}%`);
      }

      queryText += ` ORDER BY email ASC LIMIT 50`;

      const result = await query(queryText, params);

      return {
        users: result.rows.map((row) => ({
          id: row.id,
          email: row.email,
          createdAt: row.created_at,
        })),
      };
    }
  );

  // Get single user by ID
  fastify.get<{ Params: { userId: string } }>(
    '/users/:userId',
    { preValidation: [fastify.authenticate] },
    async (request: FastifyRequest<{ Params: { userId: string } }>, reply: FastifyReply) => {
      const { userId } = request.params;

      const result = await query(
        'SELECT id, email, created_at FROM users WHERE id = $1',
        [userId]
      );

      if (result.rows.length === 0) {
        return reply.code(404).send({ error: 'User not found' });
      }

      const user = result.rows[0];
      return {
        id: user.id,
        email: user.email,
        createdAt: user.created_at,
      };
    }
  );
}
```

2. Register users routes in backend/src/server.ts:
   ```typescript
   import userRoutes from './routes/users.js';
   // After other route registrations:
   await fastify.register(userRoutes, { prefix: '/api' });
   ```
  </action>
  <verify>npm run build compiles without errors in backend</verify>
  <done>Users API at GET /api/users (with search) and GET /api/users/:userId for contact discovery</done>
</task>

<task type="auto">
  <name>Task 2: Create MessagesPage and ContactsPage with routing</name>
  <files>frontend/src/pages/MessagesPage.tsx, frontend/src/pages/ContactsPage.tsx, frontend/src/routes/index.tsx, frontend/src/lib/api.ts</files>
  <action>
1. Add users API to frontend/src/lib/api.ts:

```typescript
// Add to existing api.ts

export const usersApi = {
  // Get list of users for contact discovery
  getUsers: async (search?: string): Promise<{ users: { id: string; email: string }[] }> => {
    const params = search ? `?search=${encodeURIComponent(search)}` : '';
    return apiFetch(`/api/users${params}`);
  },

  // Get single user
  getUser: async (userId: string): Promise<{ id: string; email: string }> => {
    return apiFetch(`/api/users/${userId}`);
  },
};
```

2. Create frontend/src/pages/ContactsPage.tsx:

```typescript
import * as React from 'react';
import { useNavigate } from 'react-router';
import { Search, MessageCircle } from 'lucide-react';
import { Avatar } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { usersApi } from '@/lib/api';
import { useContactStore } from '@/stores/contactStore';

interface User {
  id: string;
  email: string;
}

export function ContactsPage() {
  const [users, setUsers] = React.useState<User[]>([]);
  const [search, setSearch] = React.useState('');
  const [isLoading, setIsLoading] = React.useState(true);
  const navigate = useNavigate();
  const { addContact } = useContactStore();

  React.useEffect(() => {
    const fetchUsers = async () => {
      setIsLoading(true);
      try {
        const { users } = await usersApi.getUsers(search || undefined);
        setUsers(users);
      } catch (e) {
        console.error('Failed to fetch users:', e);
      } finally {
        setIsLoading(false);
      }
    };

    const debounce = setTimeout(fetchUsers, 300);
    return () => clearTimeout(debounce);
  }, [search]);

  const startConversation = (user: User) => {
    // Add to contacts store
    addContact({
      id: user.id,
      email: user.email,
      publicKey: null, // Will be fetched when opening conversation
    });
    // Navigate to messages with this contact
    navigate(`/messages/${user.id}`);
  };

  return (
    <div className="p-6 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">Find Users</h1>

      <div className="relative mb-6">
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
        <Input
          type="text"
          placeholder="Search by email..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="pl-10"
        />
      </div>

      {isLoading ? (
        <div className="text-center text-muted-foreground py-8">Loading...</div>
      ) : users.length === 0 ? (
        <div className="text-center text-muted-foreground py-8">
          {search ? 'No users found' : 'No other users yet'}
        </div>
      ) : (
        <div className="space-y-2">
          {users.map((user) => (
            <div
              key={user.id}
              className="flex items-center gap-3 p-4 rounded-lg border hover:bg-accent transition-colors"
            >
              <Avatar fallback={user.email} className="h-10 w-10" />
              <div className="flex-1">
                <p className="font-medium">{user.email}</p>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => startConversation(user)}
              >
                <MessageCircle className="h-4 w-4 mr-2" />
                Message
              </Button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

3. Create frontend/src/pages/MessagesPage.tsx:

```typescript
import * as React from 'react';
import { useParams, useNavigate } from 'react-router';
import { ConversationList, ConversationView } from '@/components/messaging';
import { useAuthStore } from '@/stores/auth';
import { useMessageStore } from '@/stores/messageStore';
import { useContactStore } from '@/stores/contactStore';
import { useCryptoStore } from '@/stores/cryptoStore';
import { useMessaging } from '@/lib/websocket/useMessaging';
import { decryptMessage } from '@/lib/crypto/messageEncryption';
import { usersApi } from '@/lib/api';

export function MessagesPage() {
  const { contactId } = useParams<{ contactId?: string }>();
  const navigate = useNavigate();

  const { user } = useAuthStore();
  const { conversations, loadHistory, isLoadingHistory } = useMessageStore();
  const { contacts, addContact, setActiveContact, fetchContactPublicKey } = useContactStore();
  const { getOrDeriveSessionKeys, isInitialized: cryptoReady } = useCryptoStore();
  const { isConnected, sendMessage } = useMessaging();

  // Set active contact when route changes
  React.useEffect(() => {
    setActiveContact(contactId || null);
  }, [contactId, setActiveContact]);

  // Load contact info if navigating directly to a conversation
  React.useEffect(() => {
    if (contactId && !contacts.get(contactId)) {
      usersApi.getUser(contactId).then((contactUser) => {
        addContact({
          id: contactUser.id,
          email: contactUser.email,
          publicKey: null,
        });
      }).catch(console.error);
    }
  }, [contactId, contacts, addContact]);

  // Load message history when contact changes
  React.useEffect(() => {
    if (!contactId || !user || !cryptoReady) return;

    const loadMessages = async () => {
      try {
        // Fetch public key first
        const publicKey = await fetchContactPublicKey(contactId);
        if (!publicKey) {
          console.error('Contact has no public key');
          return;
        }

        // Get session keys for decryption
        const sessionKeys = await getOrDeriveSessionKeys(user.id, contactId, publicKey);

        // Load and decrypt history
        await loadHistory(contactId, async (encrypted) => {
          return decryptMessage(encrypted, sessionKeys.rx);
        });
      } catch (e) {
        console.error('Failed to load messages:', e);
      }
    };

    loadMessages();
  }, [contactId, user, cryptoReady, fetchContactPublicKey, getOrDeriveSessionKeys, loadHistory]);

  const handleSendMessage = async (content: string) => {
    if (!contactId) return;
    try {
      await sendMessage(contactId, content);
    } catch (e) {
      console.error('Failed to send message:', e);
    }
  };

  const handleSelectConversation = (id: string) => {
    navigate(`/messages/${id}`);
  };

  // Build conversation list from contacts
  const conversationList = React.useMemo(() => {
    return Array.from(contacts.values()).map((contact) => {
      const msgs = conversations.get(contact.id) || [];
      const lastMsg = msgs[msgs.length - 1];
      return {
        contactId: contact.id,
        contactEmail: contact.email,
        lastMessage: lastMsg?.content,
        lastMessageAt: lastMsg?.timestamp,
      };
    }).sort((a, b) => {
      const aTime = a.lastMessageAt?.getTime() || 0;
      const bTime = b.lastMessageAt?.getTime() || 0;
      return bTime - aTime;
    });
  }, [contacts, conversations]);

  const activeContact = contactId ? contacts.get(contactId) : null;
  const activeMessages = contactId ? conversations.get(contactId) || [] : [];

  return (
    <div className="flex h-full">
      {/* Conversation list sidebar */}
      <div className="w-64 border-r flex-shrink-0">
        <div className="p-4 border-b">
          <h2 className="font-semibold">Messages</h2>
        </div>
        <ConversationList
          conversations={conversationList}
          activeId={contactId || null}
          onSelect={handleSelectConversation}
        />
      </div>

      {/* Conversation view */}
      <div className="flex-1">
        {contactId && activeContact && user ? (
          <ConversationView
            contactId={contactId}
            contactEmail={activeContact.email}
            currentUserId={user.id}
            messages={activeMessages}
            onSendMessage={handleSendMessage}
            isConnected={isConnected}
            isLoading={isLoadingHistory}
          />
        ) : (
          <div className="flex items-center justify-center h-full text-muted-foreground">
            Select a conversation or find a user to start chatting
          </div>
        )}
      </div>
    </div>
  );
}
```

4. Update frontend/src/routes/index.tsx to add new routes:
   - Import MessagesPage and ContactsPage
   - Add route: { path: '/messages', element: <ProtectedRoute><MessagesPage /></ProtectedRoute> }
   - Add route: { path: '/messages/:contactId', element: <ProtectedRoute><MessagesPage /></ProtectedRoute> }
   - Add route: { path: '/contacts', element: <ProtectedRoute><ContactsPage /></ProtectedRoute> }
  </action>
  <verify>npm run build compiles without errors in frontend</verify>
  <done>MessagesPage with conversation list and view; ContactsPage for user discovery; Routes configured</done>
</task>

<task type="auto">
  <name>Task 3: Initialize crypto on login and update sidebar navigation</name>
  <files>frontend/src/App.tsx, frontend/src/components/layout/Sidebar.tsx</files>
  <action>
1. Update frontend/src/App.tsx to initialize crypto after auth:

```typescript
// Add import:
import { useCryptoStore } from '@/stores/cryptoStore';

// Inside App component, after existing useEffect for checkAuth:
const { initializeKeys } = useCryptoStore();
const { isAuthenticated, user } = useAuthStore();

React.useEffect(() => {
  // Initialize encryption keys after successful authentication
  if (isAuthenticated && user) {
    initializeKeys(user.id).catch((e) => {
      console.error('Failed to initialize encryption keys:', e);
    });
  }
}, [isAuthenticated, user, initializeKeys]);
```

2. Update frontend/src/components/layout/Sidebar.tsx:
   - Add imports: import { MessageCircle, Users } from 'lucide-react'
   - Add imports: import { Link, useLocation } from 'react-router'
   - Add navigation items for Messages and Contacts:

```typescript
// Add to imports at top
import { MessageCircle, Users, LogOut, Moon, Sun } from 'lucide-react';
import { Link, useLocation } from 'react-router';

// Inside Sidebar component:
const location = useLocation();

// Navigation items (add above theme toggle section)
const navItems = [
  { href: '/messages', icon: MessageCircle, label: 'Messages' },
  { href: '/contacts', icon: Users, label: 'Contacts' },
];

// In the JSX, add navigation section:
<nav className="flex-1 p-2 space-y-1">
  {navItems.map((item) => {
    const Icon = item.icon;
    const isActive = location.pathname.startsWith(item.href);
    return (
      <Link
        key={item.href}
        to={item.href}
        className={cn(
          'flex items-center gap-3 px-3 py-2 rounded-lg transition-colors',
          'hover:bg-accent',
          isActive && 'bg-accent',
          !isExpanded && 'justify-center'
        )}
      >
        <Icon className="h-5 w-5" />
        {isExpanded && <span>{item.label}</span>}
      </Link>
    );
  })}
</nav>
```

3. Clear crypto keys on logout in Sidebar:
   - Import useCryptoStore
   - In logout handler, also call useCryptoStore.getState().clearKeys()
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>Crypto initialized on login, sidebar has Messages and Contacts navigation, keys cleared on logout</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete E2E encrypted messaging system with:
    - Key generation and storage in IndexedDB
    - Public key exchange via server
    - Session key derivation for each contact
    - Message encryption/decryption with libsodium
    - Real-time delivery via WebSocket
    - Message history persistence and retrieval
    - Messaging UI with conversation list and message view
  </what-built>
  <how-to-verify>
    1. Start the application:
       ```bash
       docker compose up -d --build
       ```

    2. Open browser and go to http://localhost (or your configured port)

    3. Create two accounts:
       - Open browser window 1, sign up as user1@test.com
       - Open browser window 2 (or incognito), sign up as user2@test.com

    4. Test contact discovery:
       - In window 1, go to Contacts page
       - Search for or find user2@test.com
       - Click "Message" button

    5. Test messaging:
       - In window 1, send a message to user2
       - In window 2, go to Messages page - message should appear in real-time
       - Reply from window 2
       - Verify message appears in window 1

    6. Test persistence:
       - Refresh both browser windows
       - Go to Messages page
       - Verify message history is loaded and decrypted correctly

    7. Verify encryption (optional advanced check):
       - Connect to database: psql -h 172.16.70.14 -U dev -d chatapp
       - Query: SELECT encrypted_content FROM messages LIMIT 5;
       - Verify content is base64-encoded ciphertext (not readable plaintext)

    Expected results:
    - Messages appear instantly for both users
    - Messages persist across page refresh
    - Database shows encrypted (unreadable) message content
    - E2E encryption indicator shows in conversation header
  </how-to-verify>
  <resume-signal>Type "verified" if all tests pass, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Backend verification:
   - users.ts registered at /api with GET /users and GET /users/:userId
   - All routes require authentication

2. Frontend verification:
   - MessagesPage integrates all stores and WebSocket hook
   - ContactsPage allows user discovery and starting conversations
   - Routes configured for /messages, /messages/:contactId, /contacts
   - Crypto keys initialized on login, cleared on logout
   - Sidebar has navigation to Messages and Contacts

3. Integration verification:
   - Complete flow works: login -> find contact -> send message -> receive message
   - Messages persist and decrypt after refresh
   - WebSocket reconnects automatically

4. Build verification:
   - npm run build succeeds for both frontend and backend
</verification>

<success_criteria>
Phase 2 Success Criteria (from ROADMAP.md):
1. User can send message to another user and see it appear in real-time
2. User can view message history with a contact after logging back in
3. Messages stored on server cannot be decrypted without client keys
4. User's encryption keys never leave their device unencrypted

All criteria verifiable via human checkpoint.
</success_criteria>

<output>
After completion, create `.planning/phases/02-e2e-encrypted-messaging/02-06-SUMMARY.md`
</output>
